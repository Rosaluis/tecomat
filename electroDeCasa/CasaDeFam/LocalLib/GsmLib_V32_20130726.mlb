(*` {CSY}Knihovna vývojového systému Mosaic{ENU}Mosaic IDE library *)
(*` {CSY}Jméno souboru{ENU}File name{} : D:\TecoUserLibs\GsmLib_V32_20130726.mlb *)
(*` {CSY}Knihovna : GsmLib{ENU}Library : GsmLib{} 3.2 *)
(*` {CSY}Autor{ENU}Author{} : Teco a.s. *)
(*` {CSY}Autorská práva{ENU}Copyright{} : (c) 2008 - 2013 *)
(*` {CSY}Verze IEC pøekladaèe{ENU}IEC compiler version{} : 3.8.17.0 *)
(*` {CSY}Verze assembleru{ENU}Assembler version{} : 4.3.00 *)

//{Knihovna : GsmLib 3.2  }
(*` {CSY}Historie{ENU}History{}: *)
(*`
{CSY}
v1.0 18.04.2008 Byd První verze knihovny
v1.1 12.05.2008 Byd Pøidáno ošetøení tvrdé chyby
v1.2 02.06.2008 Byd Prodloužení timeoutù
v1.3 16.06.2008 Byd Pøidáno vytáèení èísel
v1.4 17.06.2008 Byd Odstranìna kolize vytáèení èísel a posílání SMS
v1.5 24.08.2008 Byd Pøidán studený restart modemu a aktivní odmítnuti hovoru
v2.0 23.03.2009 Byd Využití komunikaèní knihovny ComLib
                    Hlášení pøi chybìjícím textu zprávy a nezdaøeném odeslání USSD
                    Pøidán blok SMS_Handler2 
v2.1 03.04.2009 Byd Opraveno hlášení pøi prázdném textu SMS
v2.2 23.09.2009 Byd Pøidána obsluha statusù zpráv
v2.3 03.02.2010 Byd Neveøejná verze
v2.4 02.09.2010 Byd Pøidáno poèítání prozvonìní 1 až 3
                    Pøidán blok SMS_HANDLER3 pro odesílání zpráv obsahující znak 0, 
		    který nelze pøedat v typu STRING
v2.5 04.11.2010 Byd Upravena inicializace STRING
v2.6 08.12.2010 Byd Doplnìny komentáøe, skryty vnitønì používané funkce a promìnné
v2.7 17.02.2011 Byd 
v2.8 11.05.2011 Byd Doplnìna podpora CP1255
v2.9 05.01.2012 Byd Pøidán stav pro vypnutí kompatibility s MC20
v3.0 23.04.2012 Byd Pøidán blok pro odesílání SMS pøes TCP spojení pro modem ER75i
                    Opravena kontrola velikosti vysílacích zón pro SMS_HANDLER_2 a 3
v3.1 12.04.2013 Byd Odstranìní globální promìnné z fbSendSmsTcp_ER75i
v3.2 26.07.2013 Byd Vylepšení detekce RING
{ENG}
v1.0 2008-04-18 Byd First version of library
v1.1 2008-05-12 Byd Handling of hard error added 
v1.2 2008-06-02 Byd Timeout extended 
v1.3 2008-06-16 Byd Number dialing added  
v1.4 2008-06-17 Byd Removed collision betweem dialing and SMS sending
v1.5 2008-08-24 Byd Added modem cold restart and active incoming call rejection 
v2.0 2009-03-23 Byd ComLib library used
                    Errors added when text of SMS is missing and when USSD sending 
fails
                    Block SMS_Handler2 added                  
v2.1 2009-04-03 Byd Error text corrected when text of SMS is missing
v2.2 2009-09-23 Byd Handling of SMS status added  
v2.3 2010-02-03 Byd Non-public version
v2.4 2010-09-02 Byd Added counting of ring (1 to 3)
                    Added SMS_HANDLER3 block for sending messages containing the 
		    character 0, which cann't be passed in a STRING type higher.
v2.5 2010-11-04 Byd Inicialization of STRING modified
v2.6 2010-12-08 Byd Comments added, internal function and variables hiddden 
v2.7 2011-02-17 Byd 
v2.8 2011-05-11 Byd Support for CP1255 added
v2.9 2012-01-05 Byd State to disable MC20 compatibility mode added
v3.0 2012-04-23 Byd Added blok for sending SMS via TCP connection on ER75i modem
                    Check of size of transmitting zones for SMS_HANDLER_2 a 3 
v3.1 2013-04-12 Byd Global variable removed from fbSendSmsTcp_ER75i
v3.2 26.07.2013 Byd Improved detection of RING
*)

(*----------------------------------------------------------------------------*)
{LIBRARY="LOCALLIB\STDLIB_V20_20100519.MLB"}
{LIBRARY="LOCALLIB\SYSLIB_V31_20120621.MLB"}
{LIBRARY="LOCALLIB\COMLIB_V19_20120614.MLB"}

VAR_GLOBAL CONSTANT
 _GsmLib_CommaString {HIDDEN} : string [1] :=  ',';
 _GsmLib_ColonString {HIDDEN} : string [1] :=  ':';
 _GsmLib_GreaterThanString {HIDDEN} : string [1] :=  '>';
 _GsmLib_PlusString {HIDDEN} : string [1] :=  '+';
 _GsmLib_OkString {HIDDEN} : string [2] :=  'OK';
 _GsmLib_QuoteString {HIDDEN} : string [1] :=  '"';
 _GsmLib_CrLfString {HIDDEN} : string [2] :=  '$r$n';
 _GsmLib_QuoteCrLfString {HIDDEN} : string [3] :=  '"$r$n';
 _GsmLib_SemiColonCrLfString {HIDDEN} : string [3] :=  ';$r$n';
 _GsmLib_ControlZString {HIDDEN} : string [1] :=  '$1A';
 _GsmLib_AtCommandATE0 {HIDDEN} : string [6] :=  'ATE0$r$n';
 _GsmLib_AtCommandATIPR {HIDDEN} : string [13] :=  'AT+IPR=9600$r$n';
 _GsmLib_AtCommandATCFUN {HIDDEN} : string [13] :=  'AT+CFUN=1,1$r$n';
 _GsmLib_AtCommandATCPIN1 {HIDDEN} : string [10] :=  'AT+CPIN?$r$n';
 _GsmLib_AtCommandATCPIN2 {HIDDEN} : string [8] :=  'AT+CPIN=';
 _GsmLib_AtCommandATCMEE {HIDDEN} : string [11] :=  'AT+CMEE=2$r$n';
 _GsmLib_AtCommandATCMGF0 {HIDDEN} : string [11] :=  'AT+CMGF=0$r$n';
 _GsmLib_AtCommandATCMGF1 {HIDDEN} : string [11] :=  'AT+CMGF=1$r$n';
 _GsmLib_AtCommandATCNMI {HIDDEN} : string [15] :=  'AT+CNMI=3,1,0$r$n';
 _GsmLib_AtCommandATCPMS {HIDDEN} : string [18] :=  'AT+CPMS=SM,SM,SM$r$n';
 _GsmLib_AtCommandATSSMSS {HIDDEN} : string [12] :=  'AT^SSMSS=1$r$n';
 _GsmLib_AtCommandATCSCA {HIDDEN} : string [9] :=  'AT+CSCA="';
 _GsmLib_AtCommandATCMGD {HIDDEN} : string [9] :=  'AT+CMGD=';
 _GsmLib_AtCommandATD {HIDDEN} : string [3] :=  'ATD';
 _GsmLib_AtCommandATCMGS1 {HIDDEN} : string [9] :=  'AT+CMGS="';
 _GsmLib_AtCommandATCMGS2 {HIDDEN} : string [9] :=  'AT+CMGS=';
 _GsmLib_AtCommandATCMGR {HIDDEN} : string [8] :=  'AT+CMGR=';
 _GsmLib_AtCommandATCSQ {HIDDEN} : string [8] :=  'AT+CSQ$r$n';
 _GsmLib_AtCommandATCLCC {HIDDEN} : string [9] :=  'AT+CLCC$r$n';
 _GsmLib_AtCommandATH {HIDDEN} : string [5] :=  'ATH$r$n';
 _GsmLib_AtReplyRING {HIDDEN} : string [4] :=  'RING';
 _GsmLib_AtReplyCMTI {HIDDEN} : string [6] :=  '+CMTI:';
 _GsmLib_AtReplySYSSTART {HIDDEN} : string [9] :=  '^SYSSTART';
 _GsmLib_AtReplyCPIN {HIDDEN} : string [6] :=  '+CPIN:';
 _GsmLib_AtReplyREADY {HIDDEN} : string [5] :=  'READY';
 _GsmLib_AtReplySIMPIN {HIDDEN} : string [7] :=  'SIM PIN';
 _GsmLib_AtReplySIMPUK {HIDDEN} : string [7] :=  'SIM PUK';
 _GsmLib_AtReplyCPMS {HIDDEN} : string [6] :=  '+CPMS:';
 _GsmLib_AtReplyCMGS {HIDDEN} : string [6] :=  '+CMGS:';
 _GsmLib_AtReplyCUSD {HIDDEN} : string [6] :=  '+CUSD:';
 _GsmLib_AtReplyCMGR {HIDDEN} : string [6] :=  '+CMGR:';
 _GsmLib_AtReplyERROR {HIDDEN} : string [5] :=  'ERROR';
 _GsmLib_AtReplyCSQ {HIDDEN} : string [5] :=  '+CSQ:';
 _GsmLib_AtReplyCLCC {HIDDEN} : string [6] :=  '+CLCC:';
 _GsmLib_AtReplyNOCARRIER {HIDDEN} : string [10] :=  'NO CARRIER';
 _GsmLib_AtReplyATSM20_0 {HIDDEN} : string [11] :=  'AT^SM20=0$r$n';  (*`modify ATD behaviour*)

END_VAR

TYPE TGSMGateStateOut :   (*`{CSY}initicializace{ENU}initialization*)
  (ggso_Init,  (*`{CSY}initicializace{ENU}initialization*)
   ggso_BaudRate,  (*`{CSY}nastavení komunikaèní rychlostí{ENU}setting of baud rate*)
   ggso_Reset,  (*`{CSY}studený reset GSM brány{ENU}cold reset of GSM gate*)
   ggso_Pin,  (*`{CSY}kontrola stavu PIN{ENU}checking PIN status*)
   ggso_PinValue,  (*`{CSY}posílání hodnoty PIN{ENU}sending PIN value*)
   ggso_Conf1,  (*`{CSY}nastavení formátu chyb{ENU}setting of error format*)
   ggso_Conf2,  (*`{CSY}nastavení formátu SMS{ENU}setting of SMS format*)
   ggso_Conf3,  (*`{CSY}nastavení oznamování SMS{ENU}setting of SMS acknowledges*)
   ggso_Conf4,  (*`{CSY}nastavení úložištì SMS - krok 1{ENU}setting of SMS storage - step 1*)
   ggso_Conf5,  (*`{CSY}nastavení úložištì SMS - krok 2{ENU}setting of SMS storage - step 2*)
   ggso_Center,  (*`{CSY}nastevení SMS centra{ENU}setting of SMS center*)
   ggso_EraseQuery,  (*`{CSY}žádost o smazání{ENU}query to erase*)
   ggso_Erase,  (*`{CSY}mazání SMS{ENU}erasing SMSs*)
   ggso_EraseOne,  (*`{CSY}mazání jedné SMS{ENU}erasing one SMS*)
   ggso_ReadQuery,  (*`{CSY}žádost o ètení{ENU}query to read*)
   ggso_Read,  (*`{CSY}ètení SMS{ENU}reading SMS*)
   ggso_ReadOk,  (*`{CSY}ètení potvrzení ètení{ENU}reading read acknowledge*)
   ggso_SendText,  (*`{CSY}odesílání textu SMS{ENU}sending text SMS*)
   ggso_Send,  (*`{CSY}inicializace posílání SMS{ENU}initialize sending of SMS*)
   ggso_Ussd,  (*`{CSY}posílání USSD{ENU}sending USSD*)
   ggso_SignalQ,  (*`{CSY}kontrola kvality signálu{ENU}checking signal quality*)
   ggso_RingNumber,  (*`{CSY}ètení èísla pøíchozího hovoru{ENU}reading number of incoming call*)
   ggso_Ringing,  (*`{CSY}vyzvánìní{ENU}ringing*)
   ggso_CancelCall,  (*`{CSY}pokládání hovoru{ENU}canceling call*)
   ggso_Error,  (*`{CSY}chybový stav, èekání na timeout{ENU}error state, waiting for timeout*)
   ggso_ReadOctets,  (*`{CSY}ètení SMS v PDU formátu{ENU}read SMS in PDU format*)
   ggso_Conf6,  (*`{CSY}vypnutí módu kompatibility s MC20{ENU}disable MC20 compatibility mode*)
   ggso_Send1Part 
  );
END_TYPE

TYPE TGSMGateError :   (*`{CSY}bez chyby{ENU}no error*)
  (gger_None,  (*`{CSY}bez chyby{ENU}no error*)
   gger_No_Pin,  (*`{CSY}PIN je prázdný{ENU}PIN is empty*)
   gger_Pin_Error,  (*`{CSY}posílání PINu selhalo{ENU}sending PIN failed*)
   gger_Puk_Required,  (*`{CSY}SIM karta vyžaduje PUK{ENU}SIM card requires PUK*)
   gger_Cfg_Error,  (*`{CSY}chyba pøi konfiguraci GSM brány{ENU}error during GSM gate configuration*)
   gger_Erase_Failed,  (*`{CSY}mazání SMS selhalo{ENU}erasing of SMS failed*)
   gger_SMS_Center_Error,  (*`{CSY}èíslo centra služeb odmítnuto{ENU}SMS center number rejected*)
   gger_No_Center_Number,  (*`{CSY}èíslo centra služeb je prázdné{ENU}SMS center number is empty*)
   gger_No_Recipient_Number,  (*`{CSY}èíslo pøíjemce je prázdné{ENU}recipient number is empty*)
   gger_Sending_failed,  (*`{CSY}odesílání SMS zprávy selhalo{ENU}sending of SMS message failed*)
   gger_Receiving_failed,  (*`{CSY}pøíjem SMS zprávy selhalo{ENU}receiving of SMS failed*)
   gger_Receiving_OK_Missing,  (*`{CSY}pøíjem SMS zprávy nebyl potvrzen{ENU}receiving of SMS was not acknowledged*)
   gger_Channel_error,  (*`{CSY}chyba seriového kanálu{ENU}serial channel error*)
   gger_Wrong_channel_mode,  (*`{CSY}chybný režim seriového kanálu{ENU}wrong mode of serial channel*)
   gger_ZoneIn_is_short,  (*`{CSY}pøijímací zóna kanálu je pøíliš krátká{ENU}chanel input zone is too short*)
   gger_ZoneOut_is_short,  (*`{CSY}odesílací zóna kanálu je pøíliš krátká{ENU}chanel output zone is too short*)
   gger_Empty_Message_Text,  (*`{CSY}text SMS zprávy je prázdný{ENU}text of SMS message is empty*)
   gger_Message_Text_Too_Long,  (*`{CSY}text SMS je pøíliš dlouhý{ENU}text of SMS message is too long*)
   gger_Dialing_Failed,  (*`{CSY}vytáèení èísla pøíjemce selhalo{ENU}dialing of recipient number failed*)
   gger_USSD_Not_Executed   (*`{CSY}spuštení USSD selhalo{ENU}USSD execution failed*)
  );
END_TYPE

TYPE TGSMGatePlcCoding :   (*`windows cp-1250*)
  (ggpc_cp1250,  (*`windows cp-1250*)
   ggpc_cp1251,  (*`windows cp-1251*)
   ggpc_cp1252,  (*`windows cp-1252*)
   ggpc_cp1253,  (*`windows cp-1253*)
   ggpc_cp1255   (*`windows cp-1255*)
  );
END_TYPE

TYPE TGSMGateSmsCoding :   (*`7-bit GSM 03.38*)
  (ggsc_GSM7bit,  (*`7-bit GSM 03.38*)
   ggsc_8bit,  (*`8-bit*)
   ggsc_UCS2   (*`16-bit UCS-2*)
  );
END_TYPE

TYPE TGSMGateSmsStatus :   (*`{CSY}Není definováno{ENU}not defined*)
  (ggss_Unknown,  (*`{CSY}Není definováno{ENU}not defined*)
   ggss_Success,  (*`0x00	{CSY}SMS doruèena úspìšnì{ENU}Short message delivered successfully*)
   ggss_Forwarded,  (*`0x01	{CSY}Pøedáno, ale stav neznámí{ENU}Forwarded, but status unknown*)
   ggss_Replaced,  (*`0x02	{CSY}Nahrazeno{ENU}Replaced*)
   ggss_CongestionTrying,  (*`0x20	{CSY}Pøetížení, stále se pokouší{ENU}Congestion, still trying*)
   ggss_BusyTrying,  (*`0x21	{CSY}Pøíjemce zaneprázdnìn, stále se pokouší{ENU}Recipient busy, still trying*)
   ggss_NoResponseTrying,  (*`0x22	{CSY}Žádná reakce pøíjemce, stále se pokouší{ENU}No response recipient, still trying*)
   ggss_ServiceRejectedTrying,  (*`0x23	{CSY}Služba odmítnuta, stále se pokouší{ENU}Service rejected, still trying*)
   ggss_QosNotAvailableTrying,  (*`0x24	{CSY}QOS není dostupná, stále se pokouší{ENU}QOS not available, still trying*)
   ggss_RecipientErrorTrying,  (*`0x25	{CSY}Chyba pøíjemce, stále se pokouší{ENU}Recipient error, still trying*)
   ggss_RpcError,  (*`0x40	{CSY}Chyba RPC{ENU}RPC Error*)
   ggss_IncompatibleDestination,  (*`0x41	{CSY}Nekompatibilní cíl{ENU}Incompatible destination*)
   ggss_ConnectionRejected,  (*`0x42	{CSY}Spojení odmítnuto{ENU}Connection rejected*)
   ggss_NotObtainable,  (*`0x43	{CSY}Není dostupné{ENU}Not obtainable*)
   ggss_QosNotAvailable,  (*`0x44	{CSY}QOS není dostupná{ENU}QOS not available*)
   ggss_NoInternetworkingAvailable,  (*`0x45	{CSY}Spojení není dostupné{ENU}No internetworking available*)
   ggss_Expired,  (*`0x46	{CSY}Zprávì vypršela platnost{ENU}Message expired*)
   ggss_DeletedBySender,  (*`0x47	{CSY}Zpráva smazána pøíjemcem{ENU}Message deleted by sender*)
   ggss_DeletedBySMSC,  (*`0x48	{CSY}Zpráva smazána SMSC{ENU}Message deleted by SMSC*)
   ggss_DoesNotExist   (*`0x49	{CSY}Neexistuje{ENU}Does not exist*)
  );
END_TYPE

TYPE TGSM_UNI :
  STRUCT
    STCO             : byte;
    ERR              : usint;
    NUM              : uint;
    DATA             : string [255];
  END_STRUCT;
END_TYPE

TYPE  SMS_STRING : string [160];
END_TYPE

TYPE  NUMBER_STRING : string [20];
END_TYPE

TYPE  PIN_STRING : string [4];
END_TYPE

VAR_GLOBAL CONSTANT
 _GsmLib_UCS2_TO_CP125x_256_415 : ARRAY [256..415] OF byte :=  [
(* 0256 *)  63,  63, 195, 227, 165, 185, 198, 230,  63,  63,  63,  63, 200, 232, 207, 239,
(* 0272 *) 208, 240,  63,  63,  63,  63,  63,  63, 202, 234, 204, 236,  63,  63,  63,  63,
(* 0288 *)  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,
(* 0304 *)  63,  63,  63,  63,  63,  63,  63,  63,  63, 197, 229,  63,  63, 188, 190,  63,
(* 0320 *)  63, 163, 179, 209, 241,  63,  63, 210, 242,  63,  63,  63,  63,  63,  63,  63,
(* 0336 *) 213, 245, 140, 156, 192, 224,  63,  63, 216, 248, 140, 156,  63,  63, 170, 186,
(* 0352 *) 138, 154, 222, 254, 141, 157,  63,  63,  63,  63,  63,  63,  63,  63, 217, 249,
(* 0368 *) 219, 251,  63,  63,  63,  63,  63,  63, 159, 143, 159, 175, 191, 142, 158,  63,
(* 0384 *)  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,
(* 0400 *)  63,  63, 131,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63];
 _GsmLib_UCS2_TO_CP125x_704_735 : ARRAY [704..735] OF byte :=  [
(* 0704 *)  63,  63,  63,  63,  63,  63, 136, 161,  63,  63,  63,  63,  63,  63,  63,  63,
(* 0720 *)  63,  63,  63,  63,  63,  63,  63,  63, 162, 255,  63, 178, 152, 189,  63,  63];
 _GsmLib_UCS2_TO_CP125x_896_1183 : ARRAY [896..1183] OF byte :=  [
(* 0896 *)  63,  63,  63,  63, 180, 161, 162,  63, 184, 185, 186,  63, 188,  63, 190, 191,
(* 0912 *) 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
(* 0928 *) 208, 209,  63, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
(* 0944 *) 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
(* 0960 *) 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254,  63,
(* 0976 *)  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,
(* 0992 *)  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,
(* 1008 *)  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,
(* 1024 *)  63, 168, 128, 129, 170, 189, 178, 175, 163, 138, 140, 142, 141,  63, 161, 143,
(* 1040 *) 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
(* 1056 *) 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
(* 1072 *) 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
(* 1088 *) 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255,
(* 1104 *)  63, 184, 144, 131, 186, 190, 179, 191, 188, 154, 156, 158, 157,  63, 162, 159,
(* 1120 *)  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,
(* 1136 *)  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,
(* 1152 *)  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,
(* 1168 *) 165, 180,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63];
 _GsmLib_UCS2_TO_CP125x_8206_8255 : ARRAY [8206..8495] OF byte :=  [
  
(* 8206 *) 253, 254,  63,  63,  63, 150, 151, 175,  63,  63, 145, 146, 130,  63, 147, 148,
(* 8222 *) 132,  63, 134, 135, 149,  63,  63,  63, 133,  63,  63,  63,  63,  63,  63,  63,
(* 8238 *)  63,  63, 137,  63,  63,  63,  63,  63,  63,  63,  63, 139, 155,  63,  63,  63,
(* 8254 *)  63,  63];
 _GsmLib_GSM7_TO_CP125x_0_127 : ARRAY [0..127] OF byte :=  [
(*   0 *)   64, 163,  36, 165, 232, 233, 249, 236, 242, 199,  10, 216, 248,  13, 197, 229,
(*  16 *)  196,  95, 214, 195, 203, 217, 208, 216, 211, 200, 206,   0, 198, 230, 223, 201,
(*  32 *)   32,  33,  34,  35, 164,  37,  38,  39,  40,  41,  42,  43,  44,  45,  46,  47,
(*  48 *)   48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,
(*  64 *)  161,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
(*  80 *)   80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90, 196, 214, 209, 220, 167,
(*  96 *)  191,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
(* 112 *)  112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 228, 246, 241, 252, 224];
 _GsmLib_CP125x_TO_GSM7_0_255 : ARRAY [0..255] OF byte :=  [
(*   0 *)   0,  63,  63,  63,  63,  63,  63,  63,  63,  63,  10,  63,  27,  13,  63,  63,
(*  16 *)  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,
(*  32 *)  32,  33,  34,  35,   2,  37,  38,  39,  40,  41,  42,  43,  44,  45,  46,  47,
(*  48 *)  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,
(*  64 *)   0,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
(*  80 *)  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  27,  27,  27,  27,  17,
(*  96 *)  63,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
(* 112 *) 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122,  27,  27,  27,  27,  63,
(* 128 *)  27,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,
(* 144 *)  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,
(* 160 *)  63,  64,  63,   1,  36,   3,  63,  95,  63,  63,  63,  63,  63,  63,  63,  63,
(* 176 *)  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,
(* 192 *)  96,  63,  63,  19,  91,  14,  28,   9,  25,  31,  63,  20,  63,  63,  26,  63,
(* 208 *)  22,  93,  63,  24,  63,  63,  92,  63,  11,  21,  63,  63,  94,  63,  63,  30,
(* 224 *) 127,  63,  63,  63, 123,  15,  29,  63,   4,   5,  63,  63,   7,  63,  63,  63,
(* 240 *)  63, 125,   8,  63,  63,  63, 124,  63,  12,   6,  63,  63, 126,  63,  63,  63];
 _GsmLib_CP1250_TO_UCS2_128_255 : ARRAY [128..255] OF word :=  [
		16#20AC, 16#FFFD, 16#201A, 16#FFFD, 16#201E, 16#2026, 16#2020, 16#2021,
		16#FFFD, 16#2030, 16#0160, 16#2039, 16#015A, 16#0164, 16#017D, 16#0179,
		16#FFFD, 16#2018, 16#2019, 16#201C, 16#201D, 16#2022, 16#2013, 16#2014,
		16#FFFD, 16#2122, 16#0161, 16#203A, 16#015B, 16#0165, 16#017E, 16#017A,
		16#00A0, 16#02C7, 16#02D8, 16#0141, 16#00A4, 16#0104, 16#00A6, 16#00A7,
		16#00A8, 16#00A9, 16#015E, 16#00AB, 16#00AC, 16#00AD, 16#00AE, 16#017B,
		16#00B0, 16#00B1, 16#02DB, 16#0142, 16#00B4, 16#00B5, 16#00B6, 16#00B7,
		16#00B8, 16#0105, 16#015F, 16#00BB, 16#013D, 16#02DD, 16#013E, 16#017C,
		16#0154, 16#00C1, 16#00C2, 16#0102, 16#00C4, 16#0139, 16#0106, 16#00C7,
		16#010C, 16#00C9, 16#0118, 16#00CB, 16#011A, 16#00CD, 16#00CE, 16#010E,
		16#0110, 16#0143, 16#0147, 16#00D3, 16#00D4, 16#0150, 16#00D6, 16#00D7,
		16#0158, 16#016E, 16#00DA, 16#0170, 16#00DC, 16#00DD, 16#0162, 16#00DF,
		16#0155, 16#00E1, 16#00E2, 16#0103, 16#00E4, 16#013A, 16#0107, 16#00E7,
		16#010D, 16#00E9, 16#0119, 16#00EB, 16#011B, 16#00ED, 16#00EE, 16#010F,
		16#0111, 16#0144, 16#0148, 16#00F3, 16#00F4, 16#0151, 16#00F6, 16#00F7,
		16#0159, 16#016F, 16#00FA, 16#0171, 16#00FC, 16#00FD, 16#0163, 16#02D9
	];
 _GsmLib_CP1251_TO_UCS2_128_255 : ARRAY [128..255] OF word :=  [
    16#0402, 16#0403, 16#201A, 16#0453, 16#201E, 16#2026, 16#2020, 16#2021,
		16#20AC, 16#2030, 16#0409, 16#2039, 16#040A, 16#040C, 16#040B, 16#040F,
		16#0452, 16#2018, 16#2019, 16#201C, 16#201D, 16#2022, 16#2013, 16#2014,
		16#FFFD, 16#2122, 16#0459, 16#203A, 16#045A, 16#045C, 16#045B, 16#045F,
		16#00A0, 16#040E, 16#045E, 16#0408, 16#00A4, 16#0490, 16#00A6, 16#00A7,
		16#0401, 16#00A9, 16#0404, 16#00AB, 16#00AC, 16#00AD, 16#00AE, 16#0407,
		16#00B0, 16#00B1, 16#0406, 16#0456, 16#0491, 16#00B5, 16#00B6, 16#00B7,
		16#0451, 16#2116, 16#0454, 16#00BB, 16#0458, 16#0405, 16#0455, 16#0457,
		16#0410, 16#0411, 16#0412, 16#0413, 16#0414, 16#0415, 16#0416, 16#0417,
		16#0418, 16#0419, 16#041A, 16#041B, 16#041C, 16#041D, 16#041E, 16#041F,
		16#0420, 16#0421, 16#0422, 16#0423, 16#0424, 16#0425, 16#0426, 16#0427,
		16#0428, 16#0429, 16#042A, 16#042B, 16#042C, 16#042D, 16#042E, 16#042F,
		16#0430, 16#0431, 16#0432, 16#0433, 16#0434, 16#0435, 16#0436, 16#0437,
		16#0438, 16#0439, 16#043A, 16#043B, 16#043C, 16#043D, 16#043E, 16#043F,
		16#0440, 16#0441, 16#0442, 16#0443, 16#0444, 16#0445, 16#0446, 16#0447,
		16#0448, 16#0449, 16#044A, 16#044B, 16#044C, 16#044D, 16#044E, 16#044F
	];
 _GsmLib_CP1252_TO_UCS2_128_159 : ARRAY [128..159] OF word :=  [
		16#20AC, 16#FFFD, 16#201A, 16#0192, 16#201E, 16#2026, 16#2020, 16#2021,
		16#02C6, 16#2030, 16#0160, 16#2039, 16#0152, 16#FFFD, 16#017D, 16#FFFD,
		16#FFFD, 16#2018, 16#2019, 16#201C, 16#201D, 16#2022, 16#2013, 16#2014,
		16#02DC, 16#2122, 16#0161, 16#203A, 16#0153, 16#FFFD, 16#017E, 16#0178
	];
 _GsmLib_CP1253_TO_UCS2_128_255 : ARRAY [128..255] OF word :=  [
		16#20AC, 16#FFFD, 16#201A, 16#0192, 16#201E, 16#2026, 16#2020, 16#2021,
		16#FFFD, 16#2030, 16#FFFD, 16#2039, 16#FFFD, 16#FFFD, 16#FFFD, 16#FFFD,
		16#FFFD, 16#2018, 16#2019, 16#201C, 16#201D, 16#2022, 16#2013, 16#2014,
		16#FFFD, 16#2122, 16#FFFD, 16#203A, 16#FFFD, 16#FFFD, 16#FFFD, 16#FFFD,
		16#00A0, 16#0385, 16#0386, 16#00A3, 16#00A4, 16#00A5, 16#00A6, 16#00A7,
		16#00A8, 16#00A9, 16#FFFD, 16#00AB, 16#00AC, 16#00AD, 16#00AE, 16#2015,
		16#00B0, 16#00B1, 16#00B2, 16#00B3, 16#0384, 16#00B5, 16#00B6, 16#00B7,
		16#0388, 16#0389, 16#038A, 16#00BB, 16#038C, 16#00BD, 16#038E, 16#038F,
		16#0390, 16#0391, 16#0392, 16#0393, 16#0394, 16#0395, 16#0396, 16#0397,
		16#0398, 16#0399, 16#039A, 16#039B, 16#039C, 16#039D, 16#039E, 16#039F,
		16#03A0, 16#03A1, 16#FFFD, 16#03A3, 16#03A4, 16#03A5, 16#03A6, 16#03A7,
		16#03A8, 16#03A9, 16#03AA, 16#03AB, 16#03AC, 16#03AD, 16#03AE, 16#03AF,
		16#03B0, 16#03B1, 16#03B2, 16#03B3, 16#03B4, 16#03B5, 16#03B6, 16#03B7,
		16#03B8, 16#03B9, 16#03BA, 16#03BB, 16#03BC, 16#03BD, 16#03BE, 16#03BF,
		16#03C0, 16#03C1, 16#03C2, 16#03C3, 16#03C4, 16#03C5, 16#03C6, 16#03C7,
		16#03C8, 16#03C9, 16#03CA, 16#03CB, 16#03CC, 16#03CD, 16#03CE, 16#FFFD
	];
 _GsmLib_CP1255_TO_UCS2_128_255 : ARRAY [128..255] OF word :=  [
    16#20AC, 16#FFFD, 16#201A, 16#0192, 16#201E, 16#2026, 16#2020, 16#2021,
    16#02C6, 16#2030, 16#FFFD, 16#2039, 16#FFFD, 16#FFFD, 16#FFFD, 16#FFFD,
    16#FFFD, 16#2018, 16#2019, 16#201C, 16#201D, 16#2022, 16#2013, 16#2014,
    16#02DC, 16#2122, 16#FFFD, 16#203A, 16#FFFD, 16#FFFD, 16#FFFD, 16#FFFD,
    16#00A0, 16#00A1, 16#00A2, 16#00A3, 16#20AA, 16#00A5, 16#00A6, 16#00A7,
    16#00A8, 16#00A9, 16#00D7, 16#00AB, 16#00AC, 16#00AD, 16#00AE, 16#00AF,
    16#00B0, 16#00B1, 16#00B2, 16#00B3, 16#00B4, 16#00B5, 16#00B6, 16#00B7,
    16#00B8, 16#00B9, 16#00F7, 16#00BB, 16#00BC, 16#00BD, 16#00BE, 16#00BF,
    16#05B0, 16#05B1, 16#05B2, 16#05B3, 16#05B4, 16#05B5, 16#05B6, 16#05B7,
    16#05B8, 16#05B9, 16#FFFD, 16#05BB, 16#05BC, 16#05BD, 16#05BE, 16#05BF,
    16#05C0, 16#05C1, 16#05C2, 16#05C3, 16#05F0, 16#05F1, 16#05F2, 16#05F3,
    16#05F4, 16#FFFD, 16#FFFD, 16#FFFD, 16#FFFD, 16#FFFD, 16#FFFD, 16#FFFD,
    16#05D0, 16#05D1, 16#05D2, 16#05D3, 16#05D4, 16#05D5, 16#05D6, 16#05D7,
    16#05D8, 16#05D9, 16#05DA, 16#05DB, 16#05DC, 16#05DD, 16#05DE, 16#05DF,
    16#05E0, 16#05E1, 16#05E2, 16#05E3, 16#05E4, 16#05E5, 16#05E6, 16#05E7,
    16#05E8, 16#05E9, 16#05EA, 16#FFFD, 16#FFFD, 16#200E, 16#200F, 16#FFFD
	];
 _GsmLib_CP125x_TO_BE_EGSM7 : ARRAY [0..10] OF byte :=  [ 12, 91, 92, 93, 94,123,124,125,126,128];
 _GsmLib_EGSM7_VALUES : ARRAY [0..10] OF byte :=  [ 10, 60, 47, 62, 20, 40, 64, 41, 61,101];

END_VAR

__DECL FUNCTION _GsmLib_CP125x_TO_EGSM7_BYTE {HIDDEN} : byte
(*`Second byte of extended GSM char table*)
  VAR_INPUT
    b                : byte;
  END_VAR
END_FUNCTION

__DECL FUNCTION _GsmLib_CP125x_TO_GSM7_BYTE {HIDDEN} : byte
(*`cp1250,1,2 to GSM char table (for 27 is necessary to obtain extended char )*)
  VAR_INPUT
    b                : usint;
  END_VAR
END_FUNCTION

__DECL FUNCTION _GsmLib_CP1253_TO_GSM7_BYTE {HIDDEN} : byte
(*`cp1253 to GSM char table (for 27 is necessary to obtain extended char )*)
  VAR_INPUT
    b                : usint;
  END_VAR
END_FUNCTION

__DECL FUNCTION _GsmLib_GSM7_TO_CP125x_BYTE {HIDDEN} : byte
(*`GSM char table to cp1250,1,2,3*)
  VAR_INPUT
    w                : word;
  END_VAR
END_FUNCTION

__DECL FUNCTION _GsmLib_GSM7_TO_CP125x {HIDDEN} : usint
  VAR_INPUT
    pW               : PTR_TO word;
    pB               : PTR_TO byte;
    length           : usint;
  END_VAR
END_FUNCTION

__DECL FUNCTION _GsmLib_CP1250_TO_UCS2_WORD {HIDDEN} : word
  VAR_INPUT
    b                : usint;
  END_VAR
END_FUNCTION

__DECL FUNCTION _GsmLib_CP1251_TO_UCS2_WORD {HIDDEN} : word
  VAR_INPUT
    b                : usint;
  END_VAR
END_FUNCTION

__DECL FUNCTION _GsmLib_CP1253_TO_UCS2_WORD {HIDDEN} : word
  VAR_INPUT
    b                : usint;
  END_VAR
END_FUNCTION

__DECL FUNCTION _GsmLib_CP1252_TO_UCS2_WORD {HIDDEN} : word
  VAR_INPUT
    b                : usint;
  END_VAR
END_FUNCTION

__DECL FUNCTION _GsmLib_CP1255_TO_UCS2_WORD {HIDDEN} : word
  VAR_INPUT
    b                : usint;
  END_VAR
END_FUNCTION

__DECL FUNCTION _GsmLib_UCS2_TO_CP125x_BYTE {HIDDEN} : byte
  VAR_INPUT
    w                : word;
  END_VAR
END_FUNCTION

__DECL FUNCTION _GsmLib_UCS2_TO_CP125x {HIDDEN} : bool
  VAR_INPUT
    pW               : PTR_TO word;
    pB               : PTR_TO byte;
  END_VAR
END_FUNCTION

__DECL FUNCTION _GsmLib_CodeSemiOctetsNumber {HIDDEN} : usint
(*`Decode GSM number
   420608511845 => 246080158154*)
  VAR_INPUT
    IN               : PTR_TO usint;
  END_VAR
  VAR_IN_OUT
    Num              : NUMBER_STRING;
  END_VAR
END_FUNCTION

__DECL FUNCTION _GsmLib_DecodeSemiOctetsNumber {HIDDEN} : usint
(*`Decode GSM number
   246080158154 => 420608511845*)
  VAR_INPUT
    IN               : PTR_TO usint;
    LNG              : usint;
  END_VAR
  VAR_IN_OUT
    Num              : NUMBER_STRING;
  END_VAR
END_FUNCTION

__DECL FUNCTION _GsmLib_BYTE_TO_HEX {HIDDEN} : word
(*`255 = > 'FF'*)
  VAR_INPUT
    B                : byte;
  END_VAR
END_FUNCTION

__DECL FUNCTION _GsmLib_HEX_TO_BYTE {HIDDEN} : byte
(*`'FF' => 255*)
  VAR_INPUT
    HEX              : PTR_TO byte;
  END_VAR
END_FUNCTION

__DECL FUNCTION _GsmLib_CheckBCD {HIDDEN} : bool
  VAR_INPUT
    BCD              : PTR_TO usint;
  END_VAR
END_FUNCTION

__DECL FUNCTION _GsmLib_BCD_TO_USINT {HIDDEN} : usint
(*`'19' => 19*)
  VAR_INPUT
    BCD              : PTR_TO usint;
  END_VAR
END_FUNCTION

__DECL FUNCTION _GsmLib_SwapBCD_TO_USINT {HIDDEN} : usint
(*`'19' => 91*)
  VAR_INPUT
    BCD              : PTR_TO usint;
  END_VAR
END_FUNCTION

__DECL FUNCTION _GsmLib_GetGSMDateTime {HIDDEN} : dt
  VAR_INPUT
    pGSMDT           : PTR_TO usint;
  END_VAR
END_FUNCTION

__DECL FUNCTION _GsmLib_CodeTo7bitHEX {HIDDEN} : usint
  VAR_INPUT
    HEX              : PTR_TO word;
    PlcCoding        : TGSMGatePlcCoding;
  END_VAR
  VAR_IN_OUT
    Text             : SMS_STRING;
  END_VAR
END_FUNCTION

__DECL FUNCTION _GsmLib_Decode7bitHEX {HIDDEN} : usint
  VAR_INPUT
    HEX              : PTR_TO byte;
    N                : usint;
    U                : usint;
  END_VAR
  VAR_IN_OUT
    Text             : SMS_STRING;
  END_VAR
END_FUNCTION

__DECL FUNCTION _GsmLib_CodeTo8bitHEX {HIDDEN} : usint
  VAR_INPUT
    HEX              : PTR_TO word;
  END_VAR
  VAR_IN_OUT
    Text             : SMS_STRING;
  END_VAR
END_FUNCTION

__DECL FUNCTION _GsmLib_CodeTo8bitHEX2 {HIDDEN} : usint
  VAR_INPUT
    HEX              : PTR_TO word;
    Lenght           : usint;
  END_VAR
  VAR_IN_OUT
    Text             : usint;
  END_VAR
END_FUNCTION

__DECL FUNCTION _GsmLib_Decode8bitHEX {HIDDEN} : usint
  VAR_INPUT
    HEX              : PTR_TO byte;
    N                : usint;
    U                : usint;
  END_VAR
  VAR_IN_OUT
    Text             : SMS_STRING;
  END_VAR
END_FUNCTION

__DECL FUNCTION _GsmLib_CodeTo16bitHEX {HIDDEN} : usint
  VAR_INPUT
    HEX              : PTR_TO word;
    PlcCoding        : TGSMGatePlcCoding;
  END_VAR
  VAR_IN_OUT
    Text             : SMS_STRING;
  END_VAR
END_FUNCTION

__DECL FUNCTION _GsmLib_Decode16bitHEX {HIDDEN} : usint
  VAR_INPUT
    HEX              : PTR_TO byte;
    N                : usint;
    U                : usint;
  END_VAR
  VAR_IN_OUT
    Text             : SMS_STRING;
  END_VAR
END_FUNCTION

__DECL FUNCTION_BLOCK SMS_HANDLER
(*`{CSY}Posílá a pøijímá SMS zprávy{ENU}Sends and receives SMS messages*)
  VAR_INPUT
    Send             : bool R_EDGE;  (*`{CSY}Na nábìžnou hranu odeslat SMS{ENU}Send Text via SMS message to recipient number*)
    Ussd             : bool R_EDGE;  (*`{CSY}Na nábìžnou hranu odeslat pøíkaz jako telefonní èíslo{ENU}Send USSD command from recipient number*)
    Reset            : bool R_EDGE;  (*`{CSY}Na nábìžnou hranu zinicializovat GSM bránu{ENU}Init GSM gate*)
    Cold             : bool;  (*`{CSY}Provést pøi inicializaci i softwarový reset modemu{ENU}Cold restart*)
    Erase            : bool;  (*`{CSY}Vymazat SMS uložené na SIM pøi inicializaci modemu{ENU}Erase all messages in the GSM gate initialization*)
    Dial             : bool R_EDGE;  (*`{CSY}Prozvonit èíslo pøíjemce SMS (Recipient){ENU}Dial number*)
    DialTime         : time :=  T#120s;  (*`{CSY}Doba prozvánìní{ENU}Time of dialing*)
  END_VAR
  VAR_OUTPUT
    NewMess          : bool;  (*`{CSY}Pøijata nová SMS zpráva{ENU}New message received*)
    Ready            : bool;  (*`{CSY}GSM brána je pøipravena pro pøíjem a vysílání{ENU}GSM gate is ready to send and receive*)
    Ring             : bool;  (*`{CSY}Signalizace pøíchozího volání{ENU}Incoming call*)
    RecvTime         : dt;  (*`{CSY}Èas pøijetí SMS zprávy{ENU}Time of received SMS*)
    Signal           : sint :=  -1;  (*`{CSY}Síla signálu v procentech{ENU}Signal quality [%]*)
    State            : TGSMGateStateOut;  (*`{CSY}Stav komunikace s modemem{ENU}Communication state*)
    Error            : TGSMGateError;  (*`{CSY}Specifikace chyby pøi komunikaci s modemem{ENU}Communication error*)
    SendPending      : bool;  (*`{CSY}Probíhá odesílání SMS{ENU}Sending of SMS pending*)
    UssdPending      : bool;  (*`{CSY}Probíhá odesílání pøíkazu jako telefonního èísla{ENU}Sending of USSD command pending*)
    DialPending      : bool;  (*`{CSY}Probíhá prozvánìní telefonního èísla{ENU}Dialing number*)
  END_VAR
  VAR_IN_OUT
    CH_IN            : TGSM_UNI;  (*`{CSY}Vstupní komunikaèní zóna UNI kanálu{ENU}Input zone of PLC chanel (4+251 bytes)*)
    CH_OUT           : TGSM_UNI;  (*`{CSY}Výstupní komunikaèní zóna UNI kanálu{ENU}Output zone of PLC chanel (4+251 bytes)*)
    Pin              : PIN_STRING;  (*`{CSY}Pin SIM karty{ENU}SIM card PIN 4 digits*)
    SMSCenter        : NUMBER_STRING;  (*`{CSY}Èíslo støediska SMS zpráv{ENU}Operator SMS center number (must be in international format)*)
    Sender           : NUMBER_STRING;  (*`{CSY}Telefonní èíslo odesílatele pøijaté SMS zprávy{ENU}Sender's number of received message*)
    RecvMess         : SMS_STRING;  (*`{CSY}Text pøijaté SMS zprávy{ENU}Text of received message*)
    Recipient        : NUMBER_STRING;  (*`{CSY}Telefonní èíslo pøíjemce zprávy k odeslání{ENU}Number of recipient*)
    MessToSend       : SMS_STRING;  (*`{CSY}Text SMS zprávy k odeslání{ENU}Text of SMS message to send*)
    Caller           : NUMBER_STRING;  (*`{CSY}Telefonní èíslo volajícího{ENU}Number of incoming call*)
  END_VAR
  VAR
    TimeOut          : TON;
    Counter          : usint;
    MessOut          : bool :=  true;
    ColdRestart      : bool :=  true;
    LastArc          : bool;
    NeedErase        : bool;
    HardErr          : bool;
    Ok               : bool;
    Stop             : bool;
    InitDone         : bool;
    WaitTime         : TON;
    HelpString       : string [80];
    l_USSD           : NUMBER_STRING;
    l_Recipient      : NUMBER_STRING;
    l_MessToSend     : SMS_STRING;
    ReadErrs         : usint;
    MaxReadErrs      : usint;
    MessagesCnt      : usint;
  END_VAR
  VAR CONSTANT
    longtimeout      : time :=  T#10s;
    shorttimeout     : time :=  T#5s;
    Pause1           : time :=  T#0.5s;
    Pause3           : time :=  T#2s;
    Pause4           : time :=  T#3s;
    Pause5           : time :=  T#3s;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbRecvToCrLf
(*`{CSY}Pomocný funkèní blok pro SMS_HANDLER_x.
Pøijímá data z komunikaèního kanálu konèící znaky CR LF
{ENU}Auxiliary function block for SMS_HANDLER_x.
Receives data from communication channel delimited by CR LF*)
  VAR_INPUT
    getMess          : bool;  (*`{CSY}Vybere zprávu z bufferu{ENU}Gets message from buffer*)
    lenBuf           : uint;  (*`{CSY}Délka bufferu{ENU}Lenght of buffer*)
    chanCode         : uint;  (*`{CSY}Kód kanálu (CH1_uni, ..., CH10_uni, ETH1_uni0, ..., ETH1_uni7, ETH2_uni0, ..., ETH2_uni7){ENU}Channel code (CH1_uni, ..., CH10_uni, ETH1_uni0, ..., ETH1_uni7, ETH2_uni0, ..., ETH2_uni7)*)
    reset            : bool;  (*`{CSY}Vymaže buffer{ENU}Flushes buffer*)
  END_VAR
  VAR_OUTPUT
    full             : bool;  (*`{CSY}Buffer je plný, zprávy nebyly odebírány dostateènì rychle{ENU}Buffer is full, messages were not taken fast enought*)
    lenMess          : uint;  (*`{CSY}Délka zprávy{ENU}Message length*)
  END_VAR
  VAR
    actPos           : uint;
    RecvFrom         : fbRecvFrom;
  END_VAR
  VAR_IN_OUT
    buffer           : usint;  (*`{CSY}První byte bufferu{ENU}First byte of buffer*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK SMS_HANDLER_2
(*`{CSY}Posílá a pøijímá SMS zprávy s národním kódováním{ENU}Sends and receives SMS messages with national coding*)
  VAR_INPUT
    Send             : bool R_EDGE;  (*`{CSY}Na nábìžnou hranu odeslat SMS{ENU}Send Text via SMS message to recipient number*)
    Ussd             : bool R_EDGE;  (*`{CSY}Na nábìžnou hranu odeslat pøíkaz jako telefonní èíslo{ENU}Send USSD command from recipient number*)
    Reset            : bool R_EDGE;  (*`{CSY}Na nábìžnou hranu zinicializovat GSM bránu{ENU}Init GSM gate*)
    Cold             : bool;  (*`{CSY}Provést pøi inicializaci i softwarový reset modemu{ENU}Cold restart*)
    Erase            : bool;  (*`{CSY}Vymazat SMS uložené na SIM pøi inicializaci modemu{ENU}Erase all messages in the GSM gate initialization*)
    Dial             : bool R_EDGE;  (*`{CSY}Prozvonit èíslo pøíjemce SMS (Recipient){ENU}Dial number*)
    Stat             : bool;  (*`{CSY}Vyžadovat stav doruèení{ENU}Request status report*)
    DialTime         : time :=  T#20s;  (*`{CSY}Doba prozvánìní{ENU}Time of dialing*)
    PlcCoding        : TGSMGatePlcCoding;  (*`{CSY}Kódování STRINGù v programu PLC{ENU}Code page used in PLC*)
    SmsCoding        : TGSMGateSmsCoding;  (*`{CSY}Kódování SMS zpráv{ENU}Code page used in SMS*)
    ChanCode         : uint;  (*`{CSY}Èíslo kanálu v režimu UNI (CH1_uni .. CH10_uni){ENU}CH1_uni .. CH10_uni*)
  END_VAR
  VAR_OUTPUT
    NewMess          : bool;  (*`{CSY}Pøijata nová SMS zpráva{ENU}New message received*)
    Ready            : bool;  (*`{CSY}GSM brána je pøipravena pro pøíjem a vysílání{ENU}GSM gate is ready to send and receive*)
    Ring             : bool;  (*`{CSY}Signalizace pøíchozího volání{ENU}Incoming call*)
    NewStat          : bool;  (*`{CSY}Pøijat nový status{ENU}New SMS status*)
    StatCode         : TGSMGateSmsStatus;  (*`{CSY}Status o doruèení SMS zprávy{ENU}SMS Status*)
    SmsRef           : usint;  (*`{CSY}Identifikaèní èíslo SMS zprávy pøi odeslání, nebo reference na zprávu pøi pøijetí statusu{ENU}SMS reference number*)
    RecvTime         : dt;  (*`{CSY}Èas pøijetí SMS zprávy{ENU}Time of received SMS*)
    StatTime         : dt;  (*`{CSY}Èas získání statusu (doba doruèení/nedoruèení){ENU}Time from SMS status*)
    RingCount        : usint;  (*`{CSY}{ENU}Number of rings 1-3*)
    Signal           : sint :=  -1;  (*`{CSY}Síla signálu v procentech.{ENU}Signal quality [%]*)
    State            : TGSMGateStateOut;  (*`{CSY}Stav komunikace s modemem{ENU}Communication state*)
    Error            : TGSMGateError;  (*`{CSY}Specifikace chyby pøi komunikaci s modemem{ENU}Communication error*)
    SendPending      : bool;  (*`{CSY}Probíhá odesílání SMS{ENU}Sending of SMS pending*)
    UssdPending      : bool;  (*`{CSY}Probíhá odesílání pøíkazu jako telefonního èísla{ENU}Sending of USSD command pending*)
    DialPending      : bool;  (*`{CSY}Probíhá prozvánìní telefonního èísla{ENU}Dialing number*)
  END_VAR
  VAR_IN_OUT
    Pin              : PIN_STRING;  (*`{CSY}Pin SIM karty{ENU}SIM card PIN 4 digits*)
    SMSCenter        : NUMBER_STRING;  (*`{CSY}Èíslo støediska SMS zpráv{ENU}Operator SMS center number (must be in international format)*)
    Sender           : NUMBER_STRING;  (*`{CSY}Telefonní èíslo odesílatele pøijaté SMS zprávy{ENU}Sender's number of received message*)
    RecvMess         : SMS_STRING;  (*`{CSY}Text pøijaté SMS zprávy{ENU}Text of received message*)
    Recipient        : NUMBER_STRING;  (*`{CSY}Telefonní èíslo pøíjemce zprávy k odeslání{ENU}Number of recipient*)
    MessToSend       : SMS_STRING;  (*`{CSY}Text SMS zprávy k odeslání{ENU}Text of SMS message to send*)
    Caller           : NUMBER_STRING;  (*`{CSY}Telefonní èíslo volajícího{ENU}Number of incoming call*)
  END_VAR
  VAR
    TimeOut          : TON;
    WaitTime         : TON;
    Counter          : usint;
    MessOut          : bool :=  true;
    ColdRestart      : bool :=  true;
    NeedErase        : bool;
    HardErr          : bool;
    ok               : bool;
    WaitForOk        : bool;
    Stop             : bool;
    MessStat         : bool;
    InitDone         : bool;
    l_Stat           : bool;
    MessStatCode     : usint;
    l_USSD           : NUMBER_STRING;
    l_Recipient      : NUMBER_STRING;
    l_SMSCenter      : NUMBER_STRING;
    l_MessToSend     : SMS_STRING;
    ReadErrs         : usint;
    MaxReadErrs      : usint;
    MessagesCnt      : usint;
    OctetCnt         : usint;
    OctetLen         : uint;
    RecvFrom         : fbRecvToCrLf;
    SendTo           : fbSendTo;
    BuferIN          : ARRAY [0..511] OF usint;
    BuferOUT         : ARRAY [0..179] OF word;
    DataOUT          : string [32];
    pusintdbg        : PTR_TO usint;
  END_VAR
  VAR CONSTANT
    longtimeout      : time :=  T#10s;
    shorttimeout     : time :=  T#5s;
    Pause1           : time :=  T#0.5s;
    Pause3           : time :=  T#2s;
    Pause4           : time :=  T#3s;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK SMS_HANDLER_3
(*`{CSY}Posílá a pøijímá zprávy obsahující binární nuly{ENU}Sends and receives binary SMS messages including binary zeros*)
  VAR_INPUT
    Send             : bool R_EDGE;  (*`{CSY}Na nábìžnou hranu odeslat SMS{ENU}Send Text via SMS message to recipient number*)
    Ussd             : bool R_EDGE;  (*`{CSY}Na nábìžnou hranu odeslat pøíkaz jako telefonní èíslo{ENU}Send USSD command from recipient number*)
    Reset            : bool R_EDGE;  (*`{CSY}Na nábìžnou hranu zinicializovat GSM bránu{ENU}Init GSM gate*)
    Cold             : bool;  (*`{CSY}Provést pøi inicializaci i softwarový reset modemu{ENU}Cold restart*)
    Erase            : bool;  (*`{CSY}Vymazat SMS uložené na SIM pøi inicializaci modemu{ENU}Erase all messages in the GSM gate initialization*)
    Dial             : bool R_EDGE;  (*`{CSY}Prozvonit èíslo pøíjemce SMS (Recipient){ENU}Dial number*)
    Stat             : bool;  (*`{CSY}Vyžadovat stav doruèení{ENU}Request status report*)
    MessLen          : usint;  (*`{CSY}Délka zprávy k odeslání{ENU}Lenght of message to be sent*)
    DialTime         : time :=  T#20s;  (*`{CSY}Doba prozvánìní{ENU}Time of dialing*)
    PlcCoding        : TGSMGatePlcCoding;  (*`{CSY}Kódování STRINGù v programu PLC{ENU}Code page used in PLC*)
    SmsCoding        : TGSMGateSmsCoding;  (*`{CSY}Kódování SMS zpráv{ENU}Code page used in SMS*)
    ChanCode         : uint;  (*`{CSY}Èíslo kanálu v režimu UNI (CH1_uni .. CH10_uni){ENU}CH1_uni .. CH10_uni*)
  END_VAR
  VAR_OUTPUT
    NewMess          : bool;  (*`{CSY}Pøijata nová SMS zpráva{ENU}New message received*)
    Ready            : bool;  (*`{CSY}GSM brána je pøipravena pro pøíjem a vysílání{ENU}GSM gate is ready to send and receive*)
    Ring             : bool;  (*`{CSY}Signalizace pøíchozího volání{ENU}Incoming call*)
    NewStat          : bool;  (*`{CSY}Pøijat nový status{ENU}New SMS status*)
    StatCode         : TGSMGateSmsStatus;  (*`{CSY}Status o doruèení SMS zprávy{ENU}SMS Status*)
    SmsRef           : usint;  (*`{CSY}Identifikaèní èíslo SMS zprávy pøi odeslání, nebo reference na zprávu pøi pøijetí statusu{ENU}SMS reference number*)
    RecvTime         : dt;  (*`{CSY}Èas pøijetí SMS zprávy{ENU}Time of received SMS*)
    StatTime         : dt;  (*`{CSY}Èas získání statusu (doba doruèení/nedoruèení){ENU}Time from SMS status*)
    RingCount        : usint;  (*`{CSY}{ENU}Number of rings 1-3*)
    Signal           : sint :=  -1;  (*`{CSY}Síla signálu v procentech.{ENU}Signal quality [%]*)
    State            : TGSMGateStateOut;  (*`{CSY}Stav komunikace s modemem{ENU}Communication state*)
    Error            : TGSMGateError;  (*`{CSY}Specifikace chyby pøi komunikaci s modemem{ENU}Communication error*)
    SendPending      : bool;  (*`{CSY}Probíhá odesílání SMS{ENU}Sending of SMS pending*)
    UssdPending      : bool;  (*`{CSY}Probíhá odesílání pøíkazu jako telefonního èísla{ENU}Sending of USSD command pending*)
    DialPending      : bool;  (*`{CSY}Probíhá prozvánìní telefonního èísla{ENU}Dialing number*)
  END_VAR
  VAR_IN_OUT
    Pin              : PIN_STRING;  (*`{CSY}Pin SIM karty{ENU}SIM card PIN 4 digits*)
    SMSCenter        : NUMBER_STRING;  (*`{CSY}Èíslo støediska SMS zpráv{ENU}Operator SMS center number (must be in international format)*)
    Sender           : NUMBER_STRING;  (*`{CSY}Telefonní èíslo odesílatele pøijaté SMS zprávy{ENU}Sender's number of received message*)
    RecvMess         : SMS_STRING;  (*`{CSY}Text pøijaté SMS zprávy{ENU}Text of received message*)
    Recipient        : NUMBER_STRING;  (*`{CSY}Telefonní èíslo pøíjemce zprávy k odeslání{ENU}Number of recipient*)
    MessToSend       : usint;  (*`{CSY}První byte zprávy k odeslání{ENU}First byte of array to send*)
    Caller           : NUMBER_STRING;  (*`{CSY}Telefonní èíslo volajícího{ENU}Number of incoming call*)
  END_VAR
  VAR
    TimeOut          : TON;
    WaitTime         : TON;
    Counter          : usint;
    MessOut          : bool :=  true;
    ColdRestart      : bool :=  true;
    NeedErase        : bool;
    HardErr          : bool;
    ok               : bool;
    WaitForOk        : bool;
    Stop             : bool;
    MessStat         : bool;
    InitDone         : bool;
    l_Stat           : bool;
    MessStatCode     : usint;
    l_USSD           : NUMBER_STRING;
    l_Recipient      : NUMBER_STRING;
    l_SMSCenter      : NUMBER_STRING;
    l_MessToSend     : ARRAY [0..159] OF usint;
    ReadErrs         : usint;
    MaxReadErrs      : usint;
    MessagesCnt      : usint;
    OctetCnt         : usint;
    OctetLen         : uint;
    RecvFrom         : fbRecvToCrLf;
    SendTo           : fbSendTo;
    BuferIN          : ARRAY [0..511] OF usint;
    BuferOUT         : ARRAY [0..179] OF word;
    DataOUT          : string [32];
    pusintdbg        : PTR_TO usint;
  END_VAR
  VAR CONSTANT
    longtimeout      : time :=  T#10s;
    shorttimeout     : time :=  T#5s;
    Pause1           : time :=  T#0.5s;
    Pause3           : time :=  T#2s;
    Pause4           : time :=  T#3s;
  END_VAR
END_FUNCTION_BLOCK

TYPE SendSmsTcp_ER75i_State : 
  (ssts_Idle,
   ssts_Init,
   ssts_Conn,
   ssts_TextMode,
   ssts_Ready,
   ssts_KeepAlive,
   ssts_SendingText,
   ssts_WaitingSendAck,
   ssts_WaitingAck,
   ssts_Err 
  );
END_TYPE

__DECL FUNCTION_BLOCK fbSendSmsTcp_ER75i
(*`{CSY}Posílá SMS zprávy pøes TCP spojení s modemem ER75i{ENU}Sends SMS messages via TCP connection with ER75i modem*)
  VAR_INPUT
    Send             : bool R_EDGE;  (*`{ENG} Send SMS message {CSY} Poslat SMS zprávu*)
    Conn             : bool :=  true;  (*`{ENG} Establish connection {CSY} Navázat spojení*)
    ChanCode         : uint;  (*`{ENG} Channel code {CSY}Pøenosový kanál {} TCP Master, in: 512, out: 256*)
    IPadr            : TIPadr;  (*`{ENG} IP address of modem{CSY}IP adresa modemu*)
    Port             : uint :=  50000;  (*`{ENG} Port of AT-SMS service {CSY}Port AT-SMS služby*)
  END_VAR
  VAR_OUTPUT
    Sent             : bool;  (*`{ENU}SMS sent{CSY}Zpráva odeslána SMS*)
    SendPending      : bool;  (*`{ENU}Sending of SMS pending{CSY}Probíhá odesílání SMS*)
    Busy             : bool;  (*`{ENU}Communication pending{CSY}Probíhá komunikace*)
    Connected        : bool;  (*`{ENU}TCP connection established{CSY}TCP komunikace navázána*)
    State            : SendSmsTcp_ER75i_State;  (*`{ENU}Communication state{CSY}Stav komunikace*)
  END_VAR
  VAR_IN_OUT
    Recipient        : NUMBER_STRING;  (*`{CSY}Telefonní èíslo pøíjemce zprávy k odeslání{ENU}Number of recipient*)
    MessToSend       : SMS_STRING;  (*`{CSY}Text SMS zprávy k odeslání{ENU}Text of SMS message to send*)
  END_VAR
  VAR
    ethAdr           : TRemoteEthAdr;  (*`nové nastavení*)
    l_Recipient      : NUMBER_STRING;
    l_MessToSend     : SMS_STRING;
    RecvFrom         : fbRecvToCrLf;
    SendTo           : fbSendTo;
    BuferIN          : ARRAY [0..511] OF usint;
    DataOut          : string [255];
    timer            : TON;
    timeout          : time :=  T#15s;
    OldState         : SendSmsTcp_ER75i_State;
    NewMess          : bool;
    Ok               : bool;
  END_VAR
END_FUNCTION_BLOCK



{USES=_GsmLib_GSM7_TO_CP125x:_GsmLib_GSM7_TO_CP125x_BYTE}
{USES=_GsmLib_UCS2_TO_CP125x:_GsmLib_UCS2_TO_CP125x_BYTE}
{USES=_GsmLib_GetGSMDateTime:_GsmLib_CheckBCD,_GsmLib_SwapBCD_TO_USINT,TecoDT_TO_DT}
{USES=_GsmLib_CodeTo7bitHEX:_GsmLib_CP1253_TO_GSM7_BYTE,_GsmLib_CP125x_TO_GSM7_BYTE,_GsmLib_CP125x_TO_EGSM7_BYTE,_GsmLib_BYTE_TO_HEX}
{USES=_GsmLib_Decode7bitHEX:_GsmLib_HEX_TO_BYTE,_GsmLib_GSM7_TO_CP125x}
{USES=_GsmLib_CodeTo8bitHEX:_GsmLib_BYTE_TO_HEX}
{USES=_GsmLib_CodeTo8bitHEX2:_GsmLib_BYTE_TO_HEX}
{USES=_GsmLib_Decode8bitHEX:_GsmLib_HEX_TO_BYTE}
{USES=_GsmLib_CodeTo16bitHEX:_GsmLib_CP1250_TO_UCS2_WORD,_GsmLib_CP1251_TO_UCS2_WORD,_GsmLib_CP1252_TO_UCS2_WORD,_GsmLib_CP1253_TO_UCS2_WORD,_GsmLib_CP1255_TO_UCS2_WORD,_GsmLib_BYTE_TO_HEX}
{USES=_GsmLib_Decode16bitHEX:_GsmLib_HEX_TO_BYTE,_GsmLib_UCS2_TO_CP125x_BYTE}
{USES=SMS_HANDLER_2:GetChanDesc,_GsmLib_BYTE_TO_HEX,_GsmLib_CodeSemiOctetsNumber,_GsmLib_CodeTo7bitHEX,_GsmLib_CodeTo8bitHEX,_GsmLib_CodeTo16bitHEX,GetLastComErrTxt,_GsmLib_HEX_TO_BYTE,_GsmLib_DecodeSemiOctetsNumber,_GsmLib_GetGSMDateTime,_GsmLib_Decode16bitHEX,_GsmLib_Decode8bitHEX,_GsmLib_Decode7bitHEX}
{USES=SMS_HANDLER_3:GetChanDesc,Memcpy,_GsmLib_BYTE_TO_HEX,_GsmLib_CodeSemiOctetsNumber,_GsmLib_CodeTo7bitHEX,_GsmLib_CodeTo8bitHEX2,_GsmLib_CodeTo16bitHEX,GetLastComErrTxt,_GsmLib_HEX_TO_BYTE,_GsmLib_DecodeSemiOctetsNumber,_GsmLib_GetGSMDateTime,_GsmLib_Decode16bitHEX,_GsmLib_Decode8bitHEX,_GsmLib_Decode7bitHEX}
{USES=fbSendSmsTcp_ER75i:IsEstabTCPconnection,GetRemoteIPaddress,CloseTCPconnection,SetRemoteIPaddress,EstabTCPconnection}
#srcfile 'D:\TECOLIB\GSM_LIBRARYX2\GSMLIBCONTROL\GSMLIBV.ST'


 

#srcfile ''
#srcfile 'D:\TECOLIB\GSM_LIBRARYX2\GSMLIBCONTROL\UCS2_TO_CP1250.ST'
#pou _GsmLib_CP125x_TO_EGSM7_BYTE
#srcline 167 ;FUNCTION _GsmLib_CP125x_TO_EGSM7_BYTE {HIDDEN}: BYTE

#struct _GsmLib_CP125x_TO_EGSM7_BYTE__temp__
  uint i,
  uint P0__st__
P     61
_GsmLib_CP125x_TO_EGSM7_BYTE_L0:
 LINK __SizeOf(_GsmLib_CP125x_TO_EGSM7_BYTE__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 179 ;  FOR i := 0  TO 10 DO
 LD   uint 0
 WRY  i
 LD   uint 10
 WRY  P0__st__
_GsmLib_CP125x_TO_EGSM7_BYTE_L1:
 LDY  i
 LDY  P0__st__
 GT   
 JMD  _GsmLib_CP125x_TO_EGSM7_BYTE_L2
 DBG  
#srcline 180 ;    IF _GsmLib_CP125x_TO_BE_EGSM7[i] = b THEN
 LEA  _GsmLib_CP125x_TO_BE_EGSM7
 LDY  i
#debug uint i
 RCHK 10   ; Range Check
 ADD     ; + offset 
 LDI  
 LDX  b
#debug byte b
 EQ
 JMC  _GsmLib_CP125x_TO_EGSM7_BYTE_L3
#srcline 181 ;      _GsmLib_CP125x_TO_EGSM7_BYTE := _GsmLib_EGSM7_VALUES[i];
 LEA  _GsmLib_EGSM7_VALUES
 LDY  i
#debug uint i
 RCHK 10   ; Range Check
 ADD     ; + offset 
 LDI  
 WRX  __fc___GsmLib_CP125x_TO_EGSM7_BYTE
#debug_left byte _GsmLib_CP125x_TO_EGSM7_BYTE
#srcline 182 ;      RETURN;
 JMP  _GsmLib_CP125x_TO_EGSM7_BYTE_RET
#srcline 183 ;    END_IF;
_GsmLib_CP125x_TO_EGSM7_BYTE_L3:
#srcline 184 ;  END_FOR;
 LDY  i
 LD   1
 ADD  
 WRY  i
 JMP  _GsmLib_CP125x_TO_EGSM7_BYTE_L1
_GsmLib_CP125x_TO_EGSM7_BYTE_L2:
#srcline 185 ;  _GsmLib_CP125x_TO_EGSM7_BYTE := 10;
 LD   byte 10
 WRX  __fc___GsmLib_CP125x_TO_EGSM7_BYTE
#debug_left byte _GsmLib_CP125x_TO_EGSM7_BYTE
#srcline 186 ;  (** )
#srcline 187 ;  CASE b OF
#srcline 188 ;     12 : CP125x_TO_EGSM7_BYTE :=    10; //form feed
#srcline 189 ;     91 : CP125x_TO_EGSM7_BYTE :=    60; //[
#srcline 190 ;     92 : CP125x_TO_EGSM7_BYTE :=    47; //\
#srcline 191 ;     93 : CP125x_TO_EGSM7_BYTE :=    62; //]
#srcline 192 ;     94 : CP125x_TO_EGSM7_BYTE :=    20; //^
#srcline 193 ;    123 : CP125x_TO_EGSM7_BYTE :=    40; //{
#srcline 194 ;    124 : CP125x_TO_EGSM7_BYTE :=    64; //|
#srcline 195 ;    125 : CP125x_TO_EGSM7_BYTE :=    41; //}
#srcline 196 ;    126 : CP125x_TO_EGSM7_BYTE :=    61; //~
#srcline 197 ;    128 : CP125x_TO_EGSM7_BYTE :=   101; //Euro - not compatible with russian
#srcline 198 ;  ELSE
#srcline 199 ;    CP125x_TO_EGSM7_BYTE := 10; //unknown symbol
#srcline 200 ;  END_CASE;
#srcline 201 ;  (**)
#srcline 202 ;END_FUNCTION
_GsmLib_CP125x_TO_EGSM7_BYTE_RET:
 PRV  
 LDX  __fc___GsmLib_CP125x_TO_EGSM7_BYTE
 ULNK
RET
E     61
#endpou 

#pou _GsmLib_CP125x_TO_GSM7_BYTE
#srcline 204 ;FUNCTION _GsmLib_CP125x_TO_GSM7_BYTE {HIDDEN}: BYTE
P     61
_GsmLib_CP125x_TO_GSM7_BYTE_L0:
 LINK 0
 NXT
#srcline 211 ;  _GsmLib_CP125x_TO_GSM7_BYTE := _GsmLib_CP125x_TO_GSM7_0_255[b];
 LEA  _GsmLib_CP125x_TO_GSM7_0_255
 LDX  b
#debug usint b
 RCHK 255   ; Range Check
 ADD     ; + offset 
 LDI  
 WRX  __fc___GsmLib_CP125x_TO_GSM7_BYTE
#debug_left byte _GsmLib_CP125x_TO_GSM7_BYTE
#srcline 212 ;END_FUNCTION
 PRV  
 LDX  __fc___GsmLib_CP125x_TO_GSM7_BYTE
 ULNK
RET
E     61
#endpou 

#pou _GsmLib_CP1253_TO_GSM7_BYTE
#srcline 214 ;FUNCTION _GsmLib_CP1253_TO_GSM7_BYTE {HIDDEN}: BYTE

#struct _GsmLib_CP1253_TO_GSM7_BYTE__temp__
  udint P0__st__
P     61
_GsmLib_CP1253_TO_GSM7_BYTE_L0:
 LINK __SizeOf(_GsmLib_CP1253_TO_GSM7_BYTE__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 221 ;  CASE b OF
 LDX  b
#debug usint b
 WRY  P0__st__
 LD   196
 LDY  P0__st__
 EQ  
 JMC  _GsmLib_CP1253_TO_GSM7_BYTE_L2
#srcline 222 ;    196 : _GsmLib_CP1253_TO_GSM7_BYTE := 16;
 LD   byte 16
 WRX  __fc___GsmLib_CP1253_TO_GSM7_BYTE
#debug_left byte _GsmLib_CP1253_TO_GSM7_BYTE
 JMP  _GsmLib_CP1253_TO_GSM7_BYTE_L1
_GsmLib_CP1253_TO_GSM7_BYTE_L2:
 LD   214
 LDY  P0__st__
 EQ  
 JMC  _GsmLib_CP1253_TO_GSM7_BYTE_L3
#srcline 223 ;    214 : _GsmLib_CP1253_TO_GSM7_BYTE := 18;
 LD   byte 18
 WRX  __fc___GsmLib_CP1253_TO_GSM7_BYTE
#debug_left byte _GsmLib_CP1253_TO_GSM7_BYTE
 JMP  _GsmLib_CP1253_TO_GSM7_BYTE_L1
_GsmLib_CP1253_TO_GSM7_BYTE_L3:
 LD   216
 LDY  P0__st__
 EQ  
 JMC  _GsmLib_CP1253_TO_GSM7_BYTE_L4
#srcline 224 ;    216 : _GsmLib_CP1253_TO_GSM7_BYTE := 23;
 LD   byte 23
 WRX  __fc___GsmLib_CP1253_TO_GSM7_BYTE
#debug_left byte _GsmLib_CP1253_TO_GSM7_BYTE
 JMP  _GsmLib_CP1253_TO_GSM7_BYTE_L1
_GsmLib_CP1253_TO_GSM7_BYTE_L4:
#srcline 225 ;    ELSE  _GsmLib_CP1253_TO_GSM7_BYTE := _GsmLib_CP125x_TO_GSM7_0_255[b];
 LEA  _GsmLib_CP125x_TO_GSM7_0_255
 LDX  b
#debug usint b
 RCHK 255   ; Range Check
 ADD     ; + offset 
 LDI  
 WRX  __fc___GsmLib_CP1253_TO_GSM7_BYTE
#debug_left byte _GsmLib_CP1253_TO_GSM7_BYTE
#srcline 226 ;  END_CASE;
_GsmLib_CP1253_TO_GSM7_BYTE_L1:
#srcline 227 ;END_FUNCTION
 PRV  
 LDX  __fc___GsmLib_CP1253_TO_GSM7_BYTE
 ULNK
RET
E     61
#endpou 

#pou _GsmLib_GSM7_TO_CP125x_BYTE
#srcline 229 ;FUNCTION _GsmLib_GSM7_TO_CP125x_BYTE {HIDDEN}: BYTE

#struct _GsmLib_GSM7_TO_CP125x_BYTE__temp__
  uint ui,
  byte b,
  uint i,
  uint P0__st__
P     61
_GsmLib_GSM7_TO_CP125x_BYTE_L0:
 LINK __SizeOf(_GsmLib_GSM7_TO_CP125x_BYTE__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 240 ;  ui := WORD_TO_UINT(w AND 16#7F);
 LDX  w
#debug word w
 LD   word $7F
 AND
 WRY  ui
#debug_left uint ui
#srcline 241 ;  
#srcline 242 ;  IF _GsmLib_GSM7_TO_CP125x_0_127[ui] > 0 THEN
 LEA  _GsmLib_GSM7_TO_CP125x_0_127
 LDY  ui
#debug uint ui
 RCHK 127   ; Range Check
 ADD     ; + offset 
 LDI  
 LD   byte 0
 GT
 JMC  _GsmLib_GSM7_TO_CP125x_BYTE_L1
#srcline 243 ;    _GsmLib_GSM7_TO_CP125x_BYTE := _GsmLib_GSM7_TO_CP125x_0_127[ui];
 LEA  _GsmLib_GSM7_TO_CP125x_0_127
 LDY  ui
#debug uint ui
 RCHK 127   ; Range Check
 ADD     ; + offset 
 LDI  
 WRX  __fc___GsmLib_GSM7_TO_CP125x_BYTE
#debug_left byte _GsmLib_GSM7_TO_CP125x_BYTE
#srcline 244 ;  ELSE
 JMP  _GsmLib_GSM7_TO_CP125x_BYTE_L2
_GsmLib_GSM7_TO_CP125x_BYTE_L1:
#srcline 245 ;    b := WORD_TO_BYTE(SHR(w, 8));
 LDX  w
#debug word w
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRY  b
#debug_left byte b
#srcline 246 ;    
#srcline 247 ;    FOR i := 0  TO 10 DO
 LD   uint 0
 WRY  i
 LD   uint 10
 WRY  P0__st__
_GsmLib_GSM7_TO_CP125x_BYTE_L3:
 LDY  i
 LDY  P0__st__
 GT   
 JMD  _GsmLib_GSM7_TO_CP125x_BYTE_L4
 DBG  
#srcline 248 ;      IF _GsmLib_EGSM7_VALUES[i] = b THEN
 LEA  _GsmLib_EGSM7_VALUES
 LDY  i
#debug uint i
 RCHK 10   ; Range Check
 ADD     ; + offset 
 LDI  
 LDY  b
#debug byte b
 EQ
 JMC  _GsmLib_GSM7_TO_CP125x_BYTE_L5
#srcline 249 ;        _GsmLib_GSM7_TO_CP125x_BYTE := _GsmLib_CP125x_TO_BE_EGSM7[i];
 LEA  _GsmLib_CP125x_TO_BE_EGSM7
 LDY  i
#debug uint i
 RCHK 10   ; Range Check
 ADD     ; + offset 
 LDI  
 WRX  __fc___GsmLib_GSM7_TO_CP125x_BYTE
#debug_left byte _GsmLib_GSM7_TO_CP125x_BYTE
#srcline 250 ;        RETURN;
 JMP  _GsmLib_GSM7_TO_CP125x_BYTE_RET
#srcline 251 ;      END_IF;
_GsmLib_GSM7_TO_CP125x_BYTE_L5:
#srcline 252 ;    END_FOR;
 LDY  i
 LD   1
 ADD  
 WRY  i
 JMP  _GsmLib_GSM7_TO_CP125x_BYTE_L3
_GsmLib_GSM7_TO_CP125x_BYTE_L4:
#srcline 253 ;    _GsmLib_GSM7_TO_CP125x_BYTE := 63;
 LD   byte 63
 WRX  __fc___GsmLib_GSM7_TO_CP125x_BYTE
#debug_left byte _GsmLib_GSM7_TO_CP125x_BYTE
#srcline 255 ;    (*
#srcline 256 ;    ui := WORD_TO_UINT(SHR(w, 8) AND 16#7F);
#srcline 257 ;    CASE ui OF
#srcline 258 ;      10 : GSM7_TO_CP125x_BYTE := 12;  //form feed
#srcline 259 ;      20 : GSM7_TO_CP125x_BYTE := 94;  //^
#srcline 260 ;      40 : GSM7_TO_CP125x_BYTE := 123; //{
#srcline 261 ;      41 : GSM7_TO_CP125x_BYTE := 125; //}
#srcline 262 ;      47 : GSM7_TO_CP125x_BYTE := 92;  //\
#srcline 263 ;      60 : GSM7_TO_CP125x_BYTE := 91;  //[
#srcline 264 ;      61 : GSM7_TO_CP125x_BYTE := 126; //~
#srcline 265 ;      62 : GSM7_TO_CP125x_BYTE := 93;  //]
#srcline 266 ;      64 : GSM7_TO_CP125x_BYTE := 124; //|
#srcline 267 ;     101 : GSM7_TO_CP125x_BYTE := 128; //Euro - not compatible with cp1252
#srcline 268 ;    ELSE
#srcline 269 ;      GSM7_TO_CP125x_BYTE := 63; //?  - unknown symbol
#srcline 270 ;    END_CASE;
#srcline 271 ;    *)
#srcline 272 ;  END_IF;
_GsmLib_GSM7_TO_CP125x_BYTE_L2:
#srcline 273 ;END_FUNCTION
_GsmLib_GSM7_TO_CP125x_BYTE_RET:
 PRV  
 LDX  __fc___GsmLib_GSM7_TO_CP125x_BYTE
 ULNK
RET
E     61
#endpou 

#pou _GsmLib_GSM7_TO_CP125x
#srcline 275 ;FUNCTION _GsmLib_GSM7_TO_CP125x{HIDDEN} : USINT

#struct _GsmLib_GSM7_TO_CP125x__temp__
  udint i,
  word w
P     61
_GsmLib_GSM7_TO_CP125x_L0:
 LINK __SizeOf(_GsmLib_GSM7_TO_CP125x__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 286 ;  WHILE i < USINT_TO_UDINT(length) DO
_GsmLib_GSM7_TO_CP125x_L1:
 LDY  i
#debug udint i
 LDX  length
#debug usint length
 LT
 JMC  _GsmLib_GSM7_TO_CP125x_L2
 DBG 
#srcline 287 ;   w := pW^;
 LEAX pW
 LDIL    ; dereference 
 LDIW 
#debug word pW^
 WRY  w
#debug_left word w
#srcline 288 ;   pB^ := _GsmLib_GSM7_TO_CP125x_BYTE(w);
 NXT
 LDY  w
#debug word w
 WR   __Instance___GsmLib_GSM7_TO_CP125x_BYTE~w
#debug_left word __Instance___GsmLib_GSM7_TO_CP125x_BYTE~w
 PRV
 LEA  __Instance___GsmLib_GSM7_TO_CP125x_BYTE
 CAL  _GsmLib_GSM7_TO_CP125x_BYTE_L0
 LEAX pB
 LDIL    ; dereference 
 WRI 
#debug_left byte pB^
#srcline 289 ;   i  := i+1;
 LDY  i
#debug udint i
 LD   udint 1
 ADD
 WRY  i
#debug_left udint i
#srcline 290 ;   pB := pB+1;
 LEAX pB
 LDIL 
#debug pointer pB
 LD   udint 1
 ADD
 LEAX pB
 WRIL 
#debug_left pointer pB
#srcline 291 ;   IF (w & 16#FF) = 16#1B THEN
 LDY  w
#debug word w
 LD   word $FF
 AND
 LD   word $1B
 EQ
 JMC  _GsmLib_GSM7_TO_CP125x_L3
#srcline 292 ;     pW := pW+2;
 LEAX pW
 LDIL 
#debug pointer pW
 LD   udint 2
 ADD
 LEAX pW
 WRIL 
#debug_left pointer pW
#srcline 293 ;     length := length - 1;
 LDX  length
#debug usint length
 LD   usint 1
 SUB
 AND  $FF
 WRX  length
#debug_left usint length
#srcline 294 ;   ELSE
 JMP  _GsmLib_GSM7_TO_CP125x_L4
_GsmLib_GSM7_TO_CP125x_L3:
#srcline 295 ;     pW := pW+1;
 LEAX pW
 LDIL 
#debug pointer pW
 LD   udint 1
 ADD
 LEAX pW
 WRIL 
#debug_left pointer pW
#srcline 296 ;   END_IF;
_GsmLib_GSM7_TO_CP125x_L4:
#srcline 297 ;  END_WHILE;
 JMP  _GsmLib_GSM7_TO_CP125x_L1
_GsmLib_GSM7_TO_CP125x_L2:
#srcline 298 ;  pB^ := 0;
 LD   byte 0
 LEAX pB
 LDIL    ; dereference 
 WRI 
#debug_left byte pB^
#srcline 300 ;  _GsmLib_GSM7_TO_CP125x := length;
 LDX  length
#debug usint length
 WRX  __fc___GsmLib_GSM7_TO_CP125x
#debug_left usint _GsmLib_GSM7_TO_CP125x
#srcline 301 ;END_FUNCTION
 PRV  
 LDX  __fc___GsmLib_GSM7_TO_CP125x
 ULNK
RET
E     61
#endpou 

#pou _GsmLib_CP1250_TO_UCS2_WORD
#srcline 303 ;FUNCTION _GsmLib_CP1250_TO_UCS2_WORD{HIDDEN} : WORD
P     61
_GsmLib_CP1250_TO_UCS2_WORD_L0:
 LINK 0
 NXT
#srcline 306 ;  END_VAR;
#srcline 308 ;  IF b < 128 THEN
 LDX  b
#debug usint b
 LD   usint 128
 LT
 JMC  _GsmLib_CP1250_TO_UCS2_WORD_L1
#srcline 309 ;    _GsmLib_CP1250_TO_UCS2_WORD := USINT_TO_WORD(b);
 LDX  b
#debug usint b
 WRX  __fc___GsmLib_CP1250_TO_UCS2_WORD
#debug_left word _GsmLib_CP1250_TO_UCS2_WORD
#srcline 310 ;  ELSE
 JMP  _GsmLib_CP1250_TO_UCS2_WORD_L2
_GsmLib_CP1250_TO_UCS2_WORD_L1:
#srcline 311 ;    _GsmLib_CP1250_TO_UCS2_WORD := _GsmLib_CP1250_TO_UCS2_128_255[b];
 LEA  _GsmLib_CP1250_TO_UCS2_128_255
 LDX  b
#debug usint b
 SUB  128   ; Low range[1]
 RCHK 127   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 LDIW 
 WRX  __fc___GsmLib_CP1250_TO_UCS2_WORD
#debug_left word _GsmLib_CP1250_TO_UCS2_WORD
#srcline 312 ;  END_IF;
_GsmLib_CP1250_TO_UCS2_WORD_L2:
#srcline 313 ;END_FUNCTION
 PRV  
 LDX  __fc___GsmLib_CP1250_TO_UCS2_WORD
 ULNK
RET
E     61
#endpou 

#pou _GsmLib_CP1251_TO_UCS2_WORD
#srcline 315 ;FUNCTION _GsmLib_CP1251_TO_UCS2_WORD{HIDDEN} : WORD
P     61
_GsmLib_CP1251_TO_UCS2_WORD_L0:
 LINK 0
 NXT
#srcline 318 ;  END_VAR;
#srcline 320 ;  IF b < 128 THEN
 LDX  b
#debug usint b
 LD   usint 128
 LT
 JMC  _GsmLib_CP1251_TO_UCS2_WORD_L1
#srcline 321 ;    _GsmLib_CP1251_TO_UCS2_WORD := USINT_TO_WORD(b);
 LDX  b
#debug usint b
 WRX  __fc___GsmLib_CP1251_TO_UCS2_WORD
#debug_left word _GsmLib_CP1251_TO_UCS2_WORD
#srcline 322 ;  ELSE
 JMP  _GsmLib_CP1251_TO_UCS2_WORD_L2
_GsmLib_CP1251_TO_UCS2_WORD_L1:
#srcline 323 ;    _GsmLib_CP1251_TO_UCS2_WORD := _GsmLib_CP1251_TO_UCS2_128_255[b];
 LEA  _GsmLib_CP1251_TO_UCS2_128_255
 LDX  b
#debug usint b
 SUB  128   ; Low range[1]
 RCHK 127   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 LDIW 
 WRX  __fc___GsmLib_CP1251_TO_UCS2_WORD
#debug_left word _GsmLib_CP1251_TO_UCS2_WORD
#srcline 324 ;  END_IF;
_GsmLib_CP1251_TO_UCS2_WORD_L2:
#srcline 325 ;END_FUNCTION
 PRV  
 LDX  __fc___GsmLib_CP1251_TO_UCS2_WORD
 ULNK
RET
E     61
#endpou 

#pou _GsmLib_CP1253_TO_UCS2_WORD
#srcline 327 ;FUNCTION _GsmLib_CP1253_TO_UCS2_WORD{HIDDEN} : WORD
P     61
_GsmLib_CP1253_TO_UCS2_WORD_L0:
 LINK 0
 NXT
#srcline 330 ;  END_VAR;
#srcline 332 ;  IF b < 128 THEN
 LDX  b
#debug usint b
 LD   usint 128
 LT
 JMC  _GsmLib_CP1253_TO_UCS2_WORD_L1
#srcline 333 ;    _GsmLib_CP1253_TO_UCS2_WORD := USINT_TO_WORD(b);
 LDX  b
#debug usint b
 WRX  __fc___GsmLib_CP1253_TO_UCS2_WORD
#debug_left word _GsmLib_CP1253_TO_UCS2_WORD
#srcline 334 ;  ELSE
 JMP  _GsmLib_CP1253_TO_UCS2_WORD_L2
_GsmLib_CP1253_TO_UCS2_WORD_L1:
#srcline 335 ;    _GsmLib_CP1253_TO_UCS2_WORD := _GsmLib_CP1253_TO_UCS2_128_255[b];
 LEA  _GsmLib_CP1253_TO_UCS2_128_255
 LDX  b
#debug usint b
 SUB  128   ; Low range[1]
 RCHK 127   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 LDIW 
 WRX  __fc___GsmLib_CP1253_TO_UCS2_WORD
#debug_left word _GsmLib_CP1253_TO_UCS2_WORD
#srcline 336 ;  END_IF;
_GsmLib_CP1253_TO_UCS2_WORD_L2:
#srcline 337 ;END_FUNCTION
 PRV  
 LDX  __fc___GsmLib_CP1253_TO_UCS2_WORD
 ULNK
RET
E     61
#endpou 

#pou _GsmLib_CP1252_TO_UCS2_WORD
#srcline 339 ;FUNCTION _GsmLib_CP1252_TO_UCS2_WORD{HIDDEN} : WORD
P     61
_GsmLib_CP1252_TO_UCS2_WORD_L0:
 LINK 0
 NXT
#srcline 342 ;  END_VAR;
#srcline 344 ;  IF b < 128 OR b > 159 THEN
 LDX  b
#debug usint b
 LD   usint 128
 LT
 LDX  b
#debug usint b
 LD   usint 159
 GT
 OR  
 JMC  _GsmLib_CP1252_TO_UCS2_WORD_L1
#srcline 345 ;    _GsmLib_CP1252_TO_UCS2_WORD := USINT_TO_WORD(b);
 LDX  b
#debug usint b
 WRX  __fc___GsmLib_CP1252_TO_UCS2_WORD
#debug_left word _GsmLib_CP1252_TO_UCS2_WORD
#srcline 346 ;  ELSE
 JMP  _GsmLib_CP1252_TO_UCS2_WORD_L2
_GsmLib_CP1252_TO_UCS2_WORD_L1:
#srcline 347 ;    _GsmLib_CP1252_TO_UCS2_WORD := _GsmLib_CP1252_TO_UCS2_128_159[b];
 LEA  _GsmLib_CP1252_TO_UCS2_128_159
 LDX  b
#debug usint b
 SUB  128   ; Low range[1]
 RCHK 31   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 LDIW 
 WRX  __fc___GsmLib_CP1252_TO_UCS2_WORD
#debug_left word _GsmLib_CP1252_TO_UCS2_WORD
#srcline 348 ;  END_IF;
_GsmLib_CP1252_TO_UCS2_WORD_L2:
#srcline 349 ;END_FUNCTION
 PRV  
 LDX  __fc___GsmLib_CP1252_TO_UCS2_WORD
 ULNK
RET
E     61
#endpou 

#pou _GsmLib_CP1255_TO_UCS2_WORD
#srcline 351 ;FUNCTION _GsmLib_CP1255_TO_UCS2_WORD{HIDDEN} : WORD
P     61
_GsmLib_CP1255_TO_UCS2_WORD_L0:
 LINK 0
 NXT
#srcline 354 ;  END_VAR;
#srcline 356 ;  IF b < 128 THEN
 LDX  b
#debug usint b
 LD   usint 128
 LT
 JMC  _GsmLib_CP1255_TO_UCS2_WORD_L1
#srcline 357 ;    _GsmLib_CP1255_TO_UCS2_WORD := USINT_TO_WORD(b);
 LDX  b
#debug usint b
 WRX  __fc___GsmLib_CP1255_TO_UCS2_WORD
#debug_left word _GsmLib_CP1255_TO_UCS2_WORD
#srcline 358 ;  ELSE
 JMP  _GsmLib_CP1255_TO_UCS2_WORD_L2
_GsmLib_CP1255_TO_UCS2_WORD_L1:
#srcline 359 ;    _GsmLib_CP1255_TO_UCS2_WORD := _GsmLib_CP1255_TO_UCS2_128_255[b];
 LEA  _GsmLib_CP1255_TO_UCS2_128_255
 LDX  b
#debug usint b
 SUB  128   ; Low range[1]
 RCHK 127   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 LDIW 
 WRX  __fc___GsmLib_CP1255_TO_UCS2_WORD
#debug_left word _GsmLib_CP1255_TO_UCS2_WORD
#srcline 360 ;  END_IF;
_GsmLib_CP1255_TO_UCS2_WORD_L2:
#srcline 361 ;END_FUNCTION
 PRV  
 LDX  __fc___GsmLib_CP1255_TO_UCS2_WORD
 ULNK
RET
E     61
#endpou 

#pou _GsmLib_UCS2_TO_CP125x_BYTE
#srcline 363 ;FUNCTION _GsmLib_UCS2_TO_CP125x_BYTE{HIDDEN} : BYTE
P     61
_GsmLib_UCS2_TO_CP125x_BYTE_L0:
 LINK 0
 NXT
#srcline 366 ;  END_VAR;
#srcline 367 ;  
#srcline 368 ;  IF w < 256 THEN
 LDX  w
#debug word w
 LD   word 256
 LT
 JMC  _GsmLib_UCS2_TO_CP125x_BYTE_L1
#srcline 369 ;    _GsmLib_UCS2_TO_CP125x_BYTE := WORD_TO_BYTE(w);
 LDX  w
#debug word w
 AND  $FF
 WRX  __fc___GsmLib_UCS2_TO_CP125x_BYTE
#debug_left byte _GsmLib_UCS2_TO_CP125x_BYTE
#srcline 370 ;  ELSIF w < 384 THEN
 JMP  _GsmLib_UCS2_TO_CP125x_BYTE_L2
_GsmLib_UCS2_TO_CP125x_BYTE_L1:
 LDX  w
#debug word w
 LD   word 384
 LT
 JMC  _GsmLib_UCS2_TO_CP125x_BYTE_L3
#srcline 371 ;    _GsmLib_UCS2_TO_CP125x_BYTE := _GsmLib_UCS2_TO_CP125x_256_415[WORD_TO_UINT(w)];
 LEA  _GsmLib_UCS2_TO_CP125x_256_415
 LDX  w
#debug word w
 SUB  256   ; Low range[1]
 RCHK 159   ; Range Check
 ADD     ; + offset 
 LDI  
 WRX  __fc___GsmLib_UCS2_TO_CP125x_BYTE
#debug_left byte _GsmLib_UCS2_TO_CP125x_BYTE
#srcline 372 ;  ELSIF (w >= 704) & (w < 736) THEN
 JMP  _GsmLib_UCS2_TO_CP125x_BYTE_L2
_GsmLib_UCS2_TO_CP125x_BYTE_L3:
 LDX  w
#debug word w
 LD   word 704
 LT
 NEG
 LDX  w
#debug word w
 LD   word 736
 LT
 AND
 JMC  _GsmLib_UCS2_TO_CP125x_BYTE_L4
#srcline 373 ;    _GsmLib_UCS2_TO_CP125x_BYTE := _GsmLib_UCS2_TO_CP125x_704_735[WORD_TO_UINT(w)];
 LEA  _GsmLib_UCS2_TO_CP125x_704_735
 LDX  w
#debug word w
 SUB  704   ; Low range[1]
 RCHK 31   ; Range Check
 ADD     ; + offset 
 LDI  
 WRX  __fc___GsmLib_UCS2_TO_CP125x_BYTE
#debug_left byte _GsmLib_UCS2_TO_CP125x_BYTE
#srcline 374 ;  ELSIF (w >= 896) & (w < 1184) THEN
 JMP  _GsmLib_UCS2_TO_CP125x_BYTE_L2
_GsmLib_UCS2_TO_CP125x_BYTE_L4:
 LDX  w
#debug word w
 LD   word 896
 LT
 NEG
 LDX  w
#debug word w
 LD   word 1184
 LT
 AND
 JMC  _GsmLib_UCS2_TO_CP125x_BYTE_L5
#srcline 375 ;    _GsmLib_UCS2_TO_CP125x_BYTE := _GsmLib_UCS2_TO_CP125x_896_1183[WORD_TO_UINT(w)];
 LEA  _GsmLib_UCS2_TO_CP125x_896_1183
 LDX  w
#debug word w
 SUB  896   ; Low range[1]
 RCHK 287   ; Range Check
 ADD     ; + offset 
 LDI  
 WRX  __fc___GsmLib_UCS2_TO_CP125x_BYTE
#debug_left byte _GsmLib_UCS2_TO_CP125x_BYTE
#srcline 376 ;  ELSIF (w >= 1456) & (w < 1515) THEN
 JMP  _GsmLib_UCS2_TO_CP125x_BYTE_L2
_GsmLib_UCS2_TO_CP125x_BYTE_L5:
 LDX  w
#debug word w
 LD   word 1456
 LT
 NEG
 LDX  w
#debug word w
 LD   word 1515
 LT
 AND
 JMC  _GsmLib_UCS2_TO_CP125x_BYTE_L6
#srcline 377 ;    _GsmLib_UCS2_TO_CP125x_BYTE := UINT_TO_BYTE(WORD_TO_UINT(w)-1264);
 LDX  w
#debug word w
 LD   uint 1264
 SUB
 AND  $FFFF
 AND  $FF
 WRX  __fc___GsmLib_UCS2_TO_CP125x_BYTE
#debug_left byte _GsmLib_UCS2_TO_CP125x_BYTE
#srcline 378 ;  ELSIF (w >= 1520) & (w < 1525) THEN
 JMP  _GsmLib_UCS2_TO_CP125x_BYTE_L2
_GsmLib_UCS2_TO_CP125x_BYTE_L6:
 LDX  w
#debug word w
 LD   word 1520
 LT
 NEG
 LDX  w
#debug word w
 LD   word 1525
 LT
 AND
 JMC  _GsmLib_UCS2_TO_CP125x_BYTE_L7
#srcline 379 ;    _GsmLib_UCS2_TO_CP125x_BYTE := UINT_TO_BYTE(WORD_TO_UINT(w)-1308);
 LDX  w
#debug word w
 LD   uint 1308
 SUB
 AND  $FFFF
 AND  $FF
 WRX  __fc___GsmLib_UCS2_TO_CP125x_BYTE
#debug_left byte _GsmLib_UCS2_TO_CP125x_BYTE
#srcline 380 ;  ELSIF (w >= 8206) & (w < 8256) THEN
 JMP  _GsmLib_UCS2_TO_CP125x_BYTE_L2
_GsmLib_UCS2_TO_CP125x_BYTE_L7:
 LDX  w
#debug word w
 LD   word 8206
 LT
 NEG
 LDX  w
#debug word w
 LD   word 8256
 LT
 AND
 JMC  _GsmLib_UCS2_TO_CP125x_BYTE_L8
#srcline 381 ;    _GsmLib_UCS2_TO_CP125x_BYTE := _GsmLib_UCS2_TO_CP125x_8206_8255[WORD_TO_UINT(w)];
 LEA  _GsmLib_UCS2_TO_CP125x_8206_8255
 LDX  w
#debug word w
 SUB  8206   ; Low range[1]
 RCHK 289   ; Range Check
 ADD     ; + offset 
 LDI  
 WRX  __fc___GsmLib_UCS2_TO_CP125x_BYTE
#debug_left byte _GsmLib_UCS2_TO_CP125x_BYTE
#srcline 382 ;  ELSIF w = 8362 THEN
 JMP  _GsmLib_UCS2_TO_CP125x_BYTE_L2
_GsmLib_UCS2_TO_CP125x_BYTE_L8:
 LDX  w
#debug word w
 LD   word 8362
 EQ
 JMC  _GsmLib_UCS2_TO_CP125x_BYTE_L9
#srcline 383 ;    _GsmLib_UCS2_TO_CP125x_BYTE := 153;
 LD   byte 153
 WRX  __fc___GsmLib_UCS2_TO_CP125x_BYTE
#debug_left byte _GsmLib_UCS2_TO_CP125x_BYTE
#srcline 384 ;  ELSIF w = 8364 THEN
 JMP  _GsmLib_UCS2_TO_CP125x_BYTE_L2
_GsmLib_UCS2_TO_CP125x_BYTE_L9:
 LDX  w
#debug word w
 LD   word 8364
 EQ
 JMC  _GsmLib_UCS2_TO_CP125x_BYTE_L10
#srcline 385 ;    _GsmLib_UCS2_TO_CP125x_BYTE := 128;
 LD   byte 128
 WRX  __fc___GsmLib_UCS2_TO_CP125x_BYTE
#debug_left byte _GsmLib_UCS2_TO_CP125x_BYTE
#srcline 386 ;  ELSIF w = 8470 THEN
 JMP  _GsmLib_UCS2_TO_CP125x_BYTE_L2
_GsmLib_UCS2_TO_CP125x_BYTE_L10:
 LDX  w
#debug word w
 LD   word 8470
 EQ
 JMC  _GsmLib_UCS2_TO_CP125x_BYTE_L11
#srcline 387 ;    _GsmLib_UCS2_TO_CP125x_BYTE := 185;
 LD   byte 185
 WRX  __fc___GsmLib_UCS2_TO_CP125x_BYTE
#debug_left byte _GsmLib_UCS2_TO_CP125x_BYTE
#srcline 388 ;  ELSIF w = 8482 THEN
 JMP  _GsmLib_UCS2_TO_CP125x_BYTE_L2
_GsmLib_UCS2_TO_CP125x_BYTE_L11:
 LDX  w
#debug word w
 LD   word 8482
 EQ
 JMC  _GsmLib_UCS2_TO_CP125x_BYTE_L12
#srcline 389 ;    _GsmLib_UCS2_TO_CP125x_BYTE := 153;
 LD   byte 153
 WRX  __fc___GsmLib_UCS2_TO_CP125x_BYTE
#debug_left byte _GsmLib_UCS2_TO_CP125x_BYTE
#srcline 390 ;  ELSE
 JMP  _GsmLib_UCS2_TO_CP125x_BYTE_L2
_GsmLib_UCS2_TO_CP125x_BYTE_L12:
#srcline 391 ;    _GsmLib_UCS2_TO_CP125x_BYTE := 63;
 LD   byte 63
 WRX  __fc___GsmLib_UCS2_TO_CP125x_BYTE
#debug_left byte _GsmLib_UCS2_TO_CP125x_BYTE
#srcline 392 ;  END_IF;
_GsmLib_UCS2_TO_CP125x_BYTE_L2:
#srcline 393 ;  
#srcline 394 ;END_FUNCTION
 PRV  
 LDX  __fc___GsmLib_UCS2_TO_CP125x_BYTE
 ULNK
RET
E     61
#endpou 

#pou _GsmLib_UCS2_TO_CP125x
#srcline 396 ;FUNCTION _GsmLib_UCS2_TO_CP125x{HIDDEN} : BOOL

#struct _GsmLib_UCS2_TO_CP125x__temp__
  udint i
P     61
_GsmLib_UCS2_TO_CP125x_L0:
 LINK __SizeOf(_GsmLib_UCS2_TO_CP125x__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 405 ;  WHILE (pW^ <> 0) AND (i < 256) DO
_GsmLib_UCS2_TO_CP125x_L1:
 LEAX pW
 LDIL    ; dereference 
 LDIW 
#debug word pW^
 LD   word 0
 EQ
 NEG
 LDY  i
#debug udint i
 LD   udint 256
 LT
 AND
 JMC  _GsmLib_UCS2_TO_CP125x_L2
 DBG 
#srcline 406 ;   pB^ := _GsmLib_UCS2_TO_CP125x_BYTE(pW^);
 NXT
 LEAX pW
 LDIL    ; dereference 
 LDIW 
#debug word pW^
 WR   __Instance___GsmLib_UCS2_TO_CP125x_BYTE~w
#debug_left word __Instance___GsmLib_UCS2_TO_CP125x_BYTE~w
 PRV
 LEA  __Instance___GsmLib_UCS2_TO_CP125x_BYTE
 CAL  _GsmLib_UCS2_TO_CP125x_BYTE_L0
 LEAX pB
 LDIL    ; dereference 
 WRI 
#debug_left byte pB^
#srcline 407 ;   i  := i+1;
 LDY  i
#debug udint i
 LD   udint 1
 ADD
 WRY  i
#debug_left udint i
#srcline 408 ;   pB := pB+1;
 LEAX pB
 LDIL 
#debug pointer pB
 LD   udint 1
 ADD
 LEAX pB
 WRIL 
#debug_left pointer pB
#srcline 409 ;   pW := pW+2;
 LEAX pW
 LDIL 
#debug pointer pW
 LD   udint 2
 ADD
 LEAX pW
 WRIL 
#debug_left pointer pW
#srcline 410 ;  END_WHILE;
 JMP  _GsmLib_UCS2_TO_CP125x_L1
_GsmLib_UCS2_TO_CP125x_L2:
#srcline 412 ;END_FUNCTION
 PRV  
 LDX  __fc___GsmLib_UCS2_TO_CP125x
 ULNK
RET
E     61
#endpou 

#pou _GsmLib_CodeSemiOctetsNumber
#srcline 414 ;FUNCTION _GsmLib_CodeSemiOctetsNumber{HIDDEN} : USINT

#struct _GsmLib_CodeSemiOctetsNumber__temp__
  usint B,
  usint B2,
  pointer SRC,
  usint LNG
P     61
_GsmLib_CodeSemiOctetsNumber_L0:
 LINK __SizeOf(_GsmLib_CodeSemiOctetsNumber__temp__)
 NXT
; Initialize - variables
; End initialize - variables
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  SRC
; End initialize - dynamic variables
#srcline 434 ;  SRC := ADR(Num);
 LDX  Num
#debug pointer Num
 LEAY SRC
 WRIL 
#debug_left pointer SRC
#srcline 435 ;  LNG   := LEN(Num);
 LDX  Num
#debug string Num
 SLEN 
 WRY  LNG
#debug_left usint LNG
#srcline 436 ;  
#srcline 437 ;  IF SRC^ = 43 THEN //skip leading plus '+'
 LEAY SRC
 LDIL    ; dereference 
 LDI  
#debug usint SRC^
 LD   usint 43
 EQ
 JMC  _GsmLib_CodeSemiOctetsNumber_L1
#srcline 438 ;    LNG := LNG - 1;
 LDY  LNG
#debug usint LNG
 LD   usint 1
 SUB
 AND  $FF
 WRY  LNG
#debug_left usint LNG
#srcline 439 ;    SRC := SRC + 1;
 LEAY SRC
 LDIL 
#debug pointer SRC
 LD   udint 1
 ADD
 LEAY SRC
 WRIL 
#debug_left pointer SRC
#srcline 440 ;  END_IF;
_GsmLib_CodeSemiOctetsNumber_L1:
#srcline 441 ;  
#srcline 442 ;  _GsmLib_CodeSemiOctetsNumber := LNG;
 LDY  LNG
#debug usint LNG
 WRX  __fc___GsmLib_CodeSemiOctetsNumber
#debug_left usint _GsmLib_CodeSemiOctetsNumber
#srcline 444 ;  LNG := BYTE_TO_USINT(USINT_TO_BYTE(LNG+1) AND 16#FE); //sude
 LDY  LNG
#debug usint LNG
 LD   usint 1
 ADD
 AND  $FF
 AND  $FF
 LD   byte $FE
 AND
 WRY  LNG
#debug_left usint LNG
#srcline 446 ;  WHILE LNG > 0 DO
_GsmLib_CodeSemiOctetsNumber_L3:
 LDY  LNG
#debug usint LNG
 LD   usint 0
 GT
 JMC  _GsmLib_CodeSemiOctetsNumber_L4
 DBG 
#srcline 447 ;    B  := SRC^; SRC := SRC + 1;
 LEAY SRC
 LDIL    ; dereference 
 LDI  
#debug usint SRC^
 WRY  B
#debug_left usint B
 LEAY SRC
 LDIL 
#debug pointer SRC
 LD   udint 1
 ADD
 LEAY SRC
 WRIL 
#debug_left pointer SRC
#srcline 448 ;    B2 := SRC^; SRC := SRC + 1;
 LEAY SRC
 LDIL    ; dereference 
 LDI  
#debug usint SRC^
 WRY  B2
#debug_left usint B2
 LEAY SRC
 LDIL 
#debug pointer SRC
 LD   udint 1
 ADD
 LEAY SRC
 WRIL 
#debug_left pointer SRC
#srcline 450 ;    IF B2 = 0 THEN
 LDY  B2
#debug usint B2
 LD   usint 0
 EQ
 JMC  _GsmLib_CodeSemiOctetsNumber_L5
#srcline 451 ;      IN^ := 70; //'F'
 LD   usint 70
 LEAX IN
 LDIL    ; dereference 
 WRI 
#debug_left usint IN^
#srcline 452 ;    ELSE
 JMP  _GsmLib_CodeSemiOctetsNumber_L6
_GsmLib_CodeSemiOctetsNumber_L5:
#srcline 453 ;      IN^ := B2;
 LDY  B2
#debug usint B2
 LEAX IN
 LDIL    ; dereference 
 WRI 
#debug_left usint IN^
#srcline 454 ;    END_IF;
_GsmLib_CodeSemiOctetsNumber_L6:
#srcline 455 ;    IN  := IN + 1;
 LEAX IN
 LDIL 
#debug pointer IN
 LD   udint 1
 ADD
 LEAX IN
 WRIL 
#debug_left pointer IN
#srcline 456 ;    IN^ := B; IN  := IN + 1;
 LDY  B
#debug usint B
 LEAX IN
 LDIL    ; dereference 
 WRI 
#debug_left usint IN^
 LEAX IN
 LDIL 
#debug pointer IN
 LD   udint 1
 ADD
 LEAX IN
 WRIL 
#debug_left pointer IN
#srcline 458 ;    LNG := LNG - 2;
 LDY  LNG
#debug usint LNG
 LD   usint 2
 SUB
 AND  $FF
 WRY  LNG
#debug_left usint LNG
#srcline 459 ;  END_WHILE;
 JMP  _GsmLib_CodeSemiOctetsNumber_L3
_GsmLib_CodeSemiOctetsNumber_L4:
#srcline 461 ;(* *)
#srcline 462 ;END_FUNCTION
 PRV  
 LDX  __fc___GsmLib_CodeSemiOctetsNumber
 ULNK
RET
E     61
#endpou 

#pou _GsmLib_DecodeSemiOctetsNumber
#srcline 464 ;FUNCTION _GsmLib_DecodeSemiOctetsNumber{HIDDEN} : USINT

#struct _GsmLib_DecodeSemiOctetsNumber__temp__
  usint B,
  usint B2,
  pointer OUT
P     61
_GsmLib_DecodeSemiOctetsNumber_L0:
 LINK __SizeOf(_GsmLib_DecodeSemiOctetsNumber__temp__)
 NXT
; Initialize - variables
; End initialize - variables
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  OUT
; End initialize - dynamic variables
#srcline 485 ;  LNG   := min(LNG + 1,20);
 LDX  LNG
#debug usint LNG
 LD   usint 1
 ADD
 AND  $FF
 LD   usint 20
 MIN
 WRX  LNG
#debug_left usint LNG
#srcline 486 ;  LNG.0 := 0; //sude
 LD   bool 0       ; false
 WRX  LNG.0
#debug_left bool LNG.0
#srcline 488 ;  _GsmLib_DecodeSemiOctetsNumber := LNG; //return even length
 LDX  LNG
#debug usint LNG
 WRX  __fc___GsmLib_DecodeSemiOctetsNumber
#debug_left usint _GsmLib_DecodeSemiOctetsNumber
#srcline 490 ;  OUT := ADR(Num);
 LDX  Num
#debug pointer Num
 LEAY OUT
 WRIL 
#debug_left pointer OUT
#srcline 492 ;  WHILE LNG > 0 DO
_GsmLib_DecodeSemiOctetsNumber_L1:
 LDX  LNG
#debug usint LNG
 LD   usint 0
 GT
 JMC  _GsmLib_DecodeSemiOctetsNumber_L2
 DBG 
#srcline 493 ;    B  := IN^; IN := IN + 1;
 LEAX IN
 LDIL    ; dereference 
 LDI  
#debug usint IN^
 WRY  B
#debug_left usint B
 LEAX IN
 LDIL 
#debug pointer IN
 LD   udint 1
 ADD
 LEAX IN
 WRIL 
#debug_left pointer IN
#srcline 494 ;    B2 := IN^; IN := IN + 1;
 LEAX IN
 LDIL    ; dereference 
 LDI  
#debug usint IN^
 WRY  B2
#debug_left usint B2
 LEAX IN
 LDIL 
#debug pointer IN
 LD   udint 1
 ADD
 LEAX IN
 WRIL 
#debug_left pointer IN
#srcline 496 ;    IF B > 16#39 THEN
 LDY  B
#debug usint B
 LD   usint $39
 GT
 JMC  _GsmLib_DecodeSemiOctetsNumber_L3
#srcline 497 ;      OUT^ := B2; OUT  := OUT + 1;
 LDY  B2
#debug usint B2
 LEAY OUT
 LDIL    ; dereference 
 WRI 
#debug_left usint OUT^
 LEAY OUT
 LDIL 
#debug pointer OUT
 LD   udint 1
 ADD
 LEAY OUT
 WRIL 
#debug_left pointer OUT
#srcline 498 ;    ELSE
 JMP  _GsmLib_DecodeSemiOctetsNumber_L4
_GsmLib_DecodeSemiOctetsNumber_L3:
#srcline 499 ;      OUT^ := B2; OUT  := OUT + 1;
 LDY  B2
#debug usint B2
 LEAY OUT
 LDIL    ; dereference 
 WRI 
#debug_left usint OUT^
 LEAY OUT
 LDIL 
#debug pointer OUT
 LD   udint 1
 ADD
 LEAY OUT
 WRIL 
#debug_left pointer OUT
#srcline 500 ;      OUT^ := B;  OUT  := OUT + 1;
 LDY  B
#debug usint B
 LEAY OUT
 LDIL    ; dereference 
 WRI 
#debug_left usint OUT^
 LEAY OUT
 LDIL 
#debug pointer OUT
 LD   udint 1
 ADD
 LEAY OUT
 WRIL 
#debug_left pointer OUT
#srcline 501 ;    END_IF;
_GsmLib_DecodeSemiOctetsNumber_L4:
#srcline 503 ;    LNG := LNG - 2;
 LDX  LNG
#debug usint LNG
 LD   usint 2
 SUB
 AND  $FF
 WRX  LNG
#debug_left usint LNG
#srcline 504 ;  END_WHILE;
 JMP  _GsmLib_DecodeSemiOctetsNumber_L1
_GsmLib_DecodeSemiOctetsNumber_L2:
#srcline 506 ;  OUT^ := 0;
 LD   usint 0
 LEAY OUT
 LDIL    ; dereference 
 WRI 
#debug_left usint OUT^
#srcline 507 ;(* *)
#srcline 508 ;END_FUNCTION
 PRV  
 LDX  __fc___GsmLib_DecodeSemiOctetsNumber
 ULNK
RET
E     61
#endpou 

#pou _GsmLib_BYTE_TO_HEX
#srcline 510 ;FUNCTION _GsmLib_BYTE_TO_HEX{HIDDEN} : WORD

#struct _GsmLib_BYTE_TO_HEX__temp__
  byte B1,
  word W
P     61
_GsmLib_BYTE_TO_HEX_L0:
 LINK __SizeOf(_GsmLib_BYTE_TO_HEX__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 519 ;  B1 := B & 16#F;
 LDX  B
#debug byte B
 LD   byte $F
 AND
 WRY  B1
#debug_left byte B1
#srcline 520 ;  IF B1 < 10 THEN
 LDY  B1
#debug byte B1
 LD   byte 10
 LT
 JMC  _GsmLib_BYTE_TO_HEX_L1
#srcline 521 ;    W := BYTE_TO_WORD(B1 OR 16#30);
 LDY  B1
#debug byte B1
 LD   byte $30
 OR  
 WRY  W
#debug_left word W
#srcline 522 ;  ELSE
 JMP  _GsmLib_BYTE_TO_HEX_L2
_GsmLib_BYTE_TO_HEX_L1:
#srcline 523 ;    W := UINT_TO_WORD(BYTE_TO_UINT(B1) + 55);
 LDY  B1
#debug byte B1
 LD   uint 55
 ADD
 AND  $FFFF
 WRY  W
#debug_left word W
#srcline 524 ;  END_IF;
_GsmLib_BYTE_TO_HEX_L2:
#srcline 525 ;  W  := SHL(W,8);
 LDY  W
#debug word W
 LD   uint 8
 SHL
 AND  $FFFF
 WRY  W
#debug_left word W
#srcline 526 ;  B1 := SHR(B & 16#F0,4);
 LDX  B
#debug byte B
 LD   byte $F0
 AND
 LD   uint 4
 SHR
 AND  $FF
 WRY  B1
#debug_left byte B1
#srcline 527 ;  IF B1 < 10 THEN
 LDY  B1
#debug byte B1
 LD   byte 10
 LT
 JMC  _GsmLib_BYTE_TO_HEX_L3
#srcline 528 ;    W := W OR BYTE_TO_WORD(B1 OR 16#30);
 LDY  W
#debug word W
 LDY  B1
#debug byte B1
 LD   byte $30
 OR  
 OR  
 WRY  W
#debug_left word W
#srcline 529 ;  ELSE
 JMP  _GsmLib_BYTE_TO_HEX_L4
_GsmLib_BYTE_TO_HEX_L3:
#srcline 530 ;    W := W OR UINT_TO_WORD(BYTE_TO_UINT(B1) + 55);
 LDY  W
#debug word W
 LDY  B1
#debug byte B1
 LD   uint 55
 ADD
 AND  $FFFF
 OR  
 WRY  W
#debug_left word W
#srcline 531 ;  END_IF;
_GsmLib_BYTE_TO_HEX_L4:
#srcline 532 ;  _GsmLib_BYTE_TO_HEX := W;
 LDY  W
#debug word W
 WRX  __fc___GsmLib_BYTE_TO_HEX
#debug_left word _GsmLib_BYTE_TO_HEX
#srcline 533 ;END_FUNCTION
 PRV  
 LDX  __fc___GsmLib_BYTE_TO_HEX
 ULNK
RET
E     61
#endpou 

#pou _GsmLib_HEX_TO_BYTE
#srcline 535 ;FUNCTION _GsmLib_HEX_TO_BYTE{HIDDEN} : BYTE

#struct _GsmLib_HEX_TO_BYTE__temp__
  byte B,
  byte B2
P     61
_GsmLib_HEX_TO_BYTE_L0:
 LINK __SizeOf(_GsmLib_HEX_TO_BYTE__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 544 ;  B := HEX^ AND 16#CF;
 LEAX HEX
 LDIL    ; dereference 
 LDI  
#debug byte HEX^
 LD   byte $CF
 AND
 WRY  B
#debug_left byte B
#srcline 545 ;  IF B > 9 THEN
 LDY  B
#debug byte B
 LD   byte 9
 GT
 JMC  _GsmLib_HEX_TO_BYTE_L1
#srcline 546 ;    B := USINT_TO_BYTE( BYTE_TO_USINT(B) - 16#37 );
 LDY  B
#debug byte B
 LD   usint $37
 SUB
 AND  $FF
 AND  $FF
 WRY  B
#debug_left byte B
#srcline 547 ;  END_IF;
_GsmLib_HEX_TO_BYTE_L1:
#srcline 548 ;  HEX := HEX + 1;
 LEAX HEX
 LDIL 
#debug pointer HEX
 LD   udint 1
 ADD
 LEAX HEX
 WRIL 
#debug_left pointer HEX
#srcline 549 ;  B2 := HEX^ AND 16#CF;
 LEAX HEX
 LDIL    ; dereference 
 LDI  
#debug byte HEX^
 LD   byte $CF
 AND
 WRY  B2
#debug_left byte B2
#srcline 550 ;  IF B2 > 9 THEN
 LDY  B2
#debug byte B2
 LD   byte 9
 GT
 JMC  _GsmLib_HEX_TO_BYTE_L3
#srcline 551 ;    B2 := USINT_TO_BYTE( BYTE_TO_USINT(B2) - 16#37 );
 LDY  B2
#debug byte B2
 LD   usint $37
 SUB
 AND  $FF
 AND  $FF
 WRY  B2
#debug_left byte B2
#srcline 552 ;  END_IF;
_GsmLib_HEX_TO_BYTE_L3:
#srcline 553 ;  _GsmLib_HEX_TO_BYTE := SHL(B, 4) OR B2;
 LDY  B
#debug byte B
 LD   uint 4
 SHL
 AND  $FF
 LDY  B2
#debug byte B2
 OR  
 WRX  __fc___GsmLib_HEX_TO_BYTE
#debug_left byte _GsmLib_HEX_TO_BYTE
#srcline 554 ;END_FUNCTION
 PRV  
 LDX  __fc___GsmLib_HEX_TO_BYTE
 ULNK
RET
E     61
#endpou 

#pou _GsmLib_CheckBCD
#srcline 556 ;FUNCTION _GsmLib_CheckBCD{HIDDEN} : BOOL
P     61
_GsmLib_CheckBCD_L0:
 LINK 0
 NXT
#srcline 561 ;  _GsmLib_CheckBCD := TRUE;
 LD   bool -1       ; true
 WRX  __fc___GsmLib_CheckBCD
#debug_left bool _GsmLib_CheckBCD
#srcline 563 ;  IF (BCD^ - 16#30) > 9 THEN
 LEAX BCD
 LDIL    ; dereference 
 LDI  
#debug usint BCD^
 LD   usint $30
 SUB
 AND  $FF
 LD   usint 9
 GT
 JMC  _GsmLib_CheckBCD_L1
#srcline 564 ;    _GsmLib_CheckBCD := FALSE;
 LD   bool 0       ; false
 WRX  __fc___GsmLib_CheckBCD
#debug_left bool _GsmLib_CheckBCD
#srcline 565 ;  ELSE
 JMP  _GsmLib_CheckBCD_L2
_GsmLib_CheckBCD_L1:
#srcline 566 ;    BCD := BCD + 1;
 LEAX BCD
 LDIL 
#debug pointer BCD
 LD   udint 1
 ADD
 LEAX BCD
 WRIL 
#debug_left pointer BCD
#srcline 567 ;    IF (BCD^ - 16#30) > 9 THEN
 LEAX BCD
 LDIL    ; dereference 
 LDI  
#debug usint BCD^
 LD   usint $30
 SUB
 AND  $FF
 LD   usint 9
 GT
 JMC  _GsmLib_CheckBCD_L3
#srcline 568 ;      _GsmLib_CheckBCD := FALSE;
 LD   bool 0       ; false
 WRX  __fc___GsmLib_CheckBCD
#debug_left bool _GsmLib_CheckBCD
#srcline 569 ;    END_IF;
_GsmLib_CheckBCD_L3:
#srcline 570 ;  END_IF;
_GsmLib_CheckBCD_L2:
#srcline 572 ;END_FUNCTION
 PRV  
 LDX  __fc___GsmLib_CheckBCD
 ULNK
RET
E     61
#endpou 

#pou _GsmLib_BCD_TO_USINT
#srcline 574 ;FUNCTION _GsmLib_BCD_TO_USINT{HIDDEN} : USINT

#struct _GsmLib_BCD_TO_USINT__temp__
  usint B
P     61
_GsmLib_BCD_TO_USINT_L0:
 LINK __SizeOf(_GsmLib_BCD_TO_USINT__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 583 ;  B := BCD^ - 16#30;
 LEAX BCD
 LDIL    ; dereference 
 LDI  
#debug usint BCD^
 LD   usint $30
 SUB
 AND  $FF
 WRY  B
#debug_left usint B
#srcline 584 ;  BCD := BCD + 1;
 LEAX BCD
 LDIL 
#debug pointer BCD
 LD   udint 1
 ADD
 LEAX BCD
 WRIL 
#debug_left pointer BCD
#srcline 585 ;  _GsmLib_BCD_TO_USINT := B*10 + BCD^ - 16#30;
 LDY  B
#debug usint B
 LD   usint 10
 MUL
 AND  $FF
 LEAX BCD
 LDIL    ; dereference 
 LDI  
#debug usint BCD^
 ADD
 AND  $FF
 LD   usint $30
 SUB
 AND  $FF
 WRX  __fc___GsmLib_BCD_TO_USINT
#debug_left usint _GsmLib_BCD_TO_USINT
#srcline 587 ;END_FUNCTION
 PRV  
 LDX  __fc___GsmLib_BCD_TO_USINT
 ULNK
RET
E     61
#endpou 

#pou _GsmLib_SwapBCD_TO_USINT
#srcline 589 ;FUNCTION _GsmLib_SwapBCD_TO_USINT{HIDDEN} : USINT

#struct _GsmLib_SwapBCD_TO_USINT__temp__
  usint B
P     61
_GsmLib_SwapBCD_TO_USINT_L0:
 LINK __SizeOf(_GsmLib_SwapBCD_TO_USINT__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 598 ;  B := BCD^ - 16#30;
 LEAX BCD
 LDIL    ; dereference 
 LDI  
#debug usint BCD^
 LD   usint $30
 SUB
 AND  $FF
 WRY  B
#debug_left usint B
#srcline 599 ;  BCD := BCD + 1;
 LEAX BCD
 LDIL 
#debug pointer BCD
 LD   udint 1
 ADD
 LEAX BCD
 WRIL 
#debug_left pointer BCD
#srcline 600 ;  _GsmLib_SwapBCD_TO_USINT := (BCD^ - 16#30)*10 + B ;
 LEAX BCD
 LDIL    ; dereference 
 LDI  
#debug usint BCD^
 LD   usint $30
 SUB
 AND  $FF
 LD   usint 10
 MUL
 AND  $FF
 LDY  B
#debug usint B
 ADD
 AND  $FF
 WRX  __fc___GsmLib_SwapBCD_TO_USINT
#debug_left usint _GsmLib_SwapBCD_TO_USINT
#srcline 602 ;END_FUNCTION
 PRV  
 LDX  __fc___GsmLib_SwapBCD_TO_USINT
 ULNK
RET
E     61
#endpou 

#pou _GsmLib_GetGSMDateTime
#srcline 604 ;FUNCTION _GsmLib_GetGSMDateTime{HIDDEN} : DT

#struct _GsmLib_GetGSMDateTime__temp__
  TTecoDateTime tdate
P     61
_GsmLib_GetGSMDateTime_L0:
 LINK __SizeOf(_GsmLib_GetGSMDateTime__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 612 ;  IF _GsmLib_CheckBCD(pGSMDT) THEN
 NXT
 LEAX pGSMDT
 LDIL 
#debug pointer pGSMDT
 LEA  __Instance___GsmLib_CheckBCD~BCD
 WRIL 
#debug_left udint __Instance___GsmLib_CheckBCD~BCD
 PRV
 LEA  __Instance___GsmLib_CheckBCD
 CAL  _GsmLib_CheckBCD_L0
 JMC  _GsmLib_GetGSMDateTime_L1
#srcline 613 ;    tdate.year  := _GsmLib_SwapBCD_TO_USINT(pGSMDT);
 NXT
 LEAX pGSMDT
 LDIL 
#debug pointer pGSMDT
 LEA  __Instance___GsmLib_SwapBCD_TO_USINT~BCD
 WRIL 
#debug_left udint __Instance___GsmLib_SwapBCD_TO_USINT~BCD
 PRV
 LEA  __Instance___GsmLib_SwapBCD_TO_USINT
 CAL  _GsmLib_SwapBCD_TO_USINT_L0
 WRY  tdate~year
#debug_left usint tdate.year
#srcline 614 ;    tdate.month := _GsmLib_SwapBCD_TO_USINT(pGSMDT+2);
 NXT
 LEAX pGSMDT
 LDIL 
#debug pointer pGSMDT
 LD   udint 2
 ADD
 LEA  __Instance___GsmLib_SwapBCD_TO_USINT~BCD
 WRIL 
#debug_left udint __Instance___GsmLib_SwapBCD_TO_USINT~BCD
 PRV
 LEA  __Instance___GsmLib_SwapBCD_TO_USINT
 CAL  _GsmLib_SwapBCD_TO_USINT_L0
 WRY  tdate~month
#debug_left usint tdate.month
#srcline 615 ;    tdate.day   := _GsmLib_SwapBCD_TO_USINT(pGSMDT+4);
 NXT
 LEAX pGSMDT
 LDIL 
#debug pointer pGSMDT
 LD   udint 4
 ADD
 LEA  __Instance___GsmLib_SwapBCD_TO_USINT~BCD
 WRIL 
#debug_left udint __Instance___GsmLib_SwapBCD_TO_USINT~BCD
 PRV
 LEA  __Instance___GsmLib_SwapBCD_TO_USINT
 CAL  _GsmLib_SwapBCD_TO_USINT_L0
 WRY  tdate~day
#debug_left usint tdate.day
#srcline 616 ;    tdate.hour  := _GsmLib_SwapBCD_TO_USINT(pGSMDT+6);
 NXT
 LEAX pGSMDT
 LDIL 
#debug pointer pGSMDT
 LD   udint 6
 ADD
 LEA  __Instance___GsmLib_SwapBCD_TO_USINT~BCD
 WRIL 
#debug_left udint __Instance___GsmLib_SwapBCD_TO_USINT~BCD
 PRV
 LEA  __Instance___GsmLib_SwapBCD_TO_USINT
 CAL  _GsmLib_SwapBCD_TO_USINT_L0
 WRY  tdate~hour
#debug_left usint tdate.hour
#srcline 617 ;    tdate.min   := _GsmLib_SwapBCD_TO_USINT(pGSMDT+8);
 NXT
 LEAX pGSMDT
 LDIL 
#debug pointer pGSMDT
 LD   udint 8
 ADD
 LEA  __Instance___GsmLib_SwapBCD_TO_USINT~BCD
 WRIL 
#debug_left udint __Instance___GsmLib_SwapBCD_TO_USINT~BCD
 PRV
 LEA  __Instance___GsmLib_SwapBCD_TO_USINT
 CAL  _GsmLib_SwapBCD_TO_USINT_L0
 WRY  tdate~min
#debug_left usint tdate.min
#srcline 618 ;    tdate.sec   := _GsmLib_SwapBCD_TO_USINT(pGSMDT+10);
 NXT
 LEAX pGSMDT
 LDIL 
#debug pointer pGSMDT
 LD   udint 10
 ADD
 LEA  __Instance___GsmLib_SwapBCD_TO_USINT~BCD
 WRIL 
#debug_left udint __Instance___GsmLib_SwapBCD_TO_USINT~BCD
 PRV
 LEA  __Instance___GsmLib_SwapBCD_TO_USINT
 CAL  _GsmLib_SwapBCD_TO_USINT_L0
 WRY  tdate~sec
#debug_left usint tdate.sec
#srcline 619 ;    _GsmLib_GetGSMDateTime  := TecoDT_TO_DT(tdate);
 NXT
 LEAY tdate
#debug pointer tdate
 SRC  %IB0
 LEA  __Instance__TecoDT_TO_DT~Teco_DT
#debug_left pointer __Instance__TecoDT_TO_DT~Teco_DT
 LD   9   ;SizeOf() 
 MOV  %IB0
 PRV
 LEA  __Instance__TecoDT_TO_DT
 CAL  TecoDT_TO_DT_L0
 WRX  __fc___GsmLib_GetGSMDateTime
#debug_left dt _GsmLib_GetGSMDateTime
#srcline 620 ;  ELSE
 JMP  _GsmLib_GetGSMDateTime_L2
_GsmLib_GetGSMDateTime_L1:
#srcline 621 ;    _GsmLib_GetGSMDateTime := LREAL_TO_DATE_AND_TIME(0.0);
 LDQ  lreal 0.0
 WRX  __fc___GsmLib_GetGSMDateTime
#debug_left dt _GsmLib_GetGSMDateTime
#srcline 622 ;  END_IF;
_GsmLib_GetGSMDateTime_L2:
#srcline 624 ;END_FUNCTION
 PRV  
 LDX  __fc___GsmLib_GetGSMDateTime
 ULNK
RET
E     61
#endpou 

#pou _GsmLib_CodeTo7bitHEX
#srcline 627 ;FUNCTION _GsmLib_CodeTo7bitHEX{HIDDEN} : USINT

#struct _GsmLib_CodeTo7bitHEX__temp__
  uint rot,
  byte tmp,
  byte res,
  byte old,
  pointer src,
  usint NT
P     61
_GsmLib_CodeTo7bitHEX_L0:
 LINK __SizeOf(_GsmLib_CodeTo7bitHEX__temp__)
 NXT
; Initialize - variables
; End initialize - variables
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  src
; End initialize - dynamic variables
#srcline 646 ;  src := ADR(Text);
 LDX  Text
#debug pointer Text
 LEAY src
 WRIL 
#debug_left pointer src
#srcline 648 ;  IF src^ = 0 THEN   //empty string
 LEAY src
 LDIL    ; dereference 
 LDI  
#debug byte src^
 LD   byte 0
 EQ
 JMC  _GsmLib_CodeTo7bitHEX_L1
#srcline 649 ;    HEX^:= 16#3030;  //00
 LD   word $3030
 LEAX HEX
 LDIL    ; dereference 
 WRIW 
#debug_left word HEX^
#srcline 650 ;    NT  := 1;
 LD   usint 1
 WRY  NT
#debug_left usint NT
#srcline 651 ;  ELSE
 JMP  _GsmLib_CodeTo7bitHEX_L2
_GsmLib_CodeTo7bitHEX_L1:
#srcline 652 ;    WHILE ((src^ <> 0) or (old <> 0)) AND NT <= 140 DO
_GsmLib_CodeTo7bitHEX_L3:
 LEAY src
 LDIL    ; dereference 
 LDI  
#debug byte src^
 LD   byte 0
 EQ
 NEG
 LDY  old
#debug byte old
 LD   byte 0
 EQ
 NEG
 OR  
 LDY  NT
#debug usint NT
 LD   usint 140
 GT
 NEG
 AND
 JMC  _GsmLib_CodeTo7bitHEX_L4
 DBG 
#srcline 653 ;      IF old <> 0 THEN          // process extended char from previous byte
 LDY  old
#debug byte old
 LD   byte 0
 EQ
 NEG
 JMC  _GsmLib_CodeTo7bitHEX_L5
#srcline 654 ;        tmp := SHR(old, rot);   //store
 LDY  old
#debug byte old
 LDY  rot
#debug uint rot
 SHR
 AND  $FF
 WRY  tmp
#debug_left byte tmp
#srcline 655 ;        old := 0;               //clear, we have already proccessed it
 LD   byte 0
 WRY  old
#debug_left byte old
#srcline 656 ;        src := src - 1;         //decrease (will be increased in next step)
 LEAY src
 LDIL 
#debug pointer src
 LD   udint 1
 SUB
 LEAY src
 WRIL 
#debug_left pointer src
#srcline 657 ;      ELSE
 JMP  _GsmLib_CodeTo7bitHEX_L6
_GsmLib_CodeTo7bitHEX_L5:
#srcline 658 ;        IF PlcCoding = ggpc_cp1253 THEN
 LDX  PlcCoding
#debug usint PlcCoding
 LD   udint 3  ; TGSMGatePlcCoding#ggpc_cp1253
 EQ
 JMC  _GsmLib_CodeTo7bitHEX_L7
#srcline 659 ;          res := _GsmLib_CP1253_TO_GSM7_BYTE(BYTE_TO_USINT(src^));  //get GSM char
 NXT
 LEAY src
 LDIL    ; dereference 
 LDI  
#debug byte src^
 WR   __Instance___GsmLib_CP1253_TO_GSM7_BYTE~b
#debug_left usint __Instance___GsmLib_CP1253_TO_GSM7_BYTE~b
 PRV
 LEA  __Instance___GsmLib_CP1253_TO_GSM7_BYTE
 CAL  _GsmLib_CP1253_TO_GSM7_BYTE_L0
 WRY  res
#debug_left byte res
#srcline 660 ;        ELSE
 JMP  _GsmLib_CodeTo7bitHEX_L8
_GsmLib_CodeTo7bitHEX_L7:
#srcline 661 ;          res := _GsmLib_CP125x_TO_GSM7_BYTE(BYTE_TO_USINT(src^));  //get GSM char
 NXT
 LEAY src
 LDIL    ; dereference 
 LDI  
#debug byte src^
 WR   __Instance___GsmLib_CP125x_TO_GSM7_BYTE~b
#debug_left usint __Instance___GsmLib_CP125x_TO_GSM7_BYTE~b
 PRV
 LEA  __Instance___GsmLib_CP125x_TO_GSM7_BYTE
 CAL  _GsmLib_CP125x_TO_GSM7_BYTE_L0
 WRY  res
#debug_left byte res
#srcline 662 ;        END_IF;
_GsmLib_CodeTo7bitHEX_L8:
#srcline 663 ;        tmp := SHR(res, rot);                             //store
 LDY  res
#debug byte res
 LDY  rot
#debug uint rot
 SHR
 AND  $FF
 WRY  tmp
#debug_left byte tmp
#srcline 664 ;      END_IF;
_GsmLib_CodeTo7bitHEX_L6:
#srcline 666 ;      //second part
#srcline 668 ;      IF res <> 27 THEN                                   //it is not extended char
 LDY  res
#debug byte res
 LD   byte 27
 EQ
 NEG
 JMC  _GsmLib_CodeTo7bitHEX_L9
#srcline 669 ;        src := src + 1;                                   //get next byte
 LEAY src
 LDIL 
#debug pointer src
 LD   udint 1
 ADD
 LEAY src
 WRIL 
#debug_left pointer src
#srcline 670 ;        IF PlcCoding = ggpc_cp1253 THEN
 LDX  PlcCoding
#debug usint PlcCoding
 LD   udint 3  ; TGSMGatePlcCoding#ggpc_cp1253
 EQ
 JMC  _GsmLib_CodeTo7bitHEX_L11
#srcline 671 ;          res := _GsmLib_CP1253_TO_GSM7_BYTE(BYTE_TO_USINT(src^));  //get GSM char
 NXT
 LEAY src
 LDIL    ; dereference 
 LDI  
#debug byte src^
 WR   __Instance___GsmLib_CP1253_TO_GSM7_BYTE~b
#debug_left usint __Instance___GsmLib_CP1253_TO_GSM7_BYTE~b
 PRV
 LEA  __Instance___GsmLib_CP1253_TO_GSM7_BYTE
 CAL  _GsmLib_CP1253_TO_GSM7_BYTE_L0
 WRY  res
#debug_left byte res
#srcline 672 ;        ELSE
 JMP  _GsmLib_CodeTo7bitHEX_L12
_GsmLib_CodeTo7bitHEX_L11:
#srcline 673 ;          res := _GsmLib_CP125x_TO_GSM7_BYTE(BYTE_TO_USINT(src^));  //get GSM char
 NXT
 LEAY src
 LDIL    ; dereference 
 LDI  
#debug byte src^
 WR   __Instance___GsmLib_CP125x_TO_GSM7_BYTE~b
#debug_left usint __Instance___GsmLib_CP125x_TO_GSM7_BYTE~b
 PRV
 LEA  __Instance___GsmLib_CP125x_TO_GSM7_BYTE
 CAL  _GsmLib_CP125x_TO_GSM7_BYTE_L0
 WRY  res
#debug_left byte res
#srcline 674 ;        END_IF;
_GsmLib_CodeTo7bitHEX_L12:
#srcline 675 ;        tmp := tmp OR SHL(res, 7-rot);                    //store
 LDY  tmp
#debug byte tmp
 LDY  res
#debug byte res
 LD   uint 7
 LDY  rot
#debug uint rot
 SUB
 AND  $FFFF
 SHL
 AND  $FF
 OR  
 WRY  tmp
#debug_left byte tmp
#srcline 676 ;      ELSE                                                //it was extended char
 JMP  _GsmLib_CodeTo7bitHEX_L10
_GsmLib_CodeTo7bitHEX_L9:
#srcline 677 ;        res := _GsmLib_CP125x_TO_EGSM7_BYTE(src^);
 NXT
 LEAY src
 LDIL    ; dereference 
 LDI  
#debug byte src^
 WR   __Instance___GsmLib_CP125x_TO_EGSM7_BYTE~b
#debug_left byte __Instance___GsmLib_CP125x_TO_EGSM7_BYTE~b
 PRV
 LEA  __Instance___GsmLib_CP125x_TO_EGSM7_BYTE
 CAL  _GsmLib_CP125x_TO_EGSM7_BYTE_L0
 WRY  res
#debug_left byte res
#srcline 678 ;        old := res;
 LDY  res
#debug byte res
 WRY  old
#debug_left byte old
#srcline 679 ;        tmp := tmp OR SHL(res, 7-rot);                    //store value
 LDY  tmp
#debug byte tmp
 LDY  res
#debug byte res
 LD   uint 7
 LDY  rot
#debug uint rot
 SUB
 AND  $FFFF
 SHL
 AND  $FF
 OR  
 WRY  tmp
#debug_left byte tmp
#srcline 680 ;        src := src + 1;                                   //get next byte
 LEAY src
 LDIL 
#debug pointer src
 LD   udint 1
 ADD
 LEAY src
 WRIL 
#debug_left pointer src
#srcline 681 ;      END_IF;
_GsmLib_CodeTo7bitHEX_L10:
#srcline 682 ;      HEX^:= _GsmLib_BYTE_TO_HEX(tmp);                            //store as HEX
 NXT
 LDY  tmp
#debug byte tmp
 WR   __Instance___GsmLib_BYTE_TO_HEX~B
#debug_left byte __Instance___GsmLib_BYTE_TO_HEX~B
 PRV
 LEA  __Instance___GsmLib_BYTE_TO_HEX
 CAL  _GsmLib_BYTE_TO_HEX_L0
 LEAX HEX
 LDIL    ; dereference 
 WRIW 
#debug_left word HEX^
#srcline 683 ;      rot := rot + 1;                                     //increase rotation
 LDY  rot
#debug uint rot
 LD   uint 1
 ADD
 AND  $FFFF
 WRY  rot
#debug_left uint rot
#srcline 684 ;      IF rot = 7 THEN
 LDY  rot
#debug uint rot
 LD   uint 7
 EQ
 JMC  _GsmLib_CodeTo7bitHEX_L13
#srcline 685 ;        IF old <> 0 THEN
 LDY  old
#debug byte old
 LD   byte 0
 EQ
 NEG
 JMC  _GsmLib_CodeTo7bitHEX_L15
#srcline 686 ;          old := 0;
 LD   byte 0
 WRY  old
#debug_left byte old
#srcline 687 ;        ELSIF src^ <> 0 THEN
 JMP  _GsmLib_CodeTo7bitHEX_L16
_GsmLib_CodeTo7bitHEX_L15:
 LEAY src
 LDIL    ; dereference 
 LDI  
#debug byte src^
 LD   byte 0
 EQ
 NEG
 JMC  _GsmLib_CodeTo7bitHEX_L17
#srcline 688 ;          IF res = 27 THEN
 LDY  res
#debug byte res
 LD   byte 27
 EQ
 JMC  _GsmLib_CodeTo7bitHEX_L18
#srcline 689 ;            res := _GsmLib_CP125x_TO_EGSM7_BYTE(src^);
 NXT
 LEAY src
 LDIL    ; dereference 
 LDI  
#debug byte src^
 WR   __Instance___GsmLib_CP125x_TO_EGSM7_BYTE~b
#debug_left byte __Instance___GsmLib_CP125x_TO_EGSM7_BYTE~b
 PRV
 LEA  __Instance___GsmLib_CP125x_TO_EGSM7_BYTE
 CAL  _GsmLib_CP125x_TO_EGSM7_BYTE_L0
 WRY  res
#debug_left byte res
#srcline 690 ;            old := res;
 LDY  res
#debug byte res
 WRY  old
#debug_left byte old
#srcline 691 ;          END_IF;
_GsmLib_CodeTo7bitHEX_L18:
#srcline 692 ;          src := src + 1;                                 //get next byte
 LEAY src
 LDIL 
#debug pointer src
 LD   udint 1
 ADD
 LEAY src
 WRIL 
#debug_left pointer src
#srcline 693 ;        END_IF;
 JMP  _GsmLib_CodeTo7bitHEX_L16
_GsmLib_CodeTo7bitHEX_L17:
_GsmLib_CodeTo7bitHEX_L16:
#srcline 694 ;        rot := 0;
 LD   uint 0
 WRY  rot
#debug_left uint rot
#srcline 695 ;      END_IF;
_GsmLib_CodeTo7bitHEX_L13:
#srcline 696 ;      HEX := HEX + 2;                                     //next value
 LEAX HEX
 LDIL 
#debug pointer HEX
 LD   udint 2
 ADD
 LEAX HEX
 WRIL 
#debug_left pointer HEX
#srcline 697 ;      NT  := NT + 1;                                      //length
 LDY  NT
#debug usint NT
 LD   usint 1
 ADD
 AND  $FF
 WRY  NT
#debug_left usint NT
#srcline 698 ;    END_WHILE;
 JMP  _GsmLib_CodeTo7bitHEX_L3
_GsmLib_CodeTo7bitHEX_L4:
#srcline 699 ;  END_IF;
_GsmLib_CodeTo7bitHEX_L2:
#srcline 700 ;  _GsmLib_CodeTo7bitHEX := NT;
 LDY  NT
#debug usint NT
 WRX  __fc___GsmLib_CodeTo7bitHEX
#debug_left usint _GsmLib_CodeTo7bitHEX
#srcline 701 ;END_FUNCTION
 PRV  
 LDX  __fc___GsmLib_CodeTo7bitHEX
 ULNK
RET
E     61
#endpou 

#pou _GsmLib_Decode7bitHEX
#srcline 703 ;FUNCTION _GsmLib_Decode7bitHEX{HIDDEN} : USINT

#struct _GsmLib_Decode7bitHEX__temp__
  uint rot,
  byte tmp,
  byte res,
  byte old,
  pointer des,
  usint NT
P     61
_GsmLib_Decode7bitHEX_L0:
 LINK __SizeOf(_GsmLib_Decode7bitHEX__temp__)
 NXT
; Initialize - variables
; End initialize - variables
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  des
; End initialize - dynamic variables
#srcline 723 ;  Des := ADR(Text);
 LDX  Text
#debug pointer Text
 LEAY Des
 WRIL 
#debug_left pointer Des
#srcline 725 ;  HEX := HEX + USINT_TO_UDINT(U)*2;
 LEAX HEX
 LDIL 
#debug pointer HEX
 LDX  U
#debug usint U
 LD   udint 2
 MUL
 ADD
 LEAX HEX
 WRIL 
#debug_left pointer HEX
#srcline 726 ;  rot := USINT_TO_UINT(U MOD 7);
 LDX  U
#debug usint U
 LD   usint 7
 MOD
 AND  $FF
 AND  $FFFF
 WRY  rot
#debug_left uint rot
#srcline 728 ;  N := MIN(IN1 := N-UDINT_TO_USINT((USINT_TO_UDINT(U)*8+6)/7), IN2 := 160);
 LDX  N
#debug usint N
 LDX  U
#debug usint U
 LD   udint 8
 MUL
 LD   udint 6
 ADD
 LD   udint 7
 DIVL
 AND  $FF
 SUB
 AND  $FF
 LD   usint 160
 MIN
 WRX  N
#debug_left usint N
#srcline 729 ;  NT := UDINT_TO_USINT(USINT_TO_UDINT(N+1)*7/8);
 LDX  N
#debug usint N
 LD   usint 1
 ADD
 AND  $FF
 LD   udint 7
 MUL
 LD   udint 8
 DIVL
 AND  $FF
 WRY  NT
#debug_left usint NT
#srcline 731 ;  WHILE NT > 0 DO
_GsmLib_Decode7bitHEX_L1:
 LDY  NT
#debug usint NT
 LD   usint 0
 GT
 JMC  _GsmLib_Decode7bitHEX_L2
 DBG 
#srcline 732 ;    NT := NT-1;
 LDY  NT
#debug usint NT
 LD   usint 1
 SUB
 AND  $FF
 WRY  NT
#debug_left usint NT
#srcline 733 ;    tmp := _GsmLib_HEX_TO_BYTE(HEX);
 NXT
 LEAX HEX
 LDIL 
#debug pointer HEX
 LEA  __Instance___GsmLib_HEX_TO_BYTE~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_HEX_TO_BYTE~HEX
 PRV
 LEA  __Instance___GsmLib_HEX_TO_BYTE
 CAL  _GsmLib_HEX_TO_BYTE_L0
 WRY  tmp
#debug_left byte tmp
#srcline 734 ;    HEX := HEX + 2;
 LEAX HEX
 LDIL 
#debug pointer HEX
 LD   udint 2
 ADD
 LEAX HEX
 WRIL 
#debug_left pointer HEX
#srcline 735 ;    res := SHR(tmp, 7-rot);
 LDY  tmp
#debug byte tmp
 LD   uint 7
 LDY  rot
#debug uint rot
 SUB
 AND  $FFFF
 SHR
 AND  $FF
 WRY  res
#debug_left byte res
#srcline 736 ;    des^ := SHL(tmp,rot) AND 16#7F OR old;
 LDY  tmp
#debug byte tmp
 LDY  rot
#debug uint rot
 SHL
 AND  $FF
 LD   byte $7F
 AND
 LDY  old
#debug byte old
 OR  
 LEAY des
 LDIL    ; dereference 
 WRI 
#debug_left byte des^
#srcline 737 ;    IF U = 0 THEN
 LDX  U
#debug usint U
 LD   usint 0
 EQ
 JMC  _GsmLib_Decode7bitHEX_L3
#srcline 738 ;      des := des + 1;
 LEAY des
 LDIL 
#debug pointer des
 LD   udint 1
 ADD
 LEAY des
 WRIL 
#debug_left pointer des
#srcline 739 ;    ELSE
 JMP  _GsmLib_Decode7bitHEX_L4
_GsmLib_Decode7bitHEX_L3:
#srcline 740 ;      U := 0;
 LD   usint 0
 WRX  U
#debug_left usint U
#srcline 741 ;    END_IF;
_GsmLib_Decode7bitHEX_L4:
#srcline 742 ;    IF rot = 6 THEN
 LDY  rot
#debug uint rot
 LD   uint 6
 EQ
 JMC  _GsmLib_Decode7bitHEX_L5
#srcline 743 ;      des^ := res;
 LDY  res
#debug byte res
 LEAY des
 LDIL    ; dereference 
 WRI 
#debug_left byte des^
#srcline 744 ;      des := des + 1;
 LEAY des
 LDIL 
#debug pointer des
 LD   udint 1
 ADD
 LEAY des
 WRIL 
#debug_left pointer des
#srcline 745 ;      rot := DINT_TO_UINT(-1);
 LD   dint -1
 AND  $FFFF
 WRY  rot
#debug_left uint rot
#srcline 746 ;      res := 0;
 LD   byte 0
 WRY  res
#debug_left byte res
#srcline 747 ;    END_IF;
_GsmLib_Decode7bitHEX_L5:
#srcline 748 ;    old := res;
 LDY  res
#debug byte res
 WRY  old
#debug_left byte old
#srcline 749 ;    rot := rot+1;
 LDY  rot
#debug uint rot
 LD   uint 1
 ADD
 AND  $FFFF
 WRY  rot
#debug_left uint rot
#srcline 750 ;  END_WHILE;
 JMP  _GsmLib_Decode7bitHEX_L1
_GsmLib_Decode7bitHEX_L2:
#srcline 751 ;  des^ := 0;
 LD   byte 0
 LEAY des
 LDIL    ; dereference 
 WRI 
#debug_left byte des^
#srcline 752 ;  Des := ADR(Text);
 LDX  Text
#debug pointer Text
 LEAY Des
 WRIL 
#debug_left pointer Des
#srcline 754 ;  _GsmLib_Decode7bitHEX := _GsmLib_GSM7_TO_CP125x(pW := Des, pB := Des, length := N);
 NXT
 LEAY Des
 LDIL 
#debug pointer Des
 LEA  __Instance___GsmLib_GSM7_TO_CP125x~pW
 WRIL 
#debug_left udint __Instance___GsmLib_GSM7_TO_CP125x~pW
 LEAY Des
 LDIL 
#debug pointer Des
 LEA  __Instance___GsmLib_GSM7_TO_CP125x~pB
 WRIL 
#debug_left udint __Instance___GsmLib_GSM7_TO_CP125x~pB
 LDX  N
#debug usint N
 WR   __Instance___GsmLib_GSM7_TO_CP125x~length
#debug_left usint __Instance___GsmLib_GSM7_TO_CP125x~length
 PRV
 LEA  __Instance___GsmLib_GSM7_TO_CP125x
 CAL  _GsmLib_GSM7_TO_CP125x_L0
 WRX  __fc___GsmLib_Decode7bitHEX
#debug_left usint _GsmLib_Decode7bitHEX
#srcline 756 ;END_FUNCTION
 PRV  
 LDX  __fc___GsmLib_Decode7bitHEX
 ULNK
RET
E     61
#endpou 

#pou _GsmLib_CodeTo8bitHEX
#srcline 758 ;FUNCTION _GsmLib_CodeTo8bitHEX{HIDDEN} : USINT

#struct _GsmLib_CodeTo8bitHEX__temp__
  pointer src,
  usint N,
  pointer HEXEND
P     61
_GsmLib_CodeTo8bitHEX_L0:
 LINK __SizeOf(_GsmLib_CodeTo8bitHEX__temp__)
 NXT
; Initialize - variables
; End initialize - variables
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  src
 LD   udint $FFFFFFFF    ; nil
 WRY  HEXEND
; End initialize - dynamic variables
#srcline 773 ;  N := MIN(LEN(Text), 141);
 LDX  Text
#debug string Text
 SLEN 
 LD   usint 141
 MIN
 WRY  N
#debug_left usint N
#srcline 774 ;  HEXEND := HEX + USINT_TO_UDINT(N)*2;
 LEAX HEX
 LDIL 
#debug pointer HEX
 LDY  N
#debug usint N
 LD   udint 2
 MUL
 ADD
 LEAY HEXEND
 WRIL 
#debug_left pointer HEXEND
#srcline 775 ;  src    := ADR(Text);
 LDX  Text
#debug pointer Text
 LEAY src
 WRIL 
#debug_left pointer src
#srcline 776 ;  WHILE PTR_TO_UDINT(HEX) < PTR_TO_UDINT(HEXEND) DO
_GsmLib_CodeTo8bitHEX_L1:
 LEAX HEX
 LDIL 
#debug pointer HEX
 LEAY HEXEND
 LDIL 
#debug pointer HEXEND
 LT
 JMC  _GsmLib_CodeTo8bitHEX_L2
 DBG 
#srcline 777 ;    HEX^ := _GsmLib_BYTE_TO_HEX(src^);
 NXT
 LEAY src
 LDIL    ; dereference 
 LDI  
#debug byte src^
 WR   __Instance___GsmLib_BYTE_TO_HEX~B
#debug_left byte __Instance___GsmLib_BYTE_TO_HEX~B
 PRV
 LEA  __Instance___GsmLib_BYTE_TO_HEX
 CAL  _GsmLib_BYTE_TO_HEX_L0
 LEAX HEX
 LDIL    ; dereference 
 WRIW 
#debug_left word HEX^
#srcline 778 ;    src := src + 1;
 LEAY src
 LDIL 
#debug pointer src
 LD   udint 1
 ADD
 LEAY src
 WRIL 
#debug_left pointer src
#srcline 779 ;    HEX := HEX + 2;
 LEAX HEX
 LDIL 
#debug pointer HEX
 LD   udint 2
 ADD
 LEAX HEX
 WRIL 
#debug_left pointer HEX
#srcline 780 ;  END_WHILE;
 JMP  _GsmLib_CodeTo8bitHEX_L1
_GsmLib_CodeTo8bitHEX_L2:
#srcline 782 ;  _GsmLib_CodeTo8bitHEX := N;
 LDY  N
#debug usint N
 WRX  __fc___GsmLib_CodeTo8bitHEX
#debug_left usint _GsmLib_CodeTo8bitHEX
#srcline 783 ;END_FUNCTION
 PRV  
 LDX  __fc___GsmLib_CodeTo8bitHEX
 ULNK
RET
E     61
#endpou 

#pou _GsmLib_CodeTo8bitHEX2
#srcline 785 ;FUNCTION _GsmLib_CodeTo8bitHEX2{HIDDEN} : USINT

#struct _GsmLib_CodeTo8bitHEX2__temp__
  pointer src,
  usint N,
  pointer HEXEND
P     61
_GsmLib_CodeTo8bitHEX2_L0:
 LINK __SizeOf(_GsmLib_CodeTo8bitHEX2__temp__)
 NXT
; Initialize - variables
; End initialize - variables
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  src
 LD   udint $FFFFFFFF    ; nil
 WRY  HEXEND
; End initialize - dynamic variables
#srcline 801 ;  N := MIN(Lenght, 141);
 LDX  Lenght
#debug usint Lenght
 LD   usint 141
 MIN
 WRY  N
#debug_left usint N
#srcline 802 ;  HEXEND := HEX + USINT_TO_UDINT(N)*2;
 LEAX HEX
 LDIL 
#debug pointer HEX
 LDY  N
#debug usint N
 LD   udint 2
 MUL
 ADD
 LEAY HEXEND
 WRIL 
#debug_left pointer HEXEND
#srcline 803 ;  src    := ADR(Text);
 LDX  Text
#debug pointer Text
 LEAY src
 WRIL 
#debug_left pointer src
#srcline 804 ;  WHILE PTR_TO_UDINT(HEX) < PTR_TO_UDINT(HEXEND) DO
_GsmLib_CodeTo8bitHEX2_L1:
 LEAX HEX
 LDIL 
#debug pointer HEX
 LEAY HEXEND
 LDIL 
#debug pointer HEXEND
 LT
 JMC  _GsmLib_CodeTo8bitHEX2_L2
 DBG 
#srcline 805 ;    HEX^ := _GsmLib_BYTE_TO_HEX(src^);
 NXT
 LEAY src
 LDIL    ; dereference 
 LDI  
#debug byte src^
 WR   __Instance___GsmLib_BYTE_TO_HEX~B
#debug_left byte __Instance___GsmLib_BYTE_TO_HEX~B
 PRV
 LEA  __Instance___GsmLib_BYTE_TO_HEX
 CAL  _GsmLib_BYTE_TO_HEX_L0
 LEAX HEX
 LDIL    ; dereference 
 WRIW 
#debug_left word HEX^
#srcline 806 ;    src := src + 1;
 LEAY src
 LDIL 
#debug pointer src
 LD   udint 1
 ADD
 LEAY src
 WRIL 
#debug_left pointer src
#srcline 807 ;    HEX := HEX + 2;
 LEAX HEX
 LDIL 
#debug pointer HEX
 LD   udint 2
 ADD
 LEAX HEX
 WRIL 
#debug_left pointer HEX
#srcline 808 ;  END_WHILE;
 JMP  _GsmLib_CodeTo8bitHEX2_L1
_GsmLib_CodeTo8bitHEX2_L2:
#srcline 810 ;  _GsmLib_CodeTo8bitHEX2 := N;
 LDY  N
#debug usint N
 WRX  __fc___GsmLib_CodeTo8bitHEX2
#debug_left usint _GsmLib_CodeTo8bitHEX2
#srcline 811 ;END_FUNCTION
 PRV  
 LDX  __fc___GsmLib_CodeTo8bitHEX2
 ULNK
RET
E     61
#endpou 

#pou _GsmLib_Decode8bitHEX
#srcline 815 ;FUNCTION _GsmLib_Decode8bitHEX{HIDDEN} : USINT

#struct _GsmLib_Decode8bitHEX__temp__
  pointer des
P     61
_GsmLib_Decode8bitHEX_L0:
 LINK __SizeOf(_GsmLib_Decode8bitHEX__temp__)
 NXT
; Initialize - variables
; End initialize - variables
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  des
; End initialize - dynamic variables
#srcline 830 ;  Des := ADR(TEXT);
 LDX  TEXT
#debug pointer TEXT
 LEAY Des
 WRIL 
#debug_left pointer Des
#srcline 831 ;  IF U > 0 THEN
 LDX  U
#debug usint U
 LD   usint 0
 GT
 JMC  _GsmLib_Decode8bitHEX_L1
#srcline 832 ;    N := N - U;
 LDX  N
#debug usint N
 LDX  U
#debug usint U
 SUB
 AND  $FF
 WRX  N
#debug_left usint N
#srcline 833 ;    HEX := HEX + USINT_TO_UDINT(U)*2;
 LEAX HEX
 LDIL 
#debug pointer HEX
 LDX  U
#debug usint U
 LD   udint 2
 MUL
 ADD
 LEAX HEX
 WRIL 
#debug_left pointer HEX
#srcline 834 ;  END_IF;
_GsmLib_Decode8bitHEX_L1:
#srcline 835 ;  N := MIN(IN1 := N, IN2 := 140);
 LDX  N
#debug usint N
 LD   usint 140
 MIN
 WRX  N
#debug_left usint N
#srcline 836 ;  _GsmLib_Decode8bitHEX := N;
 LDX  N
#debug usint N
 WRX  __fc___GsmLib_Decode8bitHEX
#debug_left usint _GsmLib_Decode8bitHEX
#srcline 837 ;  WHILE N > 0 DO
_GsmLib_Decode8bitHEX_L3:
 LDX  N
#debug usint N
 LD   usint 0
 GT
 JMC  _GsmLib_Decode8bitHEX_L4
 DBG 
#srcline 838 ;    N := N-1;
 LDX  N
#debug usint N
 LD   usint 1
 SUB
 AND  $FF
 WRX  N
#debug_left usint N
#srcline 839 ;    des^ := _GsmLib_HEX_TO_BYTE(HEX);
 NXT
 LEAX HEX
 LDIL 
#debug pointer HEX
 LEA  __Instance___GsmLib_HEX_TO_BYTE~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_HEX_TO_BYTE~HEX
 PRV
 LEA  __Instance___GsmLib_HEX_TO_BYTE
 CAL  _GsmLib_HEX_TO_BYTE_L0
 LEAY des
 LDIL    ; dereference 
 WRI 
#debug_left byte des^
#srcline 840 ;    HEX := HEX + 2;
 LEAX HEX
 LDIL 
#debug pointer HEX
 LD   udint 2
 ADD
 LEAX HEX
 WRIL 
#debug_left pointer HEX
#srcline 841 ;    des := des + 1;
 LEAY des
 LDIL 
#debug pointer des
 LD   udint 1
 ADD
 LEAY des
 WRIL 
#debug_left pointer des
#srcline 842 ;  END_WHILE;
 JMP  _GsmLib_Decode8bitHEX_L3
_GsmLib_Decode8bitHEX_L4:
#srcline 843 ;  des^ := 0;
 LD   byte 0
 LEAY des
 LDIL    ; dereference 
 WRI 
#debug_left byte des^
#srcline 844 ;  
#srcline 845 ;END_FUNCTION
 PRV  
 LDX  __fc___GsmLib_Decode8bitHEX
 ULNK
RET
E     61
#endpou 

#pou _GsmLib_CodeTo16bitHEX
#srcline 847 ;FUNCTION _GsmLib_CodeTo16bitHEX{HIDDEN} : USINT

#struct _GsmLib_CodeTo16bitHEX__temp__
  pointer src,
  word w,
  usint N,
  pointer HEXEND,
  usint P0__st__
P     61
_GsmLib_CodeTo16bitHEX_L0:
 LINK __SizeOf(_GsmLib_CodeTo16bitHEX__temp__)
 NXT
; Initialize - variables
; End initialize - variables
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  src
 LD   udint $FFFFFFFF    ; nil
 WRY  HEXEND
; End initialize - dynamic variables
#srcline 864 ;  N := MIN(LEN(Text), 71);
 LDX  Text
#debug string Text
 SLEN 
 LD   usint 71
 MIN
 WRY  N
#debug_left usint N
#srcline 865 ;  HEXEND := HEX + USINT_TO_UDINT(N)*4;
 LEAX HEX
 LDIL 
#debug pointer HEX
 LDY  N
#debug usint N
 LD   udint 4
 MUL
 ADD
 LEAY HEXEND
 WRIL 
#debug_left pointer HEXEND
#srcline 866 ;  src    := ADR(Text);
 LDX  Text
#debug pointer Text
 LEAY src
 WRIL 
#debug_left pointer src
#srcline 867 ;  WHILE PTR_TO_UDINT(HEX) < PTR_TO_UDINT(HEXEND) DO
_GsmLib_CodeTo16bitHEX_L1:
 LEAX HEX
 LDIL 
#debug pointer HEX
 LEAY HEXEND
 LDIL 
#debug pointer HEXEND
 LT
 JMC  _GsmLib_CodeTo16bitHEX_L2
 DBG 
#srcline 868 ;    CASE PlcCoding OF
 LDX  PlcCoding
#debug usint PlcCoding
 WRY  P0__st__
 LD   0
 LDY  P0__st__
 EQ  
 JMC  _GsmLib_CodeTo16bitHEX_L4
#srcline 869 ;      ggpc_cp1250 : w := _GsmLib_CP1250_TO_UCS2_WORD(src^);
 NXT
 LEAY src
 LDIL    ; dereference 
 LDI  
#debug usint src^
 WR   __Instance___GsmLib_CP1250_TO_UCS2_WORD~b
#debug_left usint __Instance___GsmLib_CP1250_TO_UCS2_WORD~b
 PRV
 LEA  __Instance___GsmLib_CP1250_TO_UCS2_WORD
 CAL  _GsmLib_CP1250_TO_UCS2_WORD_L0
 WRY  w
#debug_left word w
 JMP  _GsmLib_CodeTo16bitHEX_L3
_GsmLib_CodeTo16bitHEX_L4:
 LD   1
 LDY  P0__st__
 EQ  
 JMC  _GsmLib_CodeTo16bitHEX_L5
#srcline 870 ;      ggpc_cp1251 : w := _GsmLib_CP1251_TO_UCS2_WORD(src^);
 NXT
 LEAY src
 LDIL    ; dereference 
 LDI  
#debug usint src^
 WR   __Instance___GsmLib_CP1251_TO_UCS2_WORD~b
#debug_left usint __Instance___GsmLib_CP1251_TO_UCS2_WORD~b
 PRV
 LEA  __Instance___GsmLib_CP1251_TO_UCS2_WORD
 CAL  _GsmLib_CP1251_TO_UCS2_WORD_L0
 WRY  w
#debug_left word w
 JMP  _GsmLib_CodeTo16bitHEX_L3
_GsmLib_CodeTo16bitHEX_L5:
 LD   2
 LDY  P0__st__
 EQ  
 JMC  _GsmLib_CodeTo16bitHEX_L6
#srcline 871 ;      ggpc_cp1252 : w := _GsmLib_CP1252_TO_UCS2_WORD(src^);
 NXT
 LEAY src
 LDIL    ; dereference 
 LDI  
#debug usint src^
 WR   __Instance___GsmLib_CP1252_TO_UCS2_WORD~b
#debug_left usint __Instance___GsmLib_CP1252_TO_UCS2_WORD~b
 PRV
 LEA  __Instance___GsmLib_CP1252_TO_UCS2_WORD
 CAL  _GsmLib_CP1252_TO_UCS2_WORD_L0
 WRY  w
#debug_left word w
 JMP  _GsmLib_CodeTo16bitHEX_L3
_GsmLib_CodeTo16bitHEX_L6:
 LD   3
 LDY  P0__st__
 EQ  
 JMC  _GsmLib_CodeTo16bitHEX_L7
#srcline 872 ;      ggpc_cp1253 : w := _GsmLib_CP1253_TO_UCS2_WORD(src^);
 NXT
 LEAY src
 LDIL    ; dereference 
 LDI  
#debug usint src^
 WR   __Instance___GsmLib_CP1253_TO_UCS2_WORD~b
#debug_left usint __Instance___GsmLib_CP1253_TO_UCS2_WORD~b
 PRV
 LEA  __Instance___GsmLib_CP1253_TO_UCS2_WORD
 CAL  _GsmLib_CP1253_TO_UCS2_WORD_L0
 WRY  w
#debug_left word w
 JMP  _GsmLib_CodeTo16bitHEX_L3
_GsmLib_CodeTo16bitHEX_L7:
 LD   4
 LDY  P0__st__
 EQ  
 JMC  _GsmLib_CodeTo16bitHEX_L8
#srcline 873 ;      ggpc_cp1255 : w := _GsmLib_CP1255_TO_UCS2_WORD(src^);
 NXT
 LEAY src
 LDIL    ; dereference 
 LDI  
#debug usint src^
 WR   __Instance___GsmLib_CP1255_TO_UCS2_WORD~b
#debug_left usint __Instance___GsmLib_CP1255_TO_UCS2_WORD~b
 PRV
 LEA  __Instance___GsmLib_CP1255_TO_UCS2_WORD
 CAL  _GsmLib_CP1255_TO_UCS2_WORD_L0
 WRY  w
#debug_left word w
 JMP  _GsmLib_CodeTo16bitHEX_L3
_GsmLib_CodeTo16bitHEX_L8:
_GsmLib_CodeTo16bitHEX_L3:
#srcline 875 ;    HEX^ := _GsmLib_BYTE_TO_HEX(WORD_TO_BYTE(SHR(w,8)));
 NXT
 LDY  w
#debug word w
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WR   __Instance___GsmLib_BYTE_TO_HEX~B
#debug_left byte __Instance___GsmLib_BYTE_TO_HEX~B
 PRV
 LEA  __Instance___GsmLib_BYTE_TO_HEX
 CAL  _GsmLib_BYTE_TO_HEX_L0
 LEAX HEX
 LDIL    ; dereference 
 WRIW 
#debug_left word HEX^
#srcline 876 ;    HEX  := HEX + 2;
 LEAX HEX
 LDIL 
#debug pointer HEX
 LD   udint 2
 ADD
 LEAX HEX
 WRIL 
#debug_left pointer HEX
#srcline 877 ;    HEX^ := _GsmLib_BYTE_TO_HEX(WORD_TO_BYTE(w));
 NXT
 LDY  w
#debug word w
 AND  $FF
 WR   __Instance___GsmLib_BYTE_TO_HEX~B
#debug_left byte __Instance___GsmLib_BYTE_TO_HEX~B
 PRV
 LEA  __Instance___GsmLib_BYTE_TO_HEX
 CAL  _GsmLib_BYTE_TO_HEX_L0
 LEAX HEX
 LDIL    ; dereference 
 WRIW 
#debug_left word HEX^
#srcline 878 ;    HEX  := HEX + 2;
 LEAX HEX
 LDIL 
#debug pointer HEX
 LD   udint 2
 ADD
 LEAX HEX
 WRIL 
#debug_left pointer HEX
#srcline 879 ;    src  := src + 1;
 LEAY src
 LDIL 
#debug pointer src
 LD   udint 1
 ADD
 LEAY src
 WRIL 
#debug_left pointer src
#srcline 880 ;  END_WHILE;
 JMP  _GsmLib_CodeTo16bitHEX_L1
_GsmLib_CodeTo16bitHEX_L2:
#srcline 881 ;  _GsmLib_CodeTo16bitHEX := N*2;
 LDY  N
#debug usint N
 LD   usint 2
 MUL
 AND  $FF
 WRX  __fc___GsmLib_CodeTo16bitHEX
#debug_left usint _GsmLib_CodeTo16bitHEX
#srcline 882 ;END_FUNCTION
 PRV  
 LDX  __fc___GsmLib_CodeTo16bitHEX
 ULNK
RET
E     61
#endpou 

#pou _GsmLib_Decode16bitHEX
#srcline 884 ;FUNCTION _GsmLib_Decode16bitHEX{HIDDEN} : USINT

#struct _GsmLib_Decode16bitHEX__temp__
  pointer des,
  word w
P     61
_GsmLib_Decode16bitHEX_L0:
 LINK __SizeOf(_GsmLib_Decode16bitHEX__temp__)
 NXT
; Initialize - variables
; End initialize - variables
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  des
; End initialize - dynamic variables
#srcline 900 ;  Des := ADR(TEXT);
 LDX  TEXT
#debug pointer TEXT
 LEAY Des
 WRIL 
#debug_left pointer Des
#srcline 901 ;  IF U > 0 THEN
 LDX  U
#debug usint U
 LD   usint 0
 GT
 JMC  _GsmLib_Decode16bitHEX_L1
#srcline 902 ;    N := N - U;
 LDX  N
#debug usint N
 LDX  U
#debug usint U
 SUB
 AND  $FF
 WRX  N
#debug_left usint N
#srcline 903 ;    HEX := HEX + USINT_TO_UDINT(U)*4;
 LEAX HEX
 LDIL 
#debug pointer HEX
 LDX  U
#debug usint U
 LD   udint 4
 MUL
 ADD
 LEAX HEX
 WRIL 
#debug_left pointer HEX
#srcline 904 ;  END_IF;
_GsmLib_Decode16bitHEX_L1:
#srcline 905 ;  N := MIN(IN1 := N/2, IN2 := 70);
 LDX  N
#debug usint N
 LD   usint 2
 DIVL
 AND  $FF
 LD   usint 70
 MIN
 WRX  N
#debug_left usint N
#srcline 906 ;  _GsmLib_Decode16bitHEX := N;
 LDX  N
#debug usint N
 WRX  __fc___GsmLib_Decode16bitHEX
#debug_left usint _GsmLib_Decode16bitHEX
#srcline 907 ;  WHILE N > 0 DO
_GsmLib_Decode16bitHEX_L3:
 LDX  N
#debug usint N
 LD   usint 0
 GT
 JMC  _GsmLib_Decode16bitHEX_L4
 DBG 
#srcline 908 ;    N := N-1;
 LDX  N
#debug usint N
 LD   usint 1
 SUB
 AND  $FF
 WRX  N
#debug_left usint N
#srcline 909 ;    w := BYTE_TO_WORD(_GsmLib_HEX_TO_BYTE(HEX));
 NXT
 LEAX HEX
 LDIL 
#debug pointer HEX
 LEA  __Instance___GsmLib_HEX_TO_BYTE~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_HEX_TO_BYTE~HEX
 PRV
 LEA  __Instance___GsmLib_HEX_TO_BYTE
 CAL  _GsmLib_HEX_TO_BYTE_L0
 WRY  w
#debug_left word w
#srcline 910 ;    HEX := HEX + 2;
 LEAX HEX
 LDIL 
#debug pointer HEX
 LD   udint 2
 ADD
 LEAX HEX
 WRIL 
#debug_left pointer HEX
#srcline 911 ;    w := SHL(w,8) OR BYTE_TO_WORD(_GsmLib_HEX_TO_BYTE(HEX));
 LDY  w
#debug word w
 LD   uint 8
 SHL
 AND  $FFFF
 NXT
 LEAX HEX
 LDIL 
#debug pointer HEX
 LEA  __Instance___GsmLib_HEX_TO_BYTE~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_HEX_TO_BYTE~HEX
 PRV
 LEA  __Instance___GsmLib_HEX_TO_BYTE
 CAL  _GsmLib_HEX_TO_BYTE_L0
 OR  
 WRY  w
#debug_left word w
#srcline 912 ;    HEX := HEX + 2;
 LEAX HEX
 LDIL 
#debug pointer HEX
 LD   udint 2
 ADD
 LEAX HEX
 WRIL 
#debug_left pointer HEX
#srcline 913 ;    des^ := _GsmLib_UCS2_TO_CP125x_BYTE(w);
 NXT
 LDY  w
#debug word w
 WR   __Instance___GsmLib_UCS2_TO_CP125x_BYTE~w
#debug_left word __Instance___GsmLib_UCS2_TO_CP125x_BYTE~w
 PRV
 LEA  __Instance___GsmLib_UCS2_TO_CP125x_BYTE
 CAL  _GsmLib_UCS2_TO_CP125x_BYTE_L0
 LEAY des
 LDIL    ; dereference 
 WRI 
#debug_left byte des^
#srcline 914 ;    des := des + 1;
 LEAY des
 LDIL 
#debug pointer des
 LD   udint 1
 ADD
 LEAY des
 WRIL 
#debug_left pointer des
#srcline 915 ;  END_WHILE;
 JMP  _GsmLib_Decode16bitHEX_L3
_GsmLib_Decode16bitHEX_L4:
#srcline 916 ;  des^ := 0;
 LD   byte 0
 LEAY des
 LDIL    ; dereference 
 WRI 
#debug_left byte des^
#srcline 917 ;END_FUNCTION
 PRV  
 LDX  __fc___GsmLib_Decode16bitHEX
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'D:\TECOLIB\GSM_LIBRARYX2\GSMLIBCONTROL\SMS_HANDLER.ST'
#pou SMS_HANDLER
#srcline 1 ;FUNCTION_BLOCK SMS_HANDLER

#struct SMS_HANDLER__temp__
  int pos,
  pointer pusint,
  pointer pstring,
  bool NewMessage,
  usint tusint,
  usint P0__st__,
  usint P1__st__,
  usint P2__st__,
  string[257] PS0__st__,
  string[257] PSC__st__
#data byte _str_SMS_HANDLER_0 = 
  'D','T','#','2','0',0
P     61
SMS_HANDLER_L0:
 LINK __SizeOf(SMS_HANDLER__temp__)
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  pusint
 LD   udint $FFFFFFFF    ; nil
 WRY  pstring
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  Send
 LETX __EDGE_R__Send
 WRX  Send
 LDX  Ussd
 LETX __EDGE_R__Ussd
 WRX  Ussd
 LDX  Reset
 LETX __EDGE_R__Reset
 WRX  Reset
 LDX  Dial
 LETX __EDGE_R__Dial
 WRX  Dial
#srcline 73 ;  IF Stop THEN RETURN; END_IF;
 LDX  Stop
#debug bool Stop
 JMC  SMS_HANDLER_L1
 JMP  SMS_HANDLER_RET
SMS_HANDLER_L1:
#srcline 75 ;  //transmit settings
#srcline 76 ;  CH_OUT.STCO.5 := 1; //TRG
 LD   bool -1      ; true
 LDX  CH_OUT
 MUL  8   ; -> bool pointer 
 ADD  5   ; Bool offset 
 WRIB 
#debug_left bool CH_OUT.STCO.5
#srcline 78 ;  NewMess := 0; //clear new SMS flag
 LD   bool 0       ; false
 WRX  NewMess
#debug_left bool NewMess
#srcline 80 ;  NewMessage := LastArc XOR CH_IN.STCO.7; //new message from channel
 LDX  LastArc
#debug bool LastArc
 LDX  CH_IN
 MUL  8   ; -> bool pointer 
 ADD  7   ; Bool offset 
 LDIB 
#debug bool CH_IN.STCO.7
 XOR 
 WRY  NewMessage
#debug_left bool NewMessage
#srcline 82 ;  //timeout settings
#srcline 83 ;  IF State <> ggso_Ringing THEN
 LDX  State
#debug usint State
 LD   udint 22  ; TGSMGateStateOut#ggso_Ringing
 EQ
 NEG
 JMC  SMS_HANDLER_L3
#srcline 84 ;    IF SendPending OR UssdPending OR State = ggso_Reset THEN
 LDX  SendPending
#debug bool SendPending
 LDX  UssdPending
#debug bool UssdPending
 OR  
 LDX  State
#debug usint State
 LD   udint 2  ; TGSMGateStateOut#ggso_Reset
 EQ
 OR  
 JMC  SMS_HANDLER_L5
#srcline 85 ;      TimeOut.PT := longtimeout;
 LD   time 10000
 WRX  TimeOut~PT
#debug_left time TimeOut.PT
#srcline 86 ;    ELSE
 JMP  SMS_HANDLER_L6
SMS_HANDLER_L5:
#srcline 87 ;      TimeOut.PT := shorttimeout;
 LD   time 5000
 WRX  TimeOut~PT
#debug_left time TimeOut.PT
#srcline 88 ;    END_IF;
SMS_HANDLER_L6:
#srcline 89 ;  END_IF;
SMS_HANDLER_L3:
#srcline 91 ;  TimeOut(IN := NOT NewMessage & NOT TimeOut.Q & NOT WaitTime.Q & NOT HardErr);
 LDY  NewMessage
#debug bool NewMessage
 NEG
 LDX  TimeOut~Q
#debug bool TimeOut.Q
 NEG
 AND
 LDX  WaitTime~Q
#debug bool WaitTime.Q
 NEG
 AND
 LDX  HardErr
#debug bool HardErr
 NEG
 AND
 WRX  TimeOut~IN
#debug_left bool TimeOut~IN
 LEAX TimeOut
 CAL  TON_L0
#srcline 93 ;  IF TimeOut.Q AND State = ggso_Ringing THEN
 LDX  TimeOut~Q
#debug bool TimeOut.Q
 LDX  State
#debug usint State
 LD   udint 22  ; TGSMGateStateOut#ggso_Ringing
 EQ
 AND
 JMC  SMS_HANDLER_L7
#srcline 94 ;    TimeOut(IN := false);       //reset timeout
 LD   bool 0       ; false
 WRX  TimeOut~IN
#debug_left bool TimeOut~IN
 LEAX TimeOut
 CAL  TON_L0
#srcline 95 ;    State := ggso_CancelCall;
 LD   udint 23  ; TGSMGateStateOut#ggso_CancelCall
 WRX  State
#debug_left usint State
#srcline 96 ;    MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 97 ;  END_IF;
SMS_HANDLER_L7:
#srcline 99 ;  //reset
#srcline 100 ;  IF Reset OR TimeOut.Q THEN
 LDX  Reset
#debug bool Reset
 LDX  TimeOut~Q
#debug bool TimeOut.Q
 OR  
 JMC  SMS_HANDLER_L9
#srcline 101 ;    InitDone := false;
 LD   bool 0       ; false
 WRX  InitDone
#debug_left bool InitDone
#srcline 102 ;    pusint := ADR(RecvMess);
 LDX  RecvMess
#debug pointer RecvMess
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 103 ;    pusint^ := 0;
 LD   usint 0
 LEAY pusint
 LDIL    ; dereference 
 WRI 
#debug_left usint pusint^
#srcline 104 ;    Ring := false;
 LD   bool 0       ; false
 WRX  Ring
#debug_left bool Ring
#srcline 105 ;    HardErr := false;
 LD   bool 0       ; false
 WRX  HardErr
#debug_left bool HardErr
#srcline 106 ;    ColdRestart := Cold;
 LDX  Cold
#debug bool Cold
 WRX  ColdRestart
#debug_left bool ColdRestart
#srcline 107 ;    SendPending := false;
 LD   bool 0       ; false
 WRX  SendPending
#debug_left bool SendPending
#srcline 108 ;    UssdPending := false;
 LD   bool 0       ; false
 WRX  UssdPending
#debug_left bool UssdPending
#srcline 109 ;    DialPending := false;
 LD   bool 0       ; false
 WRX  DialPending
#debug_left bool DialPending
#srcline 110 ;    State := ggso_Init;
 LD   udint 0  ; TGSMGateStateOut#ggso_Init
 WRX  State
#debug_left usint State
#srcline 111 ;    MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 112 ;    LastArc := CH_IN.STCO.7;
 LDX  CH_IN
 MUL  8   ; -> bool pointer 
 ADD  7   ; Bool offset 
 LDIB 
#debug bool CH_IN.STCO.7
 WRX  LastArc
#debug_left bool LastArc
#srcline 113 ;    Error := gger_None;
 LD   udint 0  ; TGSMGateError#gger_None
 WRX  Error
#debug_left usint Error
#srcline 114 ;    ReadErrs := 0;
 LD   usint 0
 WRX  ReadErrs
#debug_left usint ReadErrs
#srcline 115 ;  END_IF;
SMS_HANDLER_L9:
#srcline 117 ;  //store request to send SMS
#srcline 118 ;  IF Send THEN
 LDX  Send
#debug bool Send
 JMC  SMS_HANDLER_L11
#srcline 119 ;    SendPending := true;
 LD   bool -1       ; true
 WRX  SendPending
#debug_left bool SendPending
#srcline 120 ;    l_Recipient := Recipient;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   20
 DST    ; Level 1
 LDX  Recipient
#debug string Recipient
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX l_Recipient
 WRI  
 LEAX l_Recipient
 LD   20
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string l_Recipient
 PDST   ; Level 1
#srcline 121 ;    l_MessToSend   := MessToSend;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   160
 DST    ; Level 1
 LDX  MessToSend
#debug string MessToSend
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX l_MessToSend
 WRI  
 LEAX l_MessToSend
 LD   160
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string l_MessToSend
 PDST   ; Level 1
#srcline 122 ;  END_IF;
SMS_HANDLER_L11:
#srcline 124 ;  //store request to send USSD
#srcline 125 ;  IF Ussd THEN
 LDX  Ussd
#debug bool Ussd
 JMC  SMS_HANDLER_L13
#srcline 126 ;    UssdPending := true;
 LD   bool -1       ; true
 WRX  UssdPending
#debug_left bool UssdPending
#srcline 127 ;    l_USSD := Recipient;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   20
 DST    ; Level 1
 LDX  Recipient
#debug string Recipient
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX l_USSD
 WRI  
 LEAX l_USSD
 LD   20
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string l_USSD
 PDST   ; Level 1
#srcline 128 ;  END_IF;
SMS_HANDLER_L13:
#srcline 130 ;  //set flag when dialing number
#srcline 131 ;  IF Ready AND Dial THEN
 LDX  Ready
#debug bool Ready
 LDX  Dial
#debug bool Dial
 AND
 JMC  SMS_HANDLER_L15
#srcline 132 ;    IF State <> ggso_Ringing THEN
 LDX  State
#debug usint State
 LD   udint 22  ; TGSMGateStateOut#ggso_Ringing
 EQ
 NEG
 JMC  SMS_HANDLER_L17
#srcline 133 ;      DialPending := true;
 LD   bool -1       ; true
 WRX  DialPending
#debug_left bool DialPending
#srcline 134 ;    END_IF;
SMS_HANDLER_L17:
#srcline 135 ;  END_IF;
SMS_HANDLER_L15:
#srcline 137 ;  //pusint := ADR(State); //pointer to state variable for numeric comparations
#srcline 139 ;  //set GSM gateway ready flag
#srcline 140 ;  Ready := InitDone & Error = gger_None & NOT SendPending & NOT UssdPending & NOT DialPending & NOT Ring & Signal <> -1;
 LDX  InitDone
#debug bool InitDone
 LDX  Error
#debug usint Error
 LD   udint 0  ; TGSMGateError#gger_None
 EQ
 AND
 LDX  SendPending
#debug bool SendPending
 NEG
 AND
 LDX  UssdPending
#debug bool UssdPending
 NEG
 AND
 LDX  DialPending
#debug bool DialPending
 NEG
 AND
 LDX  Ring
#debug bool Ring
 NEG
 AND
 LDX  Signal
#debug sint Signal
 EXTB 
 LD   sint -1
 EQ
 NEG
 AND
 WRX  Ready
#debug_left bool Ready
#srcline 141 ;  (*
#srcline 142 ;  IF Ready THEN
#srcline 143 ;    WaitTime.PT := Pause2;
#srcline 144 ;  ELSE
#srcline 145 ;    WaitTime.PT := Pause3;
#srcline 146 ;  END_IF;
#srcline 147 ;  *)
#srcline 149 ;  //quasi-states
#srcline 150 ;  CASE State OF
 LDX  State
#debug usint State
 WRY  P0__st__
 LD   11
 LDY  P0__st__
 EQ  
 JMC  SMS_HANDLER_L20
#srcline 151 ;    ggso_EraseQuery:
#srcline 152 ;      Counter := 1;
 LD   usint 1
 WRX  Counter
#debug_left usint Counter
#srcline 153 ;      IF Erase & NeedErase THEN
 LDX  Erase
#debug bool Erase
 LDX  NeedErase
#debug bool NeedErase
 AND
 JMC  SMS_HANDLER_L21
#srcline 154 ;        State := ggso_Erase;
 LD   udint 12  ; TGSMGateStateOut#ggso_Erase
 WRX  State
#debug_left usint State
#srcline 155 ;      ELSE
 JMP  SMS_HANDLER_L22
SMS_HANDLER_L21:
#srcline 156 ;        State := ggso_SignalQ;
 LD   udint 20  ; TGSMGateStateOut#ggso_SignalQ
 WRX  State
#debug_left usint State
#srcline 157 ;      END_IF;
SMS_HANDLER_L22:
#srcline 158 ;      MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
 JMP  SMS_HANDLER_L19
SMS_HANDLER_L20:
 LD   14
 LDY  P0__st__
 EQ  
 JMC  SMS_HANDLER_L23
#srcline 159 ;    ggso_ReadQuery:
#srcline 160 ;      WaitTime.PT := Pause1;
 LD   time 500
 WRX  WaitTime~PT
#debug_left time WaitTime.PT
#srcline 161 ;      Counter := 1;
 LD   usint 1
 WRX  Counter
#debug_left usint Counter
#srcline 162 ;      State := ggso_Read;
 LD   udint 15  ; TGSMGateStateOut#ggso_Read
 WRX  State
#debug_left usint State
#srcline 163 ;      MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
 JMP  SMS_HANDLER_L19
SMS_HANDLER_L23:
SMS_HANDLER_L19:
#srcline 166 ;  //receiving messages from channel
#srcline 167 ;  IF NewMessage THEN //ARC
 LDY  NewMessage
#debug bool NewMessage
 JMC  SMS_HANDLER_L24
#srcline 169 ;    pusint := ADR(CH_IN.DATA) + UINT_TO_UDINT(CH_IN.NUM);
 LDX  CH_IN
 ADD  4  ; + offset 
#debug pointer CH_IN.DATA
 LDX  CH_IN
 ADD  2  ; + offset 
 LDIW 
#debug uint CH_IN.NUM
 ADD
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 170 ;    pusint^ := 0;
 LD   usint 0
 LEAY pusint
 LDIL    ; dereference 
 WRI 
#debug_left usint pusint^
#srcline 172 ;    LastArc := NOT LastArc;
 LDX  LastArc
#debug bool LastArc
 NEG
 WRX  LastArc
#debug_left bool LastArc
#srcline 174 ;    IF CH_IN.ERR <> 0 THEN
 LDX  CH_IN
 ADD  1  ; + offset 
 LDI  
#debug usint CH_IN.ERR
 LD   usint 0
 EQ
 NEG
 JMC  SMS_HANDLER_L26
#srcline 175 ;      State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 176 ;      Error := gger_Channel_error;
 LD   udint 12  ; TGSMGateError#gger_Channel_error
 WRX  Error
#debug_left usint Error
#srcline 177 ;      RETURN;
 JMP  SMS_HANDLER_RET
#srcline 178 ;    END_IF;
SMS_HANDLER_L26:
#srcline 180 ;    //unsolicited messages
#srcline 181 ;    //RING
#srcline 182 ;    IF FIND(IN1 := CH_IN.DATA, IN2 := _GsmLib_AtReplyRING) > 0 THEN
 LDX  CH_IN
 ADD  4  ; + offset 
#debug string CH_IN.DATA
 LEA  _GsmLib_AtReplyRING
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_L28
#srcline 183 ;      //Ring := true; presunuto do prijmu ggso_RingNumber
#srcline 184 ;      State := ggso_RingNumber;
 LD   udint 21  ; TGSMGateStateOut#ggso_RingNumber
 WRX  State
#debug_left usint State
#srcline 185 ;      MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 186 ;      RETURN;
 JMP  SMS_HANDLER_RET
#srcline 187 ;    END_IF;
SMS_HANDLER_L28:
#srcline 188 ;    //+CMTI
#srcline 189 ;    IF FIND(IN1 := CH_IN.DATA, IN2 := _GsmLib_AtReplyCMTI) > 0 THEN
 LDX  CH_IN
 ADD  4  ; + offset 
#debug string CH_IN.DATA
 LEA  _GsmLib_AtReplyCMTI
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_L30
#srcline 190 ;      State   := ggso_SignalQ;
 LD   udint 20  ; TGSMGateStateOut#ggso_SignalQ
 WRX  State
#debug_left usint State
#srcline 191 ;      MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 192 ;      RETURN;
 JMP  SMS_HANDLER_RET
#srcline 193 ;    END_IF;
SMS_HANDLER_L30:
#srcline 194 ;    //states
#srcline 195 ;    ok := FIND(IN1 := CH_IN.DATA, IN2 := _GsmLib_OkString) > 0;
 LDX  CH_IN
 ADD  4  ; + offset 
#debug string CH_IN.DATA
 LEA  _GsmLib_OkString
 SFND 
 LD   int 0
 GTS
 WRX  ok
#debug_left bool ok
#srcline 196 ;    
#srcline 197 ;    CASE State OF
 LDX  State
#debug usint State
 WRY  P1__st__
 LD   0
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_L33
#srcline 198 ;      ggso_Init :
#srcline 199 ;        MaxReadErrs := 50;
 LD   usint 50
 WRX  MaxReadErrs
#debug_left usint MaxReadErrs
#srcline 200 ;        WaitTime.PT := Pause4;
 LD   time 3000
 WRX  WaitTime~PT
#debug_left time WaitTime.PT
#srcline 201 ;        IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_L34
#srcline 202 ;          IF ColdRestart THEN
 LDX  ColdRestart
#debug bool ColdRestart
 JMC  SMS_HANDLER_L36
#srcline 203 ;            WaitTime.PT := Pause1;
 LD   time 500
 WRX  WaitTime~PT
#debug_left time WaitTime.PT
#srcline 204 ;            ColdRestart := false;
 LD   bool 0       ; false
 WRX  ColdRestart
#debug_left bool ColdRestart
#srcline 205 ;            State := ggso_BaudRate;
 LD   udint 1  ; TGSMGateStateOut#ggso_BaudRate
 WRX  State
#debug_left usint State
#srcline 206 ;          ELSE
 JMP  SMS_HANDLER_L37
SMS_HANDLER_L36:
#srcline 207 ;            State := ggso_Conf6;
 LD   udint 26  ; TGSMGateStateOut#ggso_Conf6
 WRX  State
#debug_left usint State
#srcline 208 ;          END_IF;
SMS_HANDLER_L37:
#srcline 209 ;          MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 210 ;        END_IF;
SMS_HANDLER_L34:
 JMP  SMS_HANDLER_L32
SMS_HANDLER_L33:
 LD   1
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_L38
#srcline 211 ;      ggso_BaudRate:
#srcline 212 ;        IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_L39
#srcline 213 ;          State := ggso_Reset;
 LD   udint 2  ; TGSMGateStateOut#ggso_Reset
 WRX  State
#debug_left usint State
#srcline 214 ;          MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 215 ;        END_IF;
SMS_HANDLER_L39:
 JMP  SMS_HANDLER_L32
SMS_HANDLER_L38:
 LD   2
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_L41
#srcline 216 ;      ggso_Reset:
#srcline 217 ;        IF FIND(IN1 := CH_IN.DATA, IN2 := _GsmLib_AtReplySYSSTART) > 0 THEN
 LDX  CH_IN
 ADD  4  ; + offset 
#debug string CH_IN.DATA
 LEA  _GsmLib_AtReplySYSSTART
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_L42
#srcline 218 ;          State := ggso_Init;
 LD   udint 0  ; TGSMGateStateOut#ggso_Init
 WRX  State
#debug_left usint State
#srcline 219 ;          MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 220 ;        END_IF;
SMS_HANDLER_L42:
 JMP  SMS_HANDLER_L32
SMS_HANDLER_L41:
 LD   3
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_L44
#srcline 221 ;      ggso_Pin:
#srcline 222 ;        WaitTime.PT := Pause3;
 LD   time 2000
 WRX  WaitTime~PT
#debug_left time WaitTime.PT
#srcline 223 ;        IF FIND(IN1 := CH_IN.DATA, IN2 := _GsmLib_AtReplyCPIN) > 0 THEN
 LDX  CH_IN
 ADD  4  ; + offset 
#debug string CH_IN.DATA
 LEA  _GsmLib_AtReplyCPIN
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_L45
#srcline 224 ;          ReadErrs := 0;
 LD   usint 0
 WRX  ReadErrs
#debug_left usint ReadErrs
#srcline 225 ;          IF FIND(IN1 := CH_IN.DATA, IN2 := _GsmLib_AtReplyREADY) > 0 THEN //PIN code is not required
 LDX  CH_IN
 ADD  4  ; + offset 
#debug string CH_IN.DATA
 LEA  _GsmLib_AtReplyREADY
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_L47
#srcline 226 ;            State := ggso_Conf2;
 LD   udint 6  ; TGSMGateStateOut#ggso_Conf2
 WRX  State
#debug_left usint State
#srcline 227 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 228 ;          END_IF;
SMS_HANDLER_L47:
#srcline 229 ;          IF FIND(IN1 := CH_IN.DATA, IN2 := _GsmLib_AtReplySIMPIN) > 0 THEN //PIN code is required
 LDX  CH_IN
 ADD  4  ; + offset 
#debug string CH_IN.DATA
 LEA  _GsmLib_AtReplySIMPIN
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_L49
#srcline 230 ;            State := ggso_PinValue;
 LD   udint 4  ; TGSMGateStateOut#ggso_PinValue
 WRX  State
#debug_left usint State
#srcline 231 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 232 ;          END_IF;
SMS_HANDLER_L49:
#srcline 233 ;          IF NOT MessOut THEN
 LDX  MessOut
#debug bool MessOut
 NEG
 JMC  SMS_HANDLER_L51
#srcline 234 ;            State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 235 ;            Error := gger_Pin_Error;
 LD   udint 2  ; TGSMGateError#gger_Pin_Error
 WRX  Error
#debug_left usint Error
#srcline 236 ;          END_IF;
SMS_HANDLER_L51:
#srcline 237 ;          IF FIND(IN1 := CH_IN.DATA, IN2 := _GsmLib_AtReplySIMPUK) > 0 THEN //PUK code is required => error
 LDX  CH_IN
 ADD  4  ; + offset 
#debug string CH_IN.DATA
 LEA  _GsmLib_AtReplySIMPUK
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_L53
#srcline 238 ;            State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 239 ;            Error := gger_Puk_Required;
 LD   udint 3  ; TGSMGateError#gger_Puk_Required
 WRX  Error
#debug_left usint Error
#srcline 240 ;            HardErr := true;
 LD   bool -1       ; true
 WRX  HardErr
#debug_left bool HardErr
#srcline 241 ;          END_IF;
SMS_HANDLER_L53:
#srcline 242 ;        ELSE
 JMP  SMS_HANDLER_L46
SMS_HANDLER_L45:
#srcline 243 ;          ReadErrs := ReadErrs + 1;
 LDX  ReadErrs
#debug usint ReadErrs
 LD   usint 1
 ADD
 AND  $FF
 WRX  ReadErrs
#debug_left usint ReadErrs
#srcline 244 ;          IF ReadErrs > 1 THEN
 LDX  ReadErrs
#debug usint ReadErrs
 LD   usint 1
 GT
 JMC  SMS_HANDLER_L55
#srcline 245 ;            State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 246 ;            Error := gger_Pin_Error;
 LD   udint 2  ; TGSMGateError#gger_Pin_Error
 WRX  Error
#debug_left usint Error
#srcline 247 ;          ELSE
 JMP  SMS_HANDLER_L56
SMS_HANDLER_L55:
#srcline 248 ;            State := ggso_Pin;
 LD   udint 3  ; TGSMGateStateOut#ggso_Pin
 WRX  State
#debug_left usint State
#srcline 249 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 250 ;          END_IF;
SMS_HANDLER_L56:
#srcline 251 ;        END_IF;
SMS_HANDLER_L46:
 JMP  SMS_HANDLER_L32
SMS_HANDLER_L44:
 LD   4
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_L57
#srcline 252 ;      ggso_PinValue:
#srcline 253 ;        WaitTime.PT := Pause5; //timeout after PIN set
 LD   time 3000
 WRX  WaitTime~PT
#debug_left time WaitTime.PT
#srcline 254 ;        IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_L58
#srcline 255 ;          State := ggso_Conf2;
 LD   udint 6  ; TGSMGateStateOut#ggso_Conf2
 WRX  State
#debug_left usint State
#srcline 256 ;          MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 257 ;        ELSE
 JMP  SMS_HANDLER_L59
SMS_HANDLER_L58:
#srcline 258 ;          State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 259 ;          Error := gger_Pin_Error;
 LD   udint 2  ; TGSMGateError#gger_Pin_Error
 WRX  Error
#debug_left usint Error
#srcline 260 ;          HardErr := true;
 LD   bool -1       ; true
 WRX  HardErr
#debug_left bool HardErr
#srcline 261 ;        END_IF;
SMS_HANDLER_L59:
 JMP  SMS_HANDLER_L32
SMS_HANDLER_L57:
 LD   5
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_L60
#srcline 262 ;      ggso_Conf1:
#srcline 263 ;        WaitTime.PT := Pause1;
 LD   time 500
 WRX  WaitTime~PT
#debug_left time WaitTime.PT
#srcline 264 ;        IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_L61
#srcline 265 ;          State := ggso_Pin;
 LD   udint 3  ; TGSMGateStateOut#ggso_Pin
 WRX  State
#debug_left usint State
#srcline 266 ;          MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 267 ;        ELSE
 JMP  SMS_HANDLER_L62
SMS_HANDLER_L61:
#srcline 268 ;          State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 269 ;          Error := gger_Cfg_Error;
 LD   udint 4  ; TGSMGateError#gger_Cfg_Error
 WRX  Error
#debug_left usint Error
#srcline 270 ;        END_IF;
SMS_HANDLER_L62:
 JMP  SMS_HANDLER_L32
SMS_HANDLER_L60:
 LD   6
 LDY  P1__st__
 EQ   
 JMD  SMS_HANDLER_L63
 LD   7
 LDY  P1__st__
 EQ   
 JMD  SMS_HANDLER_L63
 LD   9
 LDY  P1__st__
 EQ   
 JMC  SMS_HANDLER_L64
SMS_HANDLER_L63:
#srcline 271 ;      ggso_Conf2, ggso_Conf3,ggso_Conf5:
#srcline 272 ;        WaitTime.PT := Pause1;
 LD   time 500
 WRX  WaitTime~PT
#debug_left time WaitTime.PT
#srcline 273 ;        IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_L65
#srcline 274 ;          pusint := ADR(State);
 LEAX State
#debug pointer State
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 275 ;          pusint^ := pusint^ + 1;
 LEAY pusint
 LDIL    ; dereference 
 LDI  
#debug usint pusint^
 LD   usint 1
 ADD
 AND  $FF
 LEAY pusint
 LDIL    ; dereference 
 WRI 
#debug_left usint pusint^
#srcline 276 ;          MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 277 ;        ELSE
 JMP  SMS_HANDLER_L66
SMS_HANDLER_L65:
#srcline 278 ;          State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 279 ;          Error := gger_Cfg_Error;
 LD   udint 4  ; TGSMGateError#gger_Cfg_Error
 WRX  Error
#debug_left usint Error
#srcline 280 ;        END_IF;
SMS_HANDLER_L66:
 JMP  SMS_HANDLER_L32
SMS_HANDLER_L64:
 LD   8
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_L67
#srcline 281 ;      ggso_Conf4:
#srcline 282 ;        NeedErase := true;
 LD   bool -1       ; true
 WRX  NeedErase
#debug_left bool NeedErase
#srcline 283 ;        IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_L68
#srcline 284 ;          pos := FIND(IN1 := CH_IN.DATA, IN2 := _GsmLib_ColonString);
 LDX  CH_IN
 ADD  4  ; + offset 
#debug string CH_IN.DATA
 LEA  _GsmLib_ColonString
 SFND 
 WRY  pos
#debug_left int pos
#srcline 285 ;          IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_L70
#srcline 286 ;            pstring := ADR(CH_IN.DATA) + INT_TO_UDINT(pos);
 LDX  CH_IN
 ADD  4  ; + offset 
#debug pointer CH_IN.DATA
 LDY  pos
#debug int pos
 EXTW 
 ADD
 LEAY pstring
 WRIL 
#debug_left pointer pstring
#srcline 287 ;            NeedErase := STRING_TO_USINT(pstring^) <> 0;
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 SCNV $3008;  IEC_STRING _TO_ IEC_USINT
 LD   usint 0
 EQ
 NEG
 WRX  NeedErase
#debug_left bool NeedErase
#srcline 288 ;          END_IF;
SMS_HANDLER_L70:
#srcline 289 ;          pos := FIND(IN1 := CH_IN.DATA, IN2 := _GsmLib_CommaString);
 LDX  CH_IN
 ADD  4  ; + offset 
#debug string CH_IN.DATA
 LEA  _GsmLib_CommaString
 SFND 
 WRY  pos
#debug_left int pos
#srcline 290 ;          IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_L72
#srcline 291 ;            pstring := ADR(CH_IN.DATA) + INT_TO_UDINT(pos);
 LDX  CH_IN
 ADD  4  ; + offset 
#debug pointer CH_IN.DATA
 LDY  pos
#debug int pos
 EXTW 
 ADD
 LEAY pstring
 WRIL 
#debug_left pointer pstring
#srcline 292 ;            MessagesCnt := STRING_TO_USINT(pstring^);
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 SCNV $3008;  IEC_STRING _TO_ IEC_USINT
 WRX  MessagesCnt
#debug_left usint MessagesCnt
#srcline 293 ;          ELSE
 JMP  SMS_HANDLER_L73
SMS_HANDLER_L72:
#srcline 294 ;            MessagesCnt := 10;
 LD   usint 10
 WRX  MessagesCnt
#debug_left usint MessagesCnt
#srcline 295 ;          END_IF;
SMS_HANDLER_L73:
#srcline 296 ;          State := ggso_Conf5; //ggso_Center; //MC35
 LD   udint 9  ; TGSMGateStateOut#ggso_Conf5
 WRX  State
#debug_left usint State
#srcline 297 ;          MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 298 ;        ELSE
 JMP  SMS_HANDLER_L69
SMS_HANDLER_L68:
#srcline 299 ;          State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 300 ;          Error := gger_Cfg_Error;
 LD   udint 4  ; TGSMGateError#gger_Cfg_Error
 WRX  Error
#debug_left usint Error
#srcline 301 ;        END_IF;
SMS_HANDLER_L69:
 JMP  SMS_HANDLER_L32
SMS_HANDLER_L67:
 LD   26
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_L74
#srcline 302 ;      ggso_Conf6:
#srcline 303 ;        IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_L75
#srcline 304 ;          pusint := ADR(State);
 LEAX State
#debug pointer State
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 305 ;          State := ggso_Conf1;
 LD   udint 5  ; TGSMGateStateOut#ggso_Conf1
 WRX  State
#debug_left usint State
#srcline 306 ;          MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 307 ;        ELSE
 JMP  SMS_HANDLER_L76
SMS_HANDLER_L75:
#srcline 308 ;          State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 309 ;          Error := gger_Cfg_Error;
 LD   udint 4  ; TGSMGateError#gger_Cfg_Error
 WRX  Error
#debug_left usint Error
#srcline 310 ;        END_IF;
SMS_HANDLER_L76:
 JMP  SMS_HANDLER_L32
SMS_HANDLER_L74:
 LD   10
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_L77
#srcline 311 ;      ggso_Center:
#srcline 312 ;        IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_L78
#srcline 313 ;          State := ggso_EraseQuery;
 LD   udint 11  ; TGSMGateStateOut#ggso_EraseQuery
 WRX  State
#debug_left usint State
#srcline 314 ;          MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 315 ;        ELSE
 JMP  SMS_HANDLER_L79
SMS_HANDLER_L78:
#srcline 316 ;          State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 317 ;          Error := gger_SMS_Center_Error;
 LD   udint 6  ; TGSMGateError#gger_SMS_Center_Error
 WRX  Error
#debug_left usint Error
#srcline 318 ;        END_IF;
SMS_HANDLER_L79:
 JMP  SMS_HANDLER_L32
SMS_HANDLER_L77:
 LD   12
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_L80
#srcline 319 ;      ggso_Erase:
#srcline 320 ;        IF Counter < MessagesCnt THEN
 LDX  Counter
#debug usint Counter
 LDX  MessagesCnt
#debug usint MessagesCnt
 LT
 JMC  SMS_HANDLER_L81
#srcline 321 ;          IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_L83
#srcline 322 ;            Counter := Counter+1;
 LDX  Counter
#debug usint Counter
 LD   usint 1
 ADD
 AND  $FF
 WRX  Counter
#debug_left usint Counter
#srcline 323 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 324 ;          ELSE
 JMP  SMS_HANDLER_L84
SMS_HANDLER_L83:
#srcline 325 ;            State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 326 ;            Error := gger_Erase_Failed;
 LD   udint 5  ; TGSMGateError#gger_Erase_Failed
 WRX  Error
#debug_left usint Error
#srcline 327 ;          END_IF;
SMS_HANDLER_L84:
#srcline 328 ;        ELSE
 JMP  SMS_HANDLER_L82
SMS_HANDLER_L81:
#srcline 329 ;          State := ggso_SignalQ;
 LD   udint 20  ; TGSMGateStateOut#ggso_SignalQ
 WRX  State
#debug_left usint State
#srcline 330 ;          MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 331 ;//          State := ggso_ReadQuery;
#srcline 332 ;        END_IF;
SMS_HANDLER_L82:
 JMP  SMS_HANDLER_L32
SMS_HANDLER_L80:
 LD   13
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_L85
#srcline 333 ;      ggso_EraseOne:
#srcline 334 ;        IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_L86
#srcline 335 ;          Counter := Counter+1;
 LDX  Counter
#debug usint Counter
 LD   usint 1
 ADD
 AND  $FF
 WRX  Counter
#debug_left usint Counter
#srcline 336 ;          IF SendPending THEN
 LDX  SendPending
#debug bool SendPending
 JMC  SMS_HANDLER_L88
#srcline 337 ;            State := ggso_Send;
 LD   udint 18  ; TGSMGateStateOut#ggso_Send
 WRX  State
#debug_left usint State
#srcline 338 ;          ELSIF UssdPending THEN
 JMP  SMS_HANDLER_L89
SMS_HANDLER_L88:
 LDX  UssdPending
#debug bool UssdPending
 JMC  SMS_HANDLER_L90
#srcline 339 ;            State := ggso_Ussd;
 LD   udint 19  ; TGSMGateStateOut#ggso_Ussd
 WRX  State
#debug_left usint State
#srcline 340 ;          ELSE
 JMP  SMS_HANDLER_L89
SMS_HANDLER_L90:
#srcline 341 ;            State := ggso_Read;
 LD   udint 15  ; TGSMGateStateOut#ggso_Read
 WRX  State
#debug_left usint State
#srcline 342 ;          END_IF;
SMS_HANDLER_L89:
#srcline 343 ;          MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 344 ;        ELSE
 JMP  SMS_HANDLER_L87
SMS_HANDLER_L86:
#srcline 345 ;          State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 346 ;          Error := gger_Erase_Failed;
 LD   udint 5  ; TGSMGateError#gger_Erase_Failed
 WRX  Error
#debug_left usint Error
#srcline 347 ;        END_IF;
SMS_HANDLER_L87:
 JMP  SMS_HANDLER_L32
SMS_HANDLER_L85:
 LD   18
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_L91
#srcline 348 ;      ggso_Send:
#srcline 349 ;        IF FIND(IN1 := CH_IN.DATA, IN2 := _GsmLib_GreaterThanString) > 0 THEN
 LDX  CH_IN
 ADD  4  ; + offset 
#debug string CH_IN.DATA
 LEA  _GsmLib_GreaterThanString
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_L92
#srcline 350 ;          State := ggso_SendText;
 LD   udint 17  ; TGSMGateStateOut#ggso_SendText
 WRX  State
#debug_left usint State
#srcline 351 ;          MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 352 ;        ELSE
 JMP  SMS_HANDLER_L93
SMS_HANDLER_L92:
#srcline 353 ;          State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 354 ;          Error := gger_Sending_failed;
 LD   udint 9  ; TGSMGateError#gger_Sending_failed
 WRX  Error
#debug_left usint Error
#srcline 355 ;        END_IF;
SMS_HANDLER_L93:
 JMP  SMS_HANDLER_L32
SMS_HANDLER_L91:
 LD   17
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_L94
#srcline 356 ;      ggso_SendText:
#srcline 357 ;        IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_L95
#srcline 358 ;          SendPending := 0;
 LD   bool 0       ; false
 WRX  SendPending
#debug_left bool SendPending
#srcline 359 ;          State := ggso_SignalQ;
 LD   udint 20  ; TGSMGateStateOut#ggso_SignalQ
 WRX  State
#debug_left usint State
#srcline 360 ;          MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 361 ;        ELSE
 JMP  SMS_HANDLER_L96
SMS_HANDLER_L95:
#srcline 362 ;          State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 363 ;          Error := gger_Sending_failed;
 LD   udint 9  ; TGSMGateError#gger_Sending_failed
 WRX  Error
#debug_left usint Error
#srcline 364 ;        END_IF;
SMS_HANDLER_L96:
 JMP  SMS_HANDLER_L32
SMS_HANDLER_L94:
 LD   19
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_L97
#srcline 365 ;      ggso_Ussd:
#srcline 366 ;        pos := FIND(IN1 := CH_IN.DATA, IN2 := _GsmLib_OkString);
 LDX  CH_IN
 ADD  4  ; + offset 
#debug string CH_IN.DATA
 LEA  _GsmLib_OkString
 SFND 
 WRY  pos
#debug_left int pos
#srcline 367 ;        IF pos > 3 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 3
 GTS
 JMC  SMS_HANDLER_L98
#srcline 368 ;          pstring := ADR(CH_IN.DATA) + 2; //skip $r$n
 LDX  CH_IN
 ADD  4  ; + offset 
#debug pointer CH_IN.DATA
 LD   udint 2
 ADD
 LEAY pstring
 WRIL 
#debug_left pointer pstring
#srcline 369 ;          RecvMess  := LEFT(IN := pstring^, L :=  pos-3);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   160
 DST    ; Level 1
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 LDY  pos
#debug int pos
 EXTW 
 LD   int 3
 SUB
 EXTW
 SLFT 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  RecvMess
 WRI  
 LDX  RecvMess
 LD   160
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string RecvMess
 PDST   ; Level 1
#srcline 370 ;          NewMess   := true;
 LD   bool -1       ; true
 WRX  NewMess
#debug_left bool NewMess
#srcline 371 ;          RecvTime  := LREAL_TO_DATE_AND_TIME(0.0) ;
 LDQ  lreal 0.0
 WRX  RecvTime
#debug_left dt RecvTime
#srcline 372 ;          Sender    := l_USSD;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   20
 DST    ; Level 1
 LEAX l_USSD
#debug string l_USSD
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  Sender
 WRI  
 LDX  Sender
 LD   20
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string Sender
 PDST   ; Level 1
#srcline 373 ;          State     := ggso_SignalQ;
 LD   udint 20  ; TGSMGateStateOut#ggso_SignalQ
 WRX  State
#debug_left usint State
#srcline 374 ;          MessOut   := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 375 ;          UssdPending := false;
 LD   bool 0       ; false
 WRX  UssdPending
#debug_left bool UssdPending
#srcline 376 ;        ELSIF FIND(IN1 := CH_IN.DATA, IN2 := _GsmLib_AtReplyCUSD) > 0 THEN
 JMP  SMS_HANDLER_L99
SMS_HANDLER_L98:
 LDX  CH_IN
 ADD  4  ; + offset 
#debug string CH_IN.DATA
 LEA  _GsmLib_AtReplyCUSD
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_L100
#srcline 377 ;          pos := FIND(IN1 := CH_IN.DATA, IN2 := _GsmLib_QuoteString);
 LDX  CH_IN
 ADD  4  ; + offset 
#debug string CH_IN.DATA
 LEA  _GsmLib_QuoteString
 SFND 
 WRY  pos
#debug_left int pos
#srcline 378 ;          IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_L101
#srcline 379 ;            pstring := ADR(CH_IN.DATA) + INT_TO_UDINT(pos);
 LDX  CH_IN
 ADD  4  ; + offset 
#debug pointer CH_IN.DATA
 LDY  pos
#debug int pos
 EXTW 
 ADD
 LEAY pstring
 WRIL 
#debug_left pointer pstring
#srcline 380 ;            pos := FIND(IN1 := pstring^, IN2 := _GsmLib_QuoteString);
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 LEA  _GsmLib_QuoteString
 SFND 
 WRY  pos
#debug_left int pos
#srcline 381 ;            IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_L103
#srcline 382 ;              RecvMess  := LEFT(IN := pstring^, L := pos-1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   160
 DST    ; Level 1
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 LDY  pos
#debug int pos
 EXTW 
 LD   int 1
 SUB
 EXTW
 SLFT 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  RecvMess
 WRI  
 LDX  RecvMess
 LD   160
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string RecvMess
 PDST   ; Level 1
#srcline 383 ;              NewMess   := true;
 LD   bool -1       ; true
 WRX  NewMess
#debug_left bool NewMess
#srcline 384 ;              RecvTime := LREAL_TO_DATE_AND_TIME(0.0) ;
 LDQ  lreal 0.0
 WRX  RecvTime
#debug_left dt RecvTime
#srcline 385 ;              Sender   := l_USSD;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   20
 DST    ; Level 1
 LEAX l_USSD
#debug string l_USSD
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  Sender
 WRI  
 LDX  Sender
 LD   20
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string Sender
 PDST   ; Level 1
#srcline 386 ;              State    := ggso_SignalQ;
 LD   udint 20  ; TGSMGateStateOut#ggso_SignalQ
 WRX  State
#debug_left usint State
#srcline 387 ;              MessOut  := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 388 ;              UssdPending := false;
 LD   bool 0       ; false
 WRX  UssdPending
#debug_left bool UssdPending
#srcline 389 ;            END_IF;
SMS_HANDLER_L103:
#srcline 390 ;          END_IF;
SMS_HANDLER_L101:
#srcline 391 ;        ELSIF not ok THEN
 JMP  SMS_HANDLER_L99
SMS_HANDLER_L100:
 LDX  ok
#debug bool ok
 NEG
 JMC  SMS_HANDLER_L105
#srcline 392 ;          State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 393 ;          Error := gger_USSD_Not_Executed;
 LD   udint 19  ; TGSMGateError#gger_USSD_Not_Executed
 WRX  Error
#debug_left usint Error
#srcline 394 ;        END_IF;
 JMP  SMS_HANDLER_L99
SMS_HANDLER_L105:
SMS_HANDLER_L99:
 JMP  SMS_HANDLER_L32
SMS_HANDLER_L97:
 LD   15
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_L106
#srcline 395 ;      ggso_Read:
#srcline 396 ;        IF Counter < MessagesCnt THEN
 LDX  Counter
#debug usint Counter
 LDX  MessagesCnt
#debug usint MessagesCnt
 LT
 JMC  SMS_HANDLER_L107
#srcline 397 ;          IF FIND(IN1 := CH_IN.DATA, IN2 := _GsmLib_AtReplyCMGR) > 0 THEN
 LDX  CH_IN
 ADD  4  ; + offset 
#debug string CH_IN.DATA
 LEA  _GsmLib_AtReplyCMGR
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_L109
#srcline 398 ;            InitDone := true;
 LD   bool -1       ; true
 WRX  InitDone
#debug_left bool InitDone
#srcline 399 ;            ReadErrs := 0;
 LD   usint 0
 WRX  ReadErrs
#debug_left usint ReadErrs
#srcline 400 ;            MaxReadErrs := 2;
 LD   usint 2
 WRX  MaxReadErrs
#debug_left usint MaxReadErrs
#srcline 401 ;            pos := FIND(IN1 := CH_IN.DATA, IN2 := _GsmLib_QuoteString);
 LDX  CH_IN
 ADD  4  ; + offset 
#debug string CH_IN.DATA
 LEA  _GsmLib_QuoteString
 SFND 
 WRY  pos
#debug_left int pos
#srcline 402 ;            IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_L111
#srcline 403 ;              //Stop := true;
#srcline 404 ;              pstring := ADR(CH_IN.DATA) + INT_TO_UDINT(pos);
 LDX  CH_IN
 ADD  4  ; + offset 
#debug pointer CH_IN.DATA
 LDY  pos
#debug int pos
 EXTW 
 ADD
 LEAY pstring
 WRIL 
#debug_left pointer pstring
#srcline 405 ;              pos := FIND(IN1 := pstring^, IN2 := _GsmLib_QuoteString);
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 LEA  _GsmLib_QuoteString
 SFND 
 WRY  pos
#debug_left int pos
#srcline 406 ;              IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_L113
#srcline 407 ;                pstring := pstring + INT_TO_UDINT(pos);
 LEAY pstring
 LDIL 
#debug pointer pstring
 LDY  pos
#debug int pos
 EXTW 
 ADD
 LEAY pstring
 WRIL 
#debug_left pointer pstring
#srcline 408 ;                pos := FIND(IN1 := pstring^, IN2 := _GsmLib_QuoteString);
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 LEA  _GsmLib_QuoteString
 SFND 
 WRY  pos
#debug_left int pos
#srcline 409 ;                IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_L115
#srcline 410 ;                  pstring := pstring + INT_TO_UDINT(pos);
 LEAY pstring
 LDIL 
#debug pointer pstring
 LDY  pos
#debug int pos
 EXTW 
 ADD
 LEAY pstring
 WRIL 
#debug_left pointer pstring
#srcline 411 ;                  pos := FIND(IN1 := pstring^, IN2 := _GsmLib_QuoteString);
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 LEA  _GsmLib_QuoteString
 SFND 
 WRY  pos
#debug_left int pos
#srcline 412 ;                  IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_L117
#srcline 413 ;                    Sender := LEFT(IN := pstring^, L := pos-1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   20
 DST    ; Level 1
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 LDY  pos
#debug int pos
 EXTW 
 LD   int 1
 SUB
 EXTW
 SLFT 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  Sender
 WRI  
 LDX  Sender
 LD   20
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string Sender
 PDST   ; Level 1
#srcline 414 ;                    pstring := pstring + INT_TO_UDINT(pos);
 LEAY pstring
 LDIL 
#debug pointer pstring
 LDY  pos
#debug int pos
 EXTW 
 ADD
 LEAY pstring
 WRIL 
#debug_left pointer pstring
#srcline 415 ;                    pos := FIND(IN1 := pstring^, IN2 := _GsmLib_QuoteString);
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 LEA  _GsmLib_QuoteString
 SFND 
 WRY  pos
#debug_left int pos
#srcline 416 ;                    IF pos > 0  THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_L119
#srcline 417 ;                      pstring := pstring + INT_TO_UDINT(pos);
 LEAY pstring
 LDIL 
#debug pointer pstring
 LDY  pos
#debug int pos
 EXTW 
 ADD
 LEAY pstring
 WRIL 
#debug_left pointer pstring
#srcline 418 ;                      HelpString := CONCAT('DT#20',pstring^);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEA  _str_SMS_HANDLER_0
 SCON
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX HelpString
 WRI  
 LEAX HelpString
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string HelpString
 PDST   ; Level 1
#srcline 419 ;                      pos := FIND(IN1 := pstring^, IN2 := _GsmLib_QuoteString);
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 LEA  _GsmLib_QuoteString
 SFND 
 WRY  pos
#debug_left int pos
#srcline 420 ;                      IF pos > 0  THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_L121
#srcline 421 ;                        pusint := ADR(HelpString) + 7;
 LEAX HelpString
#debug pointer HelpString
 LD   udint 7
 ADD
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 422 ;                        pusint^ := 16#2D;
 LD   usint $2D
 LEAY pusint
 LDIL    ; dereference 
 WRI 
#debug_left usint pusint^
#srcline 423 ;                        pusint := pusint + 3;
 LEAY pusint
 LDIL 
#debug pointer pusint
 LD   udint 3
 ADD
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 424 ;                        pusint^ := 16#2D;
 LD   usint $2D
 LEAY pusint
 LDIL    ; dereference 
 WRI 
#debug_left usint pusint^
#srcline 425 ;                        pusint := pusint + 3;
 LEAY pusint
 LDIL 
#debug pointer pusint
 LD   udint 3
 ADD
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 426 ;                        pusint^ := 16#2D;
 LD   usint $2D
 LEAY pusint
 LDIL    ; dereference 
 WRI 
#debug_left usint pusint^
#srcline 427 ;                        pusint := pusint + 9;
 LEAY pusint
 LDIL 
#debug pointer pusint
 LD   udint 9
 ADD
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 428 ;                        pusint^ := 0;
 LD   usint 0
 LEAY pusint
 LDIL    ; dereference 
 WRI 
#debug_left usint pusint^
#srcline 429 ;                        RecvTime := STRING_TO_DATE_AND_TIME(HelpString);
 LEAX HelpString
#debug string HelpString
 SCNV $3032;  IEC_STRING _TO_ IEC_DT
 WRX  RecvTime
#debug_left dt RecvTime
#srcline 430 ;                        pos := FIND(IN1 := pstring^, IN2 := _GsmLib_CrLfString);
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 LEA  _GsmLib_CrLfString
 SFND 
 WRY  pos
#debug_left int pos
#srcline 431 ;                        IF pos > 0  THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_L123
#srcline 432 ;                          pstring := pstring + INT_TO_UDINT(pos+1);
 LEAY pstring
 LDIL 
#debug pointer pstring
 LDY  pos
#debug int pos
 EXTW 
 LD   int 1
 ADD
 EXTW
 ADD
 LEAY pstring
 WRIL 
#debug_left pointer pstring
#srcline 433 ;                          pos := FIND(IN1 := pstring^, IN2 := _GsmLib_CrLfString);
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 LEA  _GsmLib_CrLfString
 SFND 
 WRY  pos
#debug_left int pos
#srcline 434 ;                          IF pos > 0  THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_L125
#srcline 435 ;                            RecvMess := LEFT(IN := pstring^, L := pos-1); //pos+1 was not right, it returns /r/n
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   160
 DST    ; Level 1
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 LDY  pos
#debug int pos
 EXTW 
 LD   int 1
 SUB
 EXTW
 SLFT 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  RecvMess
 WRI  
 LDX  RecvMess
 LD   160
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string RecvMess
 PDST   ; Level 1
#srcline 436 ;                            NewMess := true;
 LD   bool -1       ; true
 WRX  NewMess
#debug_left bool NewMess
#srcline 437 ;                            State := ggso_EraseOne;
 LD   udint 13  ; TGSMGateStateOut#ggso_EraseOne
 WRX  State
#debug_left usint State
#srcline 438 ;                            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 439 ;                          ELSE
 JMP  SMS_HANDLER_L126
SMS_HANDLER_L125:
#srcline 440 ;                            RecvMess := pstring^;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   160
 DST    ; Level 1
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  RecvMess
 WRI  
 LDX  RecvMess
 LD   160
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string RecvMess
 PDST   ; Level 1
#srcline 441 ;                            State := ggso_ReadOk;
 LD   udint 16  ; TGSMGateStateOut#ggso_ReadOk
 WRX  State
#debug_left usint State
#srcline 442 ;                          END_IF;
SMS_HANDLER_L126:
#srcline 443 ;                        END_IF;
SMS_HANDLER_L123:
#srcline 444 ;                      END_IF;
SMS_HANDLER_L121:
#srcline 445 ;                    END_IF;
SMS_HANDLER_L119:
#srcline 446 ;                  END_IF;
SMS_HANDLER_L117:
#srcline 447 ;                END_IF;
SMS_HANDLER_L115:
#srcline 448 ;              END_IF;
SMS_HANDLER_L113:
#srcline 449 ;            ELSE //quote not found
 JMP  SMS_HANDLER_L112
SMS_HANDLER_L111:
#srcline 450 ;              IF ok THEN //read next
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_L127
#srcline 451 ;                IF SendPending THEN
 LDX  SendPending
#debug bool SendPending
 JMC  SMS_HANDLER_L129
#srcline 452 ;                  State := ggso_Send;
 LD   udint 18  ; TGSMGateStateOut#ggso_Send
 WRX  State
#debug_left usint State
#srcline 453 ;                ELSIF UssdPending THEN
 JMP  SMS_HANDLER_L130
SMS_HANDLER_L129:
 LDX  UssdPending
#debug bool UssdPending
 JMC  SMS_HANDLER_L131
#srcline 454 ;                  State := ggso_Ussd;
 LD   udint 19  ; TGSMGateStateOut#ggso_Ussd
 WRX  State
#debug_left usint State
#srcline 455 ;                ELSIF DialPending THEN
 JMP  SMS_HANDLER_L130
SMS_HANDLER_L131:
 LDX  DialPending
#debug bool DialPending
 JMC  SMS_HANDLER_L132
#srcline 456 ;                  State := ggso_Ringing;
 LD   udint 22  ; TGSMGateStateOut#ggso_Ringing
 WRX  State
#debug_left usint State
#srcline 457 ;                  TimeOut.PT := DialTime;
 LDX  DialTime
#debug time DialTime
 WRX  TimeOut~PT
#debug_left time TimeOut.PT
#srcline 458 ;                ELSE
 JMP  SMS_HANDLER_L130
SMS_HANDLER_L132:
#srcline 459 ;                  Counter := Counter + 1;
 LDX  Counter
#debug usint Counter
 LD   usint 1
 ADD
 AND  $FF
 WRX  Counter
#debug_left usint Counter
#srcline 460 ;                END_IF;
SMS_HANDLER_L130:
#srcline 461 ;                MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 462 ;              END_IF;
SMS_HANDLER_L127:
#srcline 463 ;            END_IF;
SMS_HANDLER_L112:
#srcline 464 ;          END_IF;
SMS_HANDLER_L109:
#srcline 465 ;          IF FIND(IN1 := CH_IN.DATA, IN2 := _GsmLib_AtReplyERROR) > 0 THEN
 LDX  CH_IN
 ADD  4  ; + offset 
#debug string CH_IN.DATA
 LEA  _GsmLib_AtReplyERROR
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_L133
#srcline 466 ;            ReadErrs := ReadErrs + 1;
 LDX  ReadErrs
#debug usint ReadErrs
 LD   usint 1
 ADD
 AND  $FF
 WRX  ReadErrs
#debug_left usint ReadErrs
#srcline 467 ;            IF ReadErrs < MaxReadErrs THEN
 LDX  ReadErrs
#debug usint ReadErrs
 LDX  MaxReadErrs
#debug usint MaxReadErrs
 LT
 JMC  SMS_HANDLER_L135
#srcline 468 ;              State := ggso_SignalQ;
 LD   udint 20  ; TGSMGateStateOut#ggso_SignalQ
 WRX  State
#debug_left usint State
#srcline 469 ;              MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 470 ;            END_IF;
SMS_HANDLER_L135:
#srcline 471 ;          END_IF;
SMS_HANDLER_L133:
#srcline 472 ;          IF NOT MessOut AND State <> ggso_ReadOk THEN
 LDX  MessOut
#debug bool MessOut
 NEG
 LDX  State
#debug usint State
 LD   udint 16  ; TGSMGateStateOut#ggso_ReadOk
 EQ
 NEG
 AND
 JMC  SMS_HANDLER_L137
#srcline 473 ;            State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 474 ;            Error := gger_Receiving_OK_Missing;
 LD   udint 11  ; TGSMGateError#gger_Receiving_OK_Missing
 WRX  Error
#debug_left usint Error
#srcline 475 ;          END_IF;
SMS_HANDLER_L137:
#srcline 476 ;        ELSE //all 10 memory slots read
 JMP  SMS_HANDLER_L108
SMS_HANDLER_L107:
#srcline 477 ;          State := ggso_SignalQ;
 LD   udint 20  ; TGSMGateStateOut#ggso_SignalQ
 WRX  State
#debug_left usint State
#srcline 478 ;          MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 479 ;        END_IF;
SMS_HANDLER_L108:
 JMP  SMS_HANDLER_L32
SMS_HANDLER_L106:
 LD   16
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_L139
#srcline 480 ;      ggso_ReadOk:
#srcline 481 ;        IF ok THEN //read next
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_L140
#srcline 482 ;          NewMess := true;
 LD   bool -1       ; true
 WRX  NewMess
#debug_left bool NewMess
#srcline 483 ;          State := ggso_EraseOne;
 LD   udint 13  ; TGSMGateStateOut#ggso_EraseOne
 WRX  State
#debug_left usint State
#srcline 484 ;          MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 485 ;        ELSE
 JMP  SMS_HANDLER_L141
SMS_HANDLER_L140:
#srcline 486 ;          State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 487 ;          Error := gger_Receiving_failed;
 LD   udint 10  ; TGSMGateError#gger_Receiving_failed
 WRX  Error
#debug_left usint Error
#srcline 488 ;        END_IF;
SMS_HANDLER_L141:
 JMP  SMS_HANDLER_L32
SMS_HANDLER_L139:
 LD   20
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_L142
#srcline 489 ;      ggso_SignalQ:
#srcline 490 ;        pos := FIND(IN1 := CH_IN.DATA, IN2 := _GsmLib_AtReplyCSQ);
 LDX  CH_IN
 ADD  4  ; + offset 
#debug string CH_IN.DATA
 LEA  _GsmLib_AtReplyCSQ
 SFND 
 WRY  pos
#debug_left int pos
#srcline 491 ;        IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_L143
#srcline 492 ;          pstring := ADR(CH_IN.DATA) + INT_TO_UDINT(pos+4);
 LDX  CH_IN
 ADD  4  ; + offset 
#debug pointer CH_IN.DATA
 LDY  pos
#debug int pos
 EXTW 
 LD   int 4
 ADD
 EXTW
 ADD
 LEAY pstring
 WRIL 
#debug_left pointer pstring
#srcline 493 ;          tusint := STRING_TO_USINT(pstring^);
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 SCNV $3008;  IEC_STRING _TO_ IEC_USINT
 WRY  tusint
#debug_left usint tusint
#srcline 494 ;          IF tusint = 99 THEN
 LDY  tusint
#debug usint tusint
 LD   usint 99
 EQ
 JMC  SMS_HANDLER_L145
#srcline 495 ;            Signal := -1;
 LD   sint -1
 WRX  Signal
#debug_left sint Signal
#srcline 496 ;          ELSE
 JMP  SMS_HANDLER_L146
SMS_HANDLER_L145:
#srcline 497 ;            Signal := UDINT_TO_SINT((USINT_TO_UDINT(tusint)*100)/31);
 LDY  tusint
#debug usint tusint
 LD   udint 100
 MUL
 LD   udint 31
 DIVL
 EXTB
 WRX  Signal
#debug_left sint Signal
#srcline 498 ;          END_IF;
SMS_HANDLER_L146:
#srcline 499 ;        END_IF;
SMS_HANDLER_L143:
#srcline 500 ;        State := ggso_ReadQuery; //and again
 LD   udint 14  ; TGSMGateStateOut#ggso_ReadQuery
 WRX  State
#debug_left usint State
 JMP  SMS_HANDLER_L32
SMS_HANDLER_L142:
 LD   21
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_L147
#srcline 501 ;      ggso_RingNumber:
#srcline 502 ;        Ring := true;
 LD   bool -1       ; true
 WRX  Ring
#debug_left bool Ring
#srcline 503 ;        IF FIND(IN1 := CH_IN.DATA, IN2 := _GsmLib_AtReplyCLCC) > 0 THEN
 LDX  CH_IN
 ADD  4  ; + offset 
#debug string CH_IN.DATA
 LEA  _GsmLib_AtReplyCLCC
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_L148
#srcline 504 ;          pos := FIND(IN1 := CH_IN.DATA, IN2 := _GsmLib_QuoteString);
 LDX  CH_IN
 ADD  4  ; + offset 
#debug string CH_IN.DATA
 LEA  _GsmLib_QuoteString
 SFND 
 WRY  pos
#debug_left int pos
#srcline 505 ;          IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_L150
#srcline 506 ;            pstring := ADR(CH_IN.DATA) + INT_TO_UDINT(pos);
 LDX  CH_IN
 ADD  4  ; + offset 
#debug pointer CH_IN.DATA
 LDY  pos
#debug int pos
 EXTW 
 ADD
 LEAY pstring
 WRIL 
#debug_left pointer pstring
#srcline 507 ;            pos := FIND(IN1 := pstring^, IN2 := _GsmLib_QuoteString);
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 LEA  _GsmLib_QuoteString
 SFND 
 WRY  pos
#debug_left int pos
#srcline 508 ;            IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_L152
#srcline 509 ;              Caller := LEFT(IN := pstring^, L := Pos-1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   20
 DST    ; Level 1
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 LDY  Pos
#debug int Pos
 EXTW 
 LD   int 1
 SUB
 EXTW
 SLFT 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  Caller
 WRI  
 LDX  Caller
 LD   20
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string Caller
 PDST   ; Level 1
#srcline 510 ;            END_IF;
SMS_HANDLER_L152:
#srcline 511 ;          END_IF;
SMS_HANDLER_L150:
#srcline 512 ;        END_IF;
SMS_HANDLER_L148:
#srcline 513 ;        WaitTime.PT := Pause5;    //timeout to cancel call
 LD   time 3000
 WRX  WaitTime~PT
#debug_left time WaitTime.PT
#srcline 514 ;        State := ggso_CancelCall; //cancel call
 LD   udint 23  ; TGSMGateStateOut#ggso_CancelCall
 WRX  State
#debug_left usint State
#srcline 515 ;        MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
 JMP  SMS_HANDLER_L32
SMS_HANDLER_L147:
 LD   22
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_L154
#srcline 516 ;      ggso_Ringing:
#srcline 517 ;        IF FIND(IN1 := CH_IN.DATA, IN2 := _GsmLib_AtReplyNOCARRIER) > 0 OR FIND(CH_IN.DATA, _GsmLib_AtReplyERROR) > 0 THEN
 LDX  CH_IN
 ADD  4  ; + offset 
#debug string CH_IN.DATA
 LEA  _GsmLib_AtReplyNOCARRIER
 SFND 
 LD   int 0
 GTS
 LDX  CH_IN
 ADD  4  ; + offset 
#debug string CH_IN.DATA
 LEA  _GsmLib_AtReplyERROR
 SFND 
 LD   int 0
 GTS
 OR  
 JMC  SMS_HANDLER_L155
#srcline 518 ;          State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 519 ;          Error := gger_Dialing_Failed;
 LD   udint 18  ; TGSMGateError#gger_Dialing_Failed
 WRX  Error
#debug_left usint Error
#srcline 520 ;        ELSIF ok THEN
 JMP  SMS_HANDLER_L156
SMS_HANDLER_L155:
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_L157
#srcline 521 ;          State := ggso_CancelCall;
 LD   udint 23  ; TGSMGateStateOut#ggso_CancelCall
 WRX  State
#debug_left usint State
#srcline 522 ;          MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 523 ;        END_IF;
 JMP  SMS_HANDLER_L156
SMS_HANDLER_L157:
SMS_HANDLER_L156:
 JMP  SMS_HANDLER_L32
SMS_HANDLER_L154:
 LD   23
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_L158
#srcline 524 ;      ggso_CancelCall:
#srcline 525 ;        State := ggso_ReadQuery; //and again
 LD   udint 14  ; TGSMGateStateOut#ggso_ReadQuery
 WRX  State
#debug_left usint State
#srcline 526 ;        DialPending := false;
 LD   bool 0       ; false
 WRX  DialPending
#debug_left bool DialPending
 JMP  SMS_HANDLER_L32
SMS_HANDLER_L158:
#srcline 527 ;    ELSE
#srcline 528 ;      pusint := ADR(CH_IN.DATA);
 LDX  CH_IN
 ADD  4  ; + offset 
#debug pointer CH_IN.DATA
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 529 ;      pusint^ := 0;
 LD   usint 0
 LEAY pusint
 LDIL    ; dereference 
 WRI 
#debug_left usint pusint^
#srcline 530 ;    END_CASE;
SMS_HANDLER_L32:
#srcline 531 ;  END_IF;
SMS_HANDLER_L24:
#srcline 533 ;  IF State = ggso_Error THEN
 LDX  State
#debug usint State
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 EQ
 JMC  SMS_HANDLER_L159
#srcline 534 ;    IF FIND(IN1 := CH_IN.DATA, IN2 := _GsmLib_AtReplyERROR) = 8 THEN
 LDX  CH_IN
 ADD  4  ; + offset 
#debug string CH_IN.DATA
 LEA  _GsmLib_AtReplyERROR
 SFND 
 LD   int 8
 EQ
 JMC  SMS_HANDLER_L161
#srcline 535 ;      pstring := ADR(CH_IN.DATA) + 7;
 LDX  CH_IN
 ADD  4  ; + offset 
#debug pointer CH_IN.DATA
 LD   udint 7
 ADD
 LEAY pstring
 WRIL 
#debug_left pointer pstring
#srcline 536 ;      RecvMess := pstring^;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   160
 DST    ; Level 1
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  RecvMess
 WRI  
 LDX  RecvMess
 LD   160
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string RecvMess
 PDST   ; Level 1
#srcline 537 ;    END_IF;
SMS_HANDLER_L161:
#srcline 538 ;  END_IF;
SMS_HANDLER_L159:
#srcline 540 ;  //transmiting
#srcline 541 ;  WaitTime(IN := MessOut); //timeout between recieve and transmit
 LDX  MessOut
#debug bool MessOut
 WRX  WaitTime~IN
#debug_left bool WaitTime~IN
 LEAX WaitTime
 CAL  TON_L0
#srcline 542 ;  IF WaitTime.Q THEN
 LDX  WaitTime~Q
#debug bool WaitTime.Q
 JMC  SMS_HANDLER_L163
#srcline 543 ;    //states
#srcline 544 ;    CASE State OF
 LDX  State
#debug usint State
 WRY  P2__st__
 LD   0
 LDY  P2__st__
 EQ  
 JMC  SMS_HANDLER_L166
#srcline 545 ;      ggso_Init :
#srcline 546 ;        WaitTime.PT := Pause1;
 LD   time 500
 WRX  WaitTime~PT
#debug_left time WaitTime.PT
#srcline 547 ;        ReadErrs := 0;
 LD   usint 0
 WRX  ReadErrs
#debug_left usint ReadErrs
#srcline 548 ;        Signal := -1;
 LD   sint -1
 WRX  Signal
#debug_left sint Signal
#srcline 549 ;        CH_OUT.DATA := _GsmLib_AtCommandATE0;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATE0
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  CH_OUT
 ADD  4  ; + offset 
 WRI  
 LDX  CH_OUT
 ADD  4  ; + offset 
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string CH_OUT.DATA
 PDST   ; Level 1
 JMP  SMS_HANDLER_L165
SMS_HANDLER_L166:
 LD   1
 LDY  P2__st__
 EQ  
 JMC  SMS_HANDLER_L167
#srcline 550 ;      ggso_BaudRate:
#srcline 551 ;        CH_OUT.DATA := _GsmLib_AtCommandATIPR;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATIPR
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  CH_OUT
 ADD  4  ; + offset 
 WRI  
 LDX  CH_OUT
 ADD  4  ; + offset 
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string CH_OUT.DATA
 PDST   ; Level 1
 JMP  SMS_HANDLER_L165
SMS_HANDLER_L167:
 LD   2
 LDY  P2__st__
 EQ  
 JMC  SMS_HANDLER_L168
#srcline 552 ;      ggso_Reset:
#srcline 553 ;        CH_OUT.DATA := _GsmLib_AtCommandATCFUN;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATCFUN
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  CH_OUT
 ADD  4  ; + offset 
 WRI  
 LDX  CH_OUT
 ADD  4  ; + offset 
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string CH_OUT.DATA
 PDST   ; Level 1
 JMP  SMS_HANDLER_L165
SMS_HANDLER_L168:
 LD   3
 LDY  P2__st__
 EQ  
 JMC  SMS_HANDLER_L169
#srcline 554 ;      ggso_Pin:
#srcline 555 ;        CH_OUT.DATA := _GsmLib_AtCommandATCPIN1;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATCPIN1
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  CH_OUT
 ADD  4  ; + offset 
 WRI  
 LDX  CH_OUT
 ADD  4  ; + offset 
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string CH_OUT.DATA
 PDST   ; Level 1
 JMP  SMS_HANDLER_L165
SMS_HANDLER_L169:
 LD   4
 LDY  P2__st__
 EQ  
 JMC  SMS_HANDLER_L170
#srcline 556 ;      ggso_PinValue:
#srcline 557 ;        IF LEN(IN := Pin) > 0 THEN
 LDX  Pin
#debug string Pin
 SLEN 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_L171
#srcline 558 ;          CH_OUT.DATA := CONCAT(_GsmLib_AtCommandATCPIN2,Pin,_GsmLib_CrLfString);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATCPIN2
 SCON
 LDX  Pin
#debug string Pin
 SCON
 LEA  _GsmLib_CrLfString

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  CH_OUT
 ADD  4  ; + offset 
 WRI  
 LDX  CH_OUT
 ADD  4  ; + offset 
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string CH_OUT.DATA
 PDST   ; Level 1
#srcline 559 ;        ELSE
 JMP  SMS_HANDLER_L172
SMS_HANDLER_L171:
#srcline 560 ;          State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 561 ;          Error := gger_No_Pin;
 LD   udint 1  ; TGSMGateError#gger_No_Pin
 WRX  Error
#debug_left usint Error
#srcline 562 ;        END_IF;
SMS_HANDLER_L172:
 JMP  SMS_HANDLER_L165
SMS_HANDLER_L170:
 LD   5
 LDY  P2__st__
 EQ  
 JMC  SMS_HANDLER_L173
#srcline 563 ;      ggso_Conf1:
#srcline 564 ;        CH_OUT.DATA := _GsmLib_AtCommandATCMEE;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATCMEE
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  CH_OUT
 ADD  4  ; + offset 
 WRI  
 LDX  CH_OUT
 ADD  4  ; + offset 
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string CH_OUT.DATA
 PDST   ; Level 1
 JMP  SMS_HANDLER_L165
SMS_HANDLER_L173:
 LD   6
 LDY  P2__st__
 EQ  
 JMC  SMS_HANDLER_L174
#srcline 565 ;      ggso_Conf2:
#srcline 566 ;        CH_OUT.DATA := _GsmLib_AtCommandATCMGF1;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATCMGF1
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  CH_OUT
 ADD  4  ; + offset 
 WRI  
 LDX  CH_OUT
 ADD  4  ; + offset 
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string CH_OUT.DATA
 PDST   ; Level 1
 JMP  SMS_HANDLER_L165
SMS_HANDLER_L174:
 LD   7
 LDY  P2__st__
 EQ  
 JMC  SMS_HANDLER_L175
#srcline 567 ;      ggso_Conf3:
#srcline 568 ;        CH_OUT.DATA := _GsmLib_AtCommandATCNMI;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATCNMI
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  CH_OUT
 ADD  4  ; + offset 
 WRI  
 LDX  CH_OUT
 ADD  4  ; + offset 
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string CH_OUT.DATA
 PDST   ; Level 1
 JMP  SMS_HANDLER_L165
SMS_HANDLER_L175:
 LD   8
 LDY  P2__st__
 EQ  
 JMC  SMS_HANDLER_L176
#srcline 569 ;      ggso_Conf4:
#srcline 570 ;        CH_OUT.DATA := _GsmLib_AtCommandATCPMS;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATCPMS
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  CH_OUT
 ADD  4  ; + offset 
 WRI  
 LDX  CH_OUT
 ADD  4  ; + offset 
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string CH_OUT.DATA
 PDST   ; Level 1
 JMP  SMS_HANDLER_L165
SMS_HANDLER_L176:
 LD   9
 LDY  P2__st__
 EQ  
 JMC  SMS_HANDLER_L177
#srcline 571 ;      ggso_Conf5:
#srcline 572 ;        CH_OUT.DATA := _GsmLib_AtCommandATSSMSS;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATSSMSS
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  CH_OUT
 ADD  4  ; + offset 
 WRI  
 LDX  CH_OUT
 ADD  4  ; + offset 
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string CH_OUT.DATA
 PDST   ; Level 1
 JMP  SMS_HANDLER_L165
SMS_HANDLER_L177:
 LD   26
 LDY  P2__st__
 EQ  
 JMC  SMS_HANDLER_L178
#srcline 573 ;      ggso_Conf6:
#srcline 574 ;        CH_OUT.DATA := _GsmLib_AtReplyATSM20_0;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _GsmLib_AtReplyATSM20_0
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  CH_OUT
 ADD  4  ; + offset 
 WRI  
 LDX  CH_OUT
 ADD  4  ; + offset 
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string CH_OUT.DATA
 PDST   ; Level 1
 JMP  SMS_HANDLER_L165
SMS_HANDLER_L178:
 LD   10
 LDY  P2__st__
 EQ  
 JMC  SMS_HANDLER_L179
#srcline 575 ;      ggso_Center:
#srcline 576 ;        IF LEN(IN := SMSCenter) > 0 THEN
 LDX  SMSCenter
#debug string SMSCenter
 SLEN 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_L180
#srcline 577 ;          CH_OUT.DATA := CONCAT(_GsmLib_AtCommandATCSCA,SMSCenter,_GsmLib_QuoteCrLfString);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATCSCA
 SCON
 LDX  SMSCenter
#debug string SMSCenter
 SCON
 LEA  _GsmLib_QuoteCrLfString

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  CH_OUT
 ADD  4  ; + offset 
 WRI  
 LDX  CH_OUT
 ADD  4  ; + offset 
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string CH_OUT.DATA
 PDST   ; Level 1
#srcline 578 ;        ELSE
 JMP  SMS_HANDLER_L181
SMS_HANDLER_L180:
#srcline 579 ;          State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 580 ;          Error := gger_No_Center_Number;
 LD   udint 7  ; TGSMGateError#gger_No_Center_Number
 WRX  Error
#debug_left usint Error
#srcline 581 ;        END_IF;
SMS_HANDLER_L181:
 JMP  SMS_HANDLER_L165
SMS_HANDLER_L179:
 LD   12
 LDY  P2__st__
 EQ  
 JMC  SMS_HANDLER_L182
#srcline 582 ;      ggso_Erase:
#srcline 583 ;        {$IFDEF DO_NOT_ERASE}
#srcline 584 ;        CH_OUT.DATA := _GsmLib_AtCommandATE0;
#srcline 585 ;        {$ELSE}
#srcline 586 ;        CH_OUT.DATA := CONCAT(_GsmLib_AtCommandATCMGD,USINT_TO_STRING(Counter),_GsmLib_CrLfString);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATCMGD
 SCON
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   255
 DST    ; Level 2
 LDX  Counter
#debug usint Counter
 SCNV $0830;  IEC_USINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]
 SCON
 LEA  _GsmLib_CrLfString

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  CH_OUT
 ADD  4  ; + offset 
 WRI  
 LDX  CH_OUT
 ADD  4  ; + offset 
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string CH_OUT.DATA
 PDST   ; Level 1
 JMP  SMS_HANDLER_L165
SMS_HANDLER_L182:
 LD   19
 LDY  P2__st__
 EQ  
 JMC  SMS_HANDLER_L183
#srcline 587 ;        {$END_IF}
#srcline 588 ;      ggso_Ussd:
#srcline 589 ;        IF LEN(IN := l_USSD) > 0 THEN
 LEAX l_USSD
#debug string l_USSD
 SLEN 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_L184
#srcline 590 ;          CH_OUT.DATA := CONCAT(_GsmLib_AtCommandATD,l_USSD,_GsmLib_SemiColonCrLfString);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATD
 SCON
 LEAX l_USSD
#debug string l_USSD
 SCON
 LEA  _GsmLib_SemiColonCrLfString

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  CH_OUT
 ADD  4  ; + offset 
 WRI  
 LDX  CH_OUT
 ADD  4  ; + offset 
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string CH_OUT.DATA
 PDST   ; Level 1
#srcline 591 ;        ELSE
 JMP  SMS_HANDLER_L185
SMS_HANDLER_L184:
#srcline 592 ;          State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 593 ;          Error := gger_No_Recipient_Number;
 LD   udint 8  ; TGSMGateError#gger_No_Recipient_Number
 WRX  Error
#debug_left usint Error
#srcline 594 ;        END_IF;
SMS_HANDLER_L185:
 JMP  SMS_HANDLER_L165
SMS_HANDLER_L183:
 LD   18
 LDY  P2__st__
 EQ  
 JMC  SMS_HANDLER_L186
#srcline 595 ;      ggso_Send:
#srcline 596 ;        IF LEN(IN := l_Recipient) > 0 THEN
 LEAX l_Recipient
#debug string l_Recipient
 SLEN 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_L187
#srcline 597 ;          CH_OUT.DATA := CONCAT(_GsmLib_AtCommandATCMGS1,l_Recipient,_GsmLib_QuoteCrLfString);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATCMGS1
 SCON
 LEAX l_Recipient
#debug string l_Recipient
 SCON
 LEA  _GsmLib_QuoteCrLfString

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  CH_OUT
 ADD  4  ; + offset 
 WRI  
 LDX  CH_OUT
 ADD  4  ; + offset 
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string CH_OUT.DATA
 PDST   ; Level 1
#srcline 598 ;        ELSE
 JMP  SMS_HANDLER_L188
SMS_HANDLER_L187:
#srcline 599 ;          State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 600 ;          Error := gger_No_Recipient_Number;
 LD   udint 8  ; TGSMGateError#gger_No_Recipient_Number
 WRX  Error
#debug_left usint Error
#srcline 601 ;        END_IF;
SMS_HANDLER_L188:
 JMP  SMS_HANDLER_L165
SMS_HANDLER_L186:
 LD   17
 LDY  P2__st__
 EQ  
 JMC  SMS_HANDLER_L189
#srcline 602 ;      ggso_SendText:
#srcline 603 ;        IF LEN(IN := l_MessToSend) > 0 THEN
 LEAX l_MessToSend
#debug string l_MessToSend
 SLEN 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_L190
#srcline 604 ;          CH_OUT.DATA := CONCAT(l_MessToSend,_GsmLib_ControlZString);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX l_MessToSend
#debug string l_MessToSend
 SCON
 LEA  _GsmLib_ControlZString

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  CH_OUT
 ADD  4  ; + offset 
 WRI  
 LDX  CH_OUT
 ADD  4  ; + offset 
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string CH_OUT.DATA
 PDST   ; Level 1
#srcline 605 ;        ELSE
 JMP  SMS_HANDLER_L191
SMS_HANDLER_L190:
#srcline 606 ;          State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 607 ;          Error := gger_Empty_Message_Text;
 LD   udint 16  ; TGSMGateError#gger_Empty_Message_Text
 WRX  Error
#debug_left usint Error
#srcline 608 ;        END_IF;
SMS_HANDLER_L191:
 JMP  SMS_HANDLER_L165
SMS_HANDLER_L189:
 LD   15
 LDY  P2__st__
 EQ  
 JMC  SMS_HANDLER_L192
#srcline 609 ;      ggso_Read:
#srcline 610 ;        CH_OUT.DATA := _GsmLib_AtCommandATCMGR+USINT_TO_STRING(Counter)+_GsmLib_CrLfString;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATCMGR
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   255
 DST    ; Level 2
 LDX  Counter
#debug usint Counter
 SCNV $0830;  IEC_USINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 LEA  _GsmLib_CrLfString
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  CH_OUT
 ADD  4  ; + offset 
 WRI  
 LDX  CH_OUT
 ADD  4  ; + offset 
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string CH_OUT.DATA
 PDST   ; Level 1
 JMP  SMS_HANDLER_L165
SMS_HANDLER_L192:
 LD   13
 LDY  P2__st__
 EQ  
 JMC  SMS_HANDLER_L193
#srcline 611 ;      ggso_EraseOne:
#srcline 612 ;        {$IFDEF DO_NOT_ERASE}
#srcline 613 ;        CH_OUT.DATA := _GsmLib_AtCommandATE0;
#srcline 614 ;        {$ELSE}
#srcline 615 ;        CH_OUT.DATA := _GsmLib_AtCommandATCMGD+USINT_TO_STRING(Counter)+_GsmLib_CrLfString;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATCMGD
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   255
 DST    ; Level 2
 LDX  Counter
#debug usint Counter
 SCNV $0830;  IEC_USINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 LEA  _GsmLib_CrLfString
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  CH_OUT
 ADD  4  ; + offset 
 WRI  
 LDX  CH_OUT
 ADD  4  ; + offset 
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string CH_OUT.DATA
 PDST   ; Level 1
 JMP  SMS_HANDLER_L165
SMS_HANDLER_L193:
 LD   20
 LDY  P2__st__
 EQ  
 JMC  SMS_HANDLER_L194
#srcline 616 ;        {$END_IF}
#srcline 617 ;      ggso_SignalQ:
#srcline 618 ;        CH_OUT.DATA := _GsmLib_AtCommandATCSQ;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATCSQ
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  CH_OUT
 ADD  4  ; + offset 
 WRI  
 LDX  CH_OUT
 ADD  4  ; + offset 
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string CH_OUT.DATA
 PDST   ; Level 1
 JMP  SMS_HANDLER_L165
SMS_HANDLER_L194:
 LD   21
 LDY  P2__st__
 EQ  
 JMC  SMS_HANDLER_L195
#srcline 619 ;      ggso_RingNumber:
#srcline 620 ;        CH_OUT.DATA := _GsmLib_AtCommandATCLCC;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATCLCC
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  CH_OUT
 ADD  4  ; + offset 
 WRI  
 LDX  CH_OUT
 ADD  4  ; + offset 
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string CH_OUT.DATA
 PDST   ; Level 1
 JMP  SMS_HANDLER_L165
SMS_HANDLER_L195:
 LD   22
 LDY  P2__st__
 EQ  
 JMC  SMS_HANDLER_L196
#srcline 621 ;      ggso_Ringing:
#srcline 622 ;        IF LEN(IN := Recipient) > 0 THEN
 LDX  Recipient
#debug string Recipient
 SLEN 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_L197
#srcline 623 ;          CH_OUT.DATA := CONCAT(_GsmLib_AtCommandATD,Recipient,_GsmLib_SemiColonCrLfString);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATD
 SCON
 LDX  Recipient
#debug string Recipient
 SCON
 LEA  _GsmLib_SemiColonCrLfString

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  CH_OUT
 ADD  4  ; + offset 
 WRI  
 LDX  CH_OUT
 ADD  4  ; + offset 
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string CH_OUT.DATA
 PDST   ; Level 1
#srcline 624 ;        ELSE
 JMP  SMS_HANDLER_L198
SMS_HANDLER_L197:
#srcline 625 ;          State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 626 ;          Error := gger_No_Recipient_Number;
 LD   udint 8  ; TGSMGateError#gger_No_Recipient_Number
 WRX  Error
#debug_left usint Error
#srcline 627 ;        END_IF;
SMS_HANDLER_L198:
 JMP  SMS_HANDLER_L165
SMS_HANDLER_L196:
 LD   23
 LDY  P2__st__
 EQ  
 JMC  SMS_HANDLER_L199
#srcline 628 ;        //Stop := true;
#srcline 629 ;      ggso_CancelCall:
#srcline 630 ;        Ring := false;
 LD   bool 0       ; false
 WRX  Ring
#debug_left bool Ring
#srcline 631 ;        CH_OUT.DATA := _GsmLib_AtCommandATH;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATH
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  CH_OUT
 ADD  4  ; + offset 
 WRI  
 LDX  CH_OUT
 ADD  4  ; + offset 
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string CH_OUT.DATA
 PDST   ; Level 1
 JMP  SMS_HANDLER_L165
SMS_HANDLER_L199:
#srcline 632 ;    ELSE
#srcline 633 ;    ;
#srcline 634 ;    END_CASE;
SMS_HANDLER_L165:
#srcline 635 ;    CH_OUT.NUM := LEN(CH_OUT.DATA);
 LDX  CH_OUT
 ADD  4  ; + offset 
#debug string CH_OUT.DATA
 SLEN 
 LDX  CH_OUT
 ADD  2  ; + offset 
 WRIW 
#debug_left uint CH_OUT.NUM
#srcline 636 ;    pusint := ADR(CH_OUT.DATA) + UINT_TO_UDINT(CH_OUT.NUM);
 LDX  CH_OUT
 ADD  4  ; + offset 
#debug pointer CH_OUT.DATA
 LDX  CH_OUT
 ADD  2  ; + offset 
 LDIW 
#debug uint CH_OUT.NUM
 ADD
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 637 ;    pusint^ := 0;
 LD   usint 0
 LEAY pusint
 LDIL    ; dereference 
 WRI 
#debug_left usint pusint^
#srcline 638 ;    IF Error = gger_None THEN
 LDX  Error
#debug usint Error
 LD   udint 0  ; TGSMGateError#gger_None
 EQ
 JMC  SMS_HANDLER_L200
#srcline 639 ;      CH_OUT.STCO.7 := NOT CH_OUT.STCO.7;  //send message to channel
 LDX  CH_OUT
 MUL  8   ; -> bool pointer 
 ADD  7   ; Bool offset 
 LDIB 
#debug bool CH_OUT.STCO.7
 NEG
 LDX  CH_OUT
 MUL  8   ; -> bool pointer 
 ADD  7   ; Bool offset 
 WRIB 
#debug_left bool CH_OUT.STCO.7
#srcline 640 ;    END_IF;
SMS_HANDLER_L200:
#srcline 641 ;    MessOut := false;                      //wait for next request
 LD   bool 0       ; false
 WRX  MessOut
#debug_left bool MessOut
#srcline 642 ;  END_IF;
SMS_HANDLER_L163:
#srcline 644 ;  //debug
#srcline 645 ;  //Stop := true;
#srcline 647 ;END_FUNCTION_BLOCK
SMS_HANDLER_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
SMS_HANDLER__InstanceInit__:
 LINK 0
 LD   time 120000
 WRX  DialTime
 LD   sint -1
 WRX  Signal
 LD   bool -1   ; true
 WRX  MessOut
 LD   bool -1   ; true
 WRX  ColdRestart
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'D:\TECOLIB\GSM_LIBRARYX2\GSMLIBCONTROL\FBRECVTOCRLF.ST'
#pou fbRecvToCrLf
#srcline 1 ;FUNCTION_BLOCK fbRecvToCrLf

#struct fbRecvToCrLf__temp__
  bool mmove,
  pointer w,
  pointer we,
  uint lendata
P     61
fbRecvToCrLf_L0:
 LINK __SizeOf(fbRecvToCrLf__temp__)
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  w
 LD   udint $FFFFFFFF    ; nil
 WRY  we
; End initialize - dynamic variables
#srcline 32 ;  IF reset THEN
 LDX  reset
#debug bool reset
 JMC  fbRecvToCrLf_L1
#srcline 33 ;    actPos := 0;
 LD   uint 0
 WRX  actPos
#debug_left uint actPos
#srcline 34 ;    lenMess := 0;
 LD   uint 0
 WRX  lenMess
#debug_left uint lenMess
#srcline 35 ;  END_IF;
fbRecvToCrLf_L1:
#srcline 37 ;  mmove := getMess AND lenMess > 0;
 LDX  getMess
#debug bool getMess
 LDX  lenMess
#debug uint lenMess
 LD   uint 0
 GT
 AND
 WRY  mmove
#debug_left bool mmove
#srcline 38 ;  IF mmove THEN
 LDY  mmove
#debug bool mmove
 JMC  fbRecvToCrLf_L3
#srcline 39 ;    (*
#srcline 40 ;    b := memmove(source := ADR(buffer) + UINT_TO_UDINT(lenMess),
#srcline 41 ;                 dest := ADR(buffer), length := UINT_TO_UDINT(actPos - lenMess));
#srcline 42 ;      actPos := actPos - lenMess;
#srcline 43 ;    *)
#srcline 44 ;    {ASM}    // copy data to tx buffer
#srcline 45
    	ldx	buffer
#srcline 46
    	ldx lenMess
#srcline 47
    	add
#srcline 48
    	src	%X0
#srcline 49
    	ldx	buffer
#srcline 50
    	ldx	actPos
#srcline 51
    	ldx lenmess
#srcline 52
    	sub
#srcline 53
    	wrx actPos
#srcline 54
    	mov	%X0
#srcline 55 ;    {END_ASM}
#srcline 56 ;    lenMess := 0;
 LD   uint 0
 WRX  lenMess
#debug_left uint lenMess
#srcline 57 ;  END_IF;
fbRecvToCrLf_L3:
#srcline 59 ;  w  := ADR(buffer);
 LDX  buffer
#debug pointer buffer
 LEAY w
 WRIL 
#debug_left pointer w
#srcline 60 ;  
#srcline 62 ;  RecvFrom.lenRx := lenBuf-actPos;
 LDX  lenBuf
#debug uint lenBuf
 LDX  actPos
#debug uint actPos
 SUB
 AND  $FFFF
 WRX  RecvFrom~lenRx
#debug_left uint RecvFrom.lenRx
#srcline 63 ;  full := RecvFrom.lenRx = 0;
 LDX  RecvFrom~lenRx
#debug uint RecvFrom.lenRx
 LD   uint 0
 EQ
 WRX  full
#debug_left bool full
#srcline 65 ;  IF NOT full THEN
 LDX  full
#debug bool full
 NEG
 JMC  fbRecvToCrLf_L5
#srcline 66 ;    {ASM}
#srcline 67
      LDX buffer
#srcline 68
      LDX actPos
#srcline 69
      ADD
#srcline 70
      WRX buffer
#srcline 71 ;    {END_ASM}
#srcline 72 ;    RecvFrom(rq := true, chanCode := chanCode, data := void(buffer), lenData => lendata);
 LD   bool -1       ; true
 WRX  RecvFrom~rq
#debug_left bool RecvFrom~rq
 LDX  chanCode
#debug uint chanCode
 WRX  RecvFrom~chanCode
#debug_left uint RecvFrom~chanCode
 LDX  buffer
 WRX  RecvFrom~data
#debug_left pointer RecvFrom.data
 LEAX RecvFrom
 CAL  fbRecvFrom_L0
; output assigment 
 LDX  RecvFrom~lenData
#debug uint RecvFrom~lenData
 WRY  lendata
#debug_left uint lendata
#srcline 73 ;    {ASM}
#srcline 74
      LDY w
#srcline 75
      WRX buffer
#srcline 76 ;    {END_ASM}
#srcline 78 ;    IF RecvFrom.mesRec THEN
 LDX  RecvFrom~mesRec
#debug bool RecvFrom.mesRec
 JMC  fbRecvToCrLf_L7
#srcline 79 ;      actPos := actPos + lendata;
 LDX  actPos
#debug uint actPos
 LDY  lendata
#debug uint lendata
 ADD
 AND  $FFFF
 WRX  actPos
#debug_left uint actPos
#srcline 80 ;    END_IF;
fbRecvToCrLf_L7:
#srcline 81 ;  END_IF;
fbRecvToCrLf_L5:
#srcline 83 ;  we := w + UINT_TO_UDINT(actPos) - 1;
 LEAY w
 LDIL 
#debug pointer w
 LDX  actPos
#debug uint actPos
 ADD
 LD   udint 1
 SUB
 LEAY we
 WRIL 
#debug_left pointer we
#srcline 84 ;  IF NOT mmove THEN
 LDY  mmove
#debug bool mmove
 NEG
 JMC  fbRecvToCrLf_L9
#srcline 85 ;    w  := we - UINT_TO_UDINT(lendata);  //search only in new data
 LEAY we
 LDIL 
#debug pointer we
 LDY  lendata
#debug uint lendata
 SUB
 LEAY w
 WRIL 
#debug_left pointer w
#srcline 86 ;    IF lendata = actPos THEN  w := w + 1; END_IF;
 LDY  lendata
#debug uint lendata
 LDX  actPos
#debug uint actPos
 EQ
 JMC  fbRecvToCrLf_L11
 LEAY w
 LDIL 
#debug pointer w
 LD   udint 1
 ADD
 LEAY w
 WRIL 
#debug_left pointer w
fbRecvToCrLf_L11:
#srcline 87 ;  END_IF;
fbRecvToCrLf_L9:
#srcline 89 ;  IF lenMess = 0 THEN
 LDX  lenMess
#debug uint lenMess
 LD   uint 0
 EQ
 JMC  fbRecvToCrLf_L13
#srcline 90 ;    WHILE PTR_TO_UDINT(w) < PTR_TO_UDINT(we) DO
fbRecvToCrLf_L15:
 LEAY w
 LDIL 
#debug pointer w
 LEAY we
 LDIL 
#debug pointer we
 LT
 JMC  fbRecvToCrLf_L16
 DBG 
#srcline 91 ;      IF (w^ = 16#0a0d) THEN
 LEAY w
 LDIL    ; dereference 
 LDIW 
#debug word w^
 LD   word $0a0d
 EQ
 JMC  fbRecvToCrLf_L17
#srcline 92 ;        lenMess := UDINT_TO_UINT(PTR_TO_UDINT(w) - PTR_TO_UDINT(ADR(buffer))) + 2;
 LEAY w
 LDIL 
#debug pointer w
 LDX  buffer
#debug pointer buffer
 SUB
 AND  $FFFF
 LD   uint 2
 ADD
 AND  $FFFF
 WRX  lenMess
#debug_left uint lenMess
#srcline 93 ;        w^ := 16#0a00;
 LD   word $0a00
 LEAY w
 LDIL    ; dereference 
 WRIW 
#debug_left word w^
#srcline 94 ;        EXIT;
 JMP  fbRecvToCrLf_L16
#srcline 95 ;      END_IF;
fbRecvToCrLf_L17:
#srcline 96 ;      w := w + 1;
 LEAY w
 LDIL 
#debug pointer w
 LD   udint 1
 ADD
 LEAY w
 WRIL 
#debug_left pointer w
#srcline 97 ;    END_WHILE;
 JMP  fbRecvToCrLf_L15
fbRecvToCrLf_L16:
#srcline 98 ;  END_IF;
fbRecvToCrLf_L13:
#srcline 100 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61

; Initialize - variables
P     61
fbRecvToCrLf__InstanceInit__:
 LINK 0
 LEAX RecvFrom
 CAL  fbRecvFrom__InstanceInit__
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'D:\TECOLIB\GSM_LIBRARYX2\GSMLIBCONTROL\SMS_HANDLER2.ST'
#pou SMS_HANDLER_2
#srcline 1 ;FUNCTION_BLOCK SMS_HANDLER_2

#struct SMS_HANDLER_2__temp__
  bool NewMessage,
  int pos,
  uint datalen,
  usint lenNum,
  byte typNum,
  byte protId,
  byte dataCode,
  byte firstOctet,
  usint lenUserHead,
  usint ChanError,
  usint tusint,
  usint indx,
  pointer pusint,
  pointer pstring,
  pointer pBuferIN,
  TUniDesc UniDesc,
  usint P0__st__,
  usint P1__st__,
  usint P2__st__,
  usint P3__st__,
  udint P4__st__,
  string[162] PS0__st__,
  string[257] PSC__st__
P     61
SMS_HANDLER_2_L0:
 LINK __SizeOf(SMS_HANDLER_2__temp__)
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  pusint
 LD   udint $FFFFFFFF    ; nil
 WRY  pstring
 LD   udint $FFFFFFFF    ; nil
 WRY  pBuferIN
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  Send
 LETX __EDGE_R__Send
 WRX  Send
 LDX  Ussd
 LETX __EDGE_R__Ussd
 WRX  Ussd
 LDX  Reset
 LETX __EDGE_R__Reset
 WRX  Reset
 LDX  Dial
 LETX __EDGE_R__Dial
 WRX  Dial
#srcline 102 ;  UniDesc := GetChanDesc(chanCode := chanCode) ;
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetChanDesc~chanCode
#debug_left uint __Instance__GetChanDesc~chanCode
 PRV
 LEA  __Instance__GetChanDesc
 CAL  GetChanDesc_L0
 LEAY UniDesc
#debug_left pointer UniDesc
 LD   26   ;SizeOf() 
 MOV  %IB0
#srcline 104 ;  IF UniDesc.modeChan <> 5 THEN
 LDY  UniDesc~modeChan
#debug byte UniDesc.modeChan
 LD   byte 5
 EQ
 NEG
 JMC  SMS_HANDLER_2_L1
#srcline 105 ;    State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 106 ;    Error := gger_Wrong_channel_mode;
 LD   udint 13  ; TGSMGateError#gger_Wrong_channel_mode
 WRX  Error
#debug_left usint Error
#srcline 107 ;    RETURN;
 JMP  SMS_HANDLER_2_RET
#srcline 108 ;  ELSE
 JMP  SMS_HANDLER_2_L2
SMS_HANDLER_2_L1:
#srcline 109 ;    IF UniDesc.lenUniIn < 380 THEN
 LDY  UniDesc~lenUniIn
#debug uint UniDesc.lenUniIn
 LD   uint 380
 LT
 JMC  SMS_HANDLER_2_L3
#srcline 110 ;      Error := gger_ZoneIn_is_short;
 LD   udint 14  ; TGSMGateError#gger_ZoneIn_is_short
 WRX  Error
#debug_left usint Error
#srcline 111 ;      RETURN;
 JMP  SMS_HANDLER_2_RET
#srcline 112 ;    END_IF;
SMS_HANDLER_2_L3:
#srcline 113 ;    IF UniDesc.lenUniOut < 360 THEN
 LDY  UniDesc~lenUniOut
#debug uint UniDesc.lenUniOut
 LD   uint 360
 LT
 JMC  SMS_HANDLER_2_L5
#srcline 114 ;      Error := gger_ZoneOut_is_short;
 LD   udint 15  ; TGSMGateError#gger_ZoneOut_is_short
 WRX  Error
#debug_left usint Error
#srcline 115 ;      RETURN;
 JMP  SMS_HANDLER_2_RET
#srcline 116 ;    END_IF;
SMS_HANDLER_2_L5:
#srcline 117 ;  END_IF;
SMS_HANDLER_2_L2:
#srcline 119 ;  NewMess := 0; //clear new SMS flag
 LD   bool 0       ; false
 WRX  NewMess
#debug_left bool NewMess
#srcline 120 ;  NewStat := 0; //clear new SMS status flag
 LD   bool 0       ; false
 WRX  NewStat
#debug_left bool NewStat
#srcline 122 ;  RecvFrom(getMess := NOT Stop, lenBuf := 512, chanCode := ChanCode, buffer := BuferIN[0],
 LDX  Stop
#debug bool Stop
 NEG
 WRX  RecvFrom~getMess
#debug_left bool RecvFrom~getMess
 LD   uint 512
 WRX  RecvFrom~lenBuf
#debug_left uint RecvFrom~lenBuf
 LDX  ChanCode
#debug uint ChanCode
 WRX  RecvFrom~chanCode
#debug_left uint RecvFrom~chanCode
 LEAX BuferIN
 WRX  RecvFrom~buffer
#debug_left pointer RecvFrom.buffer
#srcline 123 ;           reset := Reset OR TimeOut.Q);
 LDX  Reset
#debug bool Reset
 LDX  TimeOut~Q
#debug bool TimeOut.Q
 OR  
 WRX  RecvFrom~reset
#debug_left bool RecvFrom~reset
 LEAX RecvFrom
 CAL  fbRecvToCrLf_L0
#srcline 124 ;           
#srcline 125 ;  NewMessage := RecvFrom.lenMess > 2 OR BuferIN[0] = 62; //62 = '>'
 LDX  RecvFrom~lenMess
#debug uint RecvFrom.lenMess
 LD   uint 2
 GT
 LDX  BuferIN[0]
#debug usint BuferIN[0]
 LD   usint 62
 EQ
 OR  
 WRY  NewMessage
#debug_left bool NewMessage
#srcline 127 ;  IF Stop THEN return; END_IF;
 LDX  Stop
#debug bool Stop
 JMC  SMS_HANDLER_2_L7
 JMP  SMS_HANDLER_2_RET
SMS_HANDLER_2_L7:
#srcline 129 ;  (* //debug
#srcline 130 ;  IF WaitTime.Q THEN
#srcline 131 ;    pusint := ADR(TextIn);
#srcline 132 ;    pusint^ := 0;
#srcline 133 ;  END_IF;
#srcline 134 ;  IF NewMessage THEN
#srcline 136 ;    pusint := ADR(TextIn) + UINT_TO_UDINT(datalen);
#srcline 137 ;    pusint^ := 0;
#srcline 138 ;  END_IF;
#srcline 139 ;  (* *)
#srcline 140 ;  
#srcline 141 ;  //timeout settings
#srcline 142 ;  IF State <> ggso_Ringing THEN
 LDX  State
#debug usint State
 LD   udint 22  ; TGSMGateStateOut#ggso_Ringing
 EQ
 NEG
 JMC  SMS_HANDLER_2_L9
#srcline 143 ;    IF SendPending OR UssdPending OR State = ggso_Reset THEN
 LDX  SendPending
#debug bool SendPending
 LDX  UssdPending
#debug bool UssdPending
 OR  
 LDX  State
#debug usint State
 LD   udint 2  ; TGSMGateStateOut#ggso_Reset
 EQ
 OR  
 JMC  SMS_HANDLER_2_L11
#srcline 144 ;      TimeOut.PT := longtimeout;
 LD   time 10000
 WRX  TimeOut~PT
#debug_left time TimeOut.PT
#srcline 145 ;    ELSE
 JMP  SMS_HANDLER_2_L12
SMS_HANDLER_2_L11:
#srcline 146 ;      TimeOut.PT := shorttimeout;
 LD   time 5000
 WRX  TimeOut~PT
#debug_left time TimeOut.PT
#srcline 147 ;    END_IF;
SMS_HANDLER_2_L12:
#srcline 148 ;  END_IF;
SMS_HANDLER_2_L9:
#srcline 150 ;  TimeOut(IN := NOT NewMessage & NOT MessOut & NOT WaitTime.Q & NOT HardErr);
 LDY  NewMessage
#debug bool NewMessage
 NEG
 LDX  MessOut
#debug bool MessOut
 NEG
 AND
 LDX  WaitTime~Q
#debug bool WaitTime.Q
 NEG
 AND
 LDX  HardErr
#debug bool HardErr
 NEG
 AND
 WRX  TimeOut~IN
#debug_left bool TimeOut~IN
 LEAX TimeOut
 CAL  TON_L0
#srcline 152 ;  //cancel call after timeout
#srcline 153 ;  IF TimeOut.Q AND State = ggso_Ringing THEN
 LDX  TimeOut~Q
#debug bool TimeOut.Q
 LDX  State
#debug usint State
 LD   udint 22  ; TGSMGateStateOut#ggso_Ringing
 EQ
 AND
 JMC  SMS_HANDLER_2_L13
#srcline 154 ;    TimeOut(IN := false);       //reset timeout
 LD   bool 0       ; false
 WRX  TimeOut~IN
#debug_left bool TimeOut~IN
 LEAX TimeOut
 CAL  TON_L0
#srcline 155 ;    State := ggso_CancelCall;
 LD   udint 23  ; TGSMGateStateOut#ggso_CancelCall
 WRX  State
#debug_left usint State
#srcline 156 ;    MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 157 ;  END_IF;
SMS_HANDLER_2_L13:
#srcline 159 ;  //reset
#srcline 160 ;  IF Reset OR TimeOut.Q THEN
 LDX  Reset
#debug bool Reset
 LDX  TimeOut~Q
#debug bool TimeOut.Q
 OR  
 JMC  SMS_HANDLER_2_L15
#srcline 161 ;    pusint := ADR(RecvMess);
 LDX  RecvMess
#debug pointer RecvMess
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 162 ;    pusintdbg := pusint;
 LEAY pusint
 LDIL 
#debug pointer pusint
 LEAX pusintdbg
 WRIL 
#debug_left pointer pusintdbg
#srcline 163 ;    pusint^ := 0;
 LD   usint 0
 LEAY pusint
 LDIL    ; dereference 
 WRI 
#debug_left usint pusint^
#srcline 164 ;    WaitForOk := false;
 LD   bool 0       ; false
 WRX  WaitForOk
#debug_left bool WaitForOk
#srcline 165 ;    InitDone  := false;
 LD   bool 0       ; false
 WRX  InitDone
#debug_left bool InitDone
#srcline 166 ;    Ring      := false;
 LD   bool 0       ; false
 WRX  Ring
#debug_left bool Ring
#srcline 167 ;    HardErr   := false;
 LD   bool 0       ; false
 WRX  HardErr
#debug_left bool HardErr
#srcline 168 ;    ColdRestart := Cold;
 LDX  Cold
#debug bool Cold
 WRX  ColdRestart
#debug_left bool ColdRestart
#srcline 169 ;    SendPending := false;
 LD   bool 0       ; false
 WRX  SendPending
#debug_left bool SendPending
#srcline 170 ;    UssdPending := false;
 LD   bool 0       ; false
 WRX  UssdPending
#debug_left bool UssdPending
#srcline 171 ;    DialPending := false;
 LD   bool 0       ; false
 WRX  DialPending
#debug_left bool DialPending
#srcline 172 ;    State := ggso_Init;
 LD   udint 0  ; TGSMGateStateOut#ggso_Init
 WRX  State
#debug_left usint State
#srcline 173 ;    MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 174 ;    Error := gger_None;
 LD   udint 0  ; TGSMGateError#gger_None
 WRX  Error
#debug_left usint Error
#srcline 175 ;    ReadErrs  := 0;
 LD   usint 0
 WRX  ReadErrs
#debug_left usint ReadErrs
#srcline 176 ;    RingCount := 0;
 LD   usint 0
 WRX  RingCount
#debug_left usint RingCount
#srcline 177 ;  END_IF;
SMS_HANDLER_2_L15:
#srcline 179 ;  //store request to send SMS
#srcline 180 ;  IF Send THEN
 LDX  Send
#debug bool Send
 JMC  SMS_HANDLER_2_L17
#srcline 181 ;    SendPending    := true;
 LD   bool -1       ; true
 WRX  SendPending
#debug_left bool SendPending
#srcline 182 ;    l_Stat         := Stat;
 LDX  Stat
#debug bool Stat
 WRX  l_Stat
#debug_left bool l_Stat
#srcline 183 ;    l_Recipient    := Recipient;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   20
 DST    ; Level 1
 LDX  Recipient
#debug string Recipient
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX l_Recipient
 WRI  
 LEAX l_Recipient
 LD   20
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string l_Recipient
 PDST   ; Level 1
#srcline 184 ;    l_MessToSend   := MessToSend;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   160
 DST    ; Level 1
 LDX  MessToSend
#debug string MessToSend
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX l_MessToSend
 WRI  
 LEAX l_MessToSend
 LD   160
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string l_MessToSend
 PDST   ; Level 1
#srcline 185 ;  END_IF;
SMS_HANDLER_2_L17:
#srcline 187 ;  //store request to send USSD
#srcline 188 ;  IF Ussd THEN
 LDX  Ussd
#debug bool Ussd
 JMC  SMS_HANDLER_2_L19
#srcline 189 ;    UssdPending := true;
 LD   bool -1       ; true
 WRX  UssdPending
#debug_left bool UssdPending
#srcline 190 ;    l_USSD := Recipient;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   20
 DST    ; Level 1
 LDX  Recipient
#debug string Recipient
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX l_USSD
 WRI  
 LEAX l_USSD
 LD   20
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string l_USSD
 PDST   ; Level 1
#srcline 191 ;  END_IF;
SMS_HANDLER_2_L19:
#srcline 193 ;  //set flag when dialing number
#srcline 194 ;  IF Ready AND Dial THEN
 LDX  Ready
#debug bool Ready
 LDX  Dial
#debug bool Dial
 AND
 JMC  SMS_HANDLER_2_L21
#srcline 195 ;    IF State <> ggso_Ringing THEN
 LDX  State
#debug usint State
 LD   udint 22  ; TGSMGateStateOut#ggso_Ringing
 EQ
 NEG
 JMC  SMS_HANDLER_2_L23
#srcline 196 ;      DialPending := true;
 LD   bool -1       ; true
 WRX  DialPending
#debug_left bool DialPending
#srcline 197 ;    END_IF;
SMS_HANDLER_2_L23:
#srcline 198 ;  END_IF;
SMS_HANDLER_2_L21:
#srcline 200 ;  //pusint := ADR(State); //pointer to state variable for numeric comparations
#srcline 202 ;  //set GSM gateway ready flag
#srcline 203 ;  Ready := InitDone & Error = gger_None & NOT SendPending & NOT UssdPending & NOT DialPending & NOT Ring & Signal <> -1;
 LDX  InitDone
#debug bool InitDone
 LDX  Error
#debug usint Error
 LD   udint 0  ; TGSMGateError#gger_None
 EQ
 AND
 LDX  SendPending
#debug bool SendPending
 NEG
 AND
 LDX  UssdPending
#debug bool UssdPending
 NEG
 AND
 LDX  DialPending
#debug bool DialPending
 NEG
 AND
 LDX  Ring
#debug bool Ring
 NEG
 AND
 LDX  Signal
#debug sint Signal
 EXTB 
 LD   sint -1
 EQ
 NEG
 AND
 WRX  Ready
#debug_left bool Ready
#srcline 205 ;  //quasi-states
#srcline 206 ;  CASE State OF
 LDX  State
#debug usint State
 WRY  P0__st__
 LD   11
 LDY  P0__st__
 EQ  
 JMC  SMS_HANDLER_2_L26
#srcline 207 ;    ggso_EraseQuery:
#srcline 208 ;      Counter := 1;
 LD   usint 1
 WRX  Counter
#debug_left usint Counter
#srcline 209 ;      IF Erase & NeedErase THEN
 LDX  Erase
#debug bool Erase
 LDX  NeedErase
#debug bool NeedErase
 AND
 JMC  SMS_HANDLER_2_L27
#srcline 210 ;        State := ggso_Erase;
 LD   udint 12  ; TGSMGateStateOut#ggso_Erase
 WRX  State
#debug_left usint State
#srcline 211 ;      ELSE
 JMP  SMS_HANDLER_2_L28
SMS_HANDLER_2_L27:
#srcline 212 ;        State := ggso_SignalQ;
 LD   udint 20  ; TGSMGateStateOut#ggso_SignalQ
 WRX  State
#debug_left usint State
#srcline 213 ;      END_IF;
SMS_HANDLER_2_L28:
#srcline 214 ;      MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
 JMP  SMS_HANDLER_2_L25
SMS_HANDLER_2_L26:
 LD   14
 LDY  P0__st__
 EQ  
 JMC  SMS_HANDLER_2_L29
#srcline 215 ;    ggso_ReadQuery:
#srcline 216 ;      WaitTime.PT := Pause1;
 LD   time 500
 WRX  WaitTime~PT
#debug_left time WaitTime.PT
#srcline 217 ;      Counter := 1;
 LD   usint 1
 WRX  Counter
#debug_left usint Counter
#srcline 218 ;      State := ggso_Read;
 LD   udint 15  ; TGSMGateStateOut#ggso_Read
 WRX  State
#debug_left usint State
#srcline 219 ;      MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
 JMP  SMS_HANDLER_2_L25
SMS_HANDLER_2_L29:
SMS_HANDLER_2_L25:
#srcline 222 ;  //transmiting
#srcline 223 ;  WaitTime(IN := MessOut); //timeout between recieve and transmit
 LDX  MessOut
#debug bool MessOut
 WRX  WaitTime~IN
#debug_left bool WaitTime~IN
 LEAX WaitTime
 CAL  TON_L0
#srcline 224 ;  IF WaitTime.Q THEN
 LDX  WaitTime~Q
#debug bool WaitTime.Q
 JMC  SMS_HANDLER_2_L30
#srcline 225 ;    //states
#srcline 226 ;    CASE State OF
 LDX  State
#debug usint State
 WRY  P1__st__
 LD   0
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_2_L33
#srcline 227 ;      ggso_Init :
#srcline 228 ;        WaitTime.PT := Pause1;
 LD   time 500
 WRX  WaitTime~PT
#debug_left time WaitTime.PT
#srcline 229 ;        ReadErrs := 0;
 LD   usint 0
 WRX  ReadErrs
#debug_left usint ReadErrs
#srcline 230 ;        {ASM}
#srcline 231
          #macro initstring(DES, SRC, LEN)
#srcline 232
          LD   0   ; null string
#srcline 233
          WRX  DES
#srcline 234
          LEAX DES
#srcline 235
          LD   LEN
#srcline 236
          DST    ; Level 1
#srcline 237
          LEA  SRC
#srcline 238
          SCON
#srcline 239
          PDST ;level 1
#srcline 240
          #endm
#srcline 241
          initstring(DataOUT, __Init_____GsmLib_AtCommandATE0, 32)
#srcline 242 ;        {END_ASM}
#srcline 243 ;        Signal := -1;
 LD   sint -1
 WRX  Signal
#debug_left sint Signal
 JMP  SMS_HANDLER_2_L32
SMS_HANDLER_2_L33:
 LD   1
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_2_L34
#srcline 244 ;        //DataOUT := AtCommandATE0;
#srcline 246 ;      ggso_BaudRate:
#srcline 247 ;        {ASM}
#srcline 248
          initstring(DataOUT, __Init_____GsmLib_AtCommandATIPR, 32)
#srcline 249 ;        {END_ASM}
#srcline 250 ;        //DataOUT := AtCommandATIPR;
#srcline 251 ;      ggso_Reset:
 JMP  SMS_HANDLER_2_L32
SMS_HANDLER_2_L34:
 LD   2
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_2_L35
#srcline 252 ;        {ASM}
#srcline 253
          initstring(DataOUT, __Init_____GsmLib_AtCommandATCFUN, 32)
#srcline 254 ;        {END_ASM}
#srcline 255 ;        //DataOUT := AtCommandATCFUN;
#srcline 256 ;      ggso_Pin:
 JMP  SMS_HANDLER_2_L32
SMS_HANDLER_2_L35:
 LD   3
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_2_L36
#srcline 257 ;        {ASM}
#srcline 258
          initstring(DataOUT, __Init_____GsmLib_AtCommandATCPIN1, 32)
#srcline 259 ;        {END_ASM}
#srcline 260 ;        //DataOUT := AtCommandATCPIN1;
#srcline 261 ;      ggso_PinValue:
 JMP  SMS_HANDLER_2_L32
SMS_HANDLER_2_L36:
 LD   4
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_2_L37
#srcline 262 ;        IF LEN(IN := Pin) > 0 THEN
 LDX  Pin
#debug string Pin
 SLEN 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_2_L38
#srcline 263 ;          DataOUT := CONCAT(_GsmLib_AtCommandATCPIN2,Pin,_GsmLib_CrLfString);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   32
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATCPIN2
 SCON
 LDX  Pin
#debug string Pin
 SCON
 LEA  _GsmLib_CrLfString

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX DataOUT
 WRI  
 LEAX DataOUT
 LD   32
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string DataOUT
 PDST   ; Level 1
#srcline 264 ;        ELSE
 JMP  SMS_HANDLER_2_L39
SMS_HANDLER_2_L38:
#srcline 265 ;          State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 266 ;          Error := gger_No_Pin;
 LD   udint 1  ; TGSMGateError#gger_No_Pin
 WRX  Error
#debug_left usint Error
#srcline 267 ;        END_IF;
SMS_HANDLER_2_L39:
 JMP  SMS_HANDLER_2_L32
SMS_HANDLER_2_L37:
 LD   5
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_2_L40
#srcline 268 ;      ggso_Conf1:
#srcline 269 ;        {ASM}
#srcline 270
          initstring(DataOUT, __Init_____GsmLib_AtCommandATCMEE, 32)
#srcline 271 ;        {END_ASM}
#srcline 272 ;        //DataOUT := AtCommandATCMEE;
#srcline 273 ;      ggso_Conf2:
 JMP  SMS_HANDLER_2_L32
SMS_HANDLER_2_L40:
 LD   6
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_2_L41
#srcline 274 ;        {ASM}
#srcline 275
          initstring(DataOUT, __Init_____GsmLib_AtCommandATCMGF0, 32)
#srcline 276 ;        {END_ASM}
#srcline 277 ;        //DataOUT := AtCommandATCMGF0;
#srcline 278 ;      ggso_Conf3:
 JMP  SMS_HANDLER_2_L32
SMS_HANDLER_2_L41:
 LD   7
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_2_L42
#srcline 279 ;        {ASM}
#srcline 280
          initstring(DataOUT, __Init_____GsmLib_AtCommandATCNMI, 32)
#srcline 281 ;        {END_ASM}
#srcline 282 ;        //DataOUT := AtCommandATCNMI;
#srcline 283 ;      ggso_Conf4:
 JMP  SMS_HANDLER_2_L32
SMS_HANDLER_2_L42:
 LD   8
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_2_L43
#srcline 284 ;        {ASM}
#srcline 285
          initstring(DataOUT, __Init_____GsmLib_AtCommandATCPMS, 32)
#srcline 286 ;        {END_ASM}
#srcline 287 ;        //DataOUT := AtCommandATCPMS;
#srcline 288 ;      ggso_Conf5:
 JMP  SMS_HANDLER_2_L32
SMS_HANDLER_2_L43:
 LD   9
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_2_L44
#srcline 289 ;        {ASM}
#srcline 290
          initstring(DataOUT, __Init_____GsmLib_AtCommandATSSMSS, 32)
#srcline 291 ;        {END_ASM}
#srcline 292 ;        //DataOUT := AtCommandATSSMSS;
#srcline 293 ;      ggso_Conf6:
 JMP  SMS_HANDLER_2_L32
SMS_HANDLER_2_L44:
 LD   26
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_2_L45
#srcline 294 ;        {ASM}
#srcline 295
          initstring(DataOUT, __Init_____GsmLib_AtReplyATSM20_0, 32)
#srcline 296 ;        {END_ASM}
#srcline 297 ;        //DataOUT := _GsmLib_AtReplyATSM20_0;
#srcline 298 ;        //
#srcline 299 ;      ggso_Center:
 JMP  SMS_HANDLER_2_L32
SMS_HANDLER_2_L45:
 LD   10
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_2_L46
#srcline 300 ;        IF LEN(SMSCenter) > 0 THEN
 LDX  SMSCenter
#debug string SMSCenter
 SLEN 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_2_L47
#srcline 301 ;          DataOUT := CONCAT(_GsmLib_AtCommandATCSCA,SMSCenter,_GsmLib_QuoteCrLfString);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   32
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATCSCA
 SCON
 LDX  SMSCenter
#debug string SMSCenter
 SCON
 LEA  _GsmLib_QuoteCrLfString

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX DataOUT
 WRI  
 LEAX DataOUT
 LD   32
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string DataOUT
 PDST   ; Level 1
#srcline 302 ;        ELSE
 JMP  SMS_HANDLER_2_L48
SMS_HANDLER_2_L47:
#srcline 303 ;          State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 304 ;          Error := gger_No_Center_Number;
 LD   udint 7  ; TGSMGateError#gger_No_Center_Number
 WRX  Error
#debug_left usint Error
#srcline 305 ;        END_IF;
SMS_HANDLER_2_L48:
 JMP  SMS_HANDLER_2_L32
SMS_HANDLER_2_L46:
 LD   12
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_2_L49
#srcline 306 ;      ggso_Erase:
#srcline 307 ;        {$IFDEF DO_NOT_ERASE}
#srcline 308 ;        DataOUT := _GsmLib_AtCommandATE0;
#srcline 309 ;        {$ELSE}
#srcline 310 ;        DataOUT := _GsmLib_AtCommandATCMGD + USINT_TO_STRING(Counter) + _GsmLib_CrLfString;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   32
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATCMGD
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   32
 DST    ; Level 2
 LDX  Counter
#debug usint Counter
 SCNV $0830;  IEC_USINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 LEA  _GsmLib_CrLfString
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX DataOUT
 WRI  
 LEAX DataOUT
 LD   32
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string DataOUT
 PDST   ; Level 1
 JMP  SMS_HANDLER_2_L32
SMS_HANDLER_2_L49:
 LD   19
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_2_L50
#srcline 311 ;        {$END_IF}
#srcline 312 ;      ggso_Ussd:
#srcline 313 ;        IF LEN(IN := l_USSD) > 0 THEN
 LEAX l_USSD
#debug string l_USSD
 SLEN 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_2_L51
#srcline 314 ;          DataOUT := CONCAT(_GsmLib_AtCommandATD,l_USSD,_GsmLib_SemiColonCrLfString);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   32
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATD
 SCON
 LEAX l_USSD
#debug string l_USSD
 SCON
 LEA  _GsmLib_SemiColonCrLfString

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX DataOUT
 WRI  
 LEAX DataOUT
 LD   32
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string DataOUT
 PDST   ; Level 1
#srcline 315 ;        ELSE
 JMP  SMS_HANDLER_2_L52
SMS_HANDLER_2_L51:
#srcline 316 ;          State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 317 ;          Error := gger_No_Recipient_Number;
 LD   udint 8  ; TGSMGateError#gger_No_Recipient_Number
 WRX  Error
#debug_left usint Error
#srcline 318 ;        END_IF;
SMS_HANDLER_2_L52:
 JMP  SMS_HANDLER_2_L32
SMS_HANDLER_2_L50:
 LD   18
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_2_L53
#srcline 319 ;      ggso_Send:
#srcline 320 ;        IF LEN(IN := l_Recipient) = 0 THEN
 LEAX l_Recipient
#debug string l_Recipient
 SLEN 
 LD   int 0
 EQ
 JMC  SMS_HANDLER_2_L54
#srcline 321 ;          State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 322 ;          Error := gger_No_Recipient_Number;
 LD   udint 8  ; TGSMGateError#gger_No_Recipient_Number
 WRX  Error
#debug_left usint Error
#srcline 323 ;        ELSIF LEN(IN := l_MessToSend) = 0 THEN
 JMP  SMS_HANDLER_2_L55
SMS_HANDLER_2_L54:
 LEAX l_MessToSend
#debug string l_MessToSend
 SLEN 
 LD   int 0
 EQ
 JMC  SMS_HANDLER_2_L56
#srcline 324 ;          State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 325 ;          Error := gger_Empty_Message_Text;
 LD   udint 16  ; TGSMGateError#gger_Empty_Message_Text
 WRX  Error
#debug_left usint Error
#srcline 326 ;        ELSE
 JMP  SMS_HANDLER_2_L55
SMS_HANDLER_2_L56:
#srcline 327 ;          SmsRef := 0;
 LD   usint 0
 WRX  SmsRef
#debug_left usint SmsRef
#srcline 328 ;          pusint := ADR(l_Recipient);
 LEAX l_Recipient
#debug pointer l_Recipient
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 329 ;          BuferOUT[0] := 16#3030; //00
 LD   word $3030
 WRX  BuferOUT[0]
#debug_left word BuferOUT[0]
#srcline 330 ;          IF l_Stat  THEN
 LDX  l_Stat
#debug bool l_Stat
 JMC  SMS_HANDLER_2_L57
#srcline 331 ;            BuferOUT[1] := _GsmLib_BYTE_TO_HEX(2#0010_0001);
 NXT
 LD   byte 33
 WR   __Instance___GsmLib_BYTE_TO_HEX~B
#debug_left byte __Instance___GsmLib_BYTE_TO_HEX~B
 PRV
 LEA  __Instance___GsmLib_BYTE_TO_HEX
 CAL  _GsmLib_BYTE_TO_HEX_L0
 WRX  BuferOUT[1]
#debug_left word BuferOUT[1]
#srcline 332 ;          ELSE
 JMP  SMS_HANDLER_2_L58
SMS_HANDLER_2_L57:
#srcline 333 ;            BuferOUT[1] := _GsmLib_BYTE_TO_HEX(2#0000_0001);
 NXT
 LD   byte 1
 WR   __Instance___GsmLib_BYTE_TO_HEX~B
#debug_left byte __Instance___GsmLib_BYTE_TO_HEX~B
 PRV
 LEA  __Instance___GsmLib_BYTE_TO_HEX
 CAL  _GsmLib_BYTE_TO_HEX_L0
 WRX  BuferOUT[1]
#debug_left word BuferOUT[1]
#srcline 334 ;          END_IF;
SMS_HANDLER_2_L58:
#srcline 335 ;          BuferOUT[2] := 16#3030; //00
 LD   word $3030
 WRX  BuferOUT[2]
#debug_left word BuferOUT[2]
#srcline 336 ;          IF pusint^ = 43 THEN      //'+'
 LEAY pusint
 LDIL    ; dereference 
 LDI  
#debug usint pusint^
 LD   usint 43
 EQ
 JMC  SMS_HANDLER_2_L59
#srcline 337 ;            BuferOUT[4] := 16#3139; //91 - internacional number
 LD   word $3139
 WRX  BuferOUT[4]
#debug_left word BuferOUT[4]
#srcline 338 ;          ELSE
 JMP  SMS_HANDLER_2_L60
SMS_HANDLER_2_L59:
#srcline 339 ;            BuferOUT[4] := 16#3138; //81 - local number
 LD   word $3138
 WRX  BuferOUT[4]
#debug_left word BuferOUT[4]
#srcline 340 ;          END_IF;
SMS_HANDLER_2_L60:
#srcline 341 ;          indx := _GsmLib_CodeSemiOctetsNumber(ADR(BuferOUT[5]), l_Recipient);
 NXT
 LEAX BuferOUT
 ADD  10  ; + offset 
#debug pointer BuferOUT[5]
 LEA  __Instance___GsmLib_CodeSemiOctetsNumber~IN
 WRIL 
#debug_left udint __Instance___GsmLib_CodeSemiOctetsNumber~IN
 LEAX l_Recipient
 WR   __Instance___GsmLib_CodeSemiOctetsNumber~Num
#debug_left pointer __Instance___GsmLib_CodeSemiOctetsNumber.Num
 PRV
 LEA  __Instance___GsmLib_CodeSemiOctetsNumber
 CAL  _GsmLib_CodeSemiOctetsNumber_L0
 WRY  indx
#debug_left usint indx
#srcline 342 ;          BuferOUT[3] := _GsmLib_BYTE_TO_HEX(USINT_TO_BYTE(indx));
 NXT
 LDY  indx
#debug usint indx
 AND  $FF
 WR   __Instance___GsmLib_BYTE_TO_HEX~B
#debug_left byte __Instance___GsmLib_BYTE_TO_HEX~B
 PRV
 LEA  __Instance___GsmLib_BYTE_TO_HEX
 CAL  _GsmLib_BYTE_TO_HEX_L0
 WRX  BuferOUT[3]
#debug_left word BuferOUT[3]
#srcline 343 ;          indx :=  (11 + indx) / 2;     //5 + (tusint + 1) / 2;
 LD   usint 11
 LDY  indx
#debug usint indx
 ADD
 AND  $FF
 LD   usint 2
 DIVL
 AND  $FF
 WRY  indx
#debug_left usint indx
#srcline 344 ;          BuferOUT[indx]   := 16#3030; //00
 LD   word $3030
 LEAX BuferOUT
 LDY  indx
#debug usint indx
 RCHK 179   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left word BuferOUT[indx]
#srcline 345 ;          indx := indx + 1;
 LDY  indx
#debug usint indx
 LD   usint 1
 ADD
 AND  $FF
 WRY  indx
#debug_left usint indx
#srcline 346 ;          CASE SmsCoding OF
 LDX  SmsCoding
#debug usint SmsCoding
 WRY  P2__st__
 LD   0
 LDY  P2__st__
 EQ  
 JMC  SMS_HANDLER_2_L62
#srcline 347 ;            ggsc_GSM7bit :
#srcline 348 ;              BuferOUT[indx] := 16#3030; //00
 LD   word $3030
 LEAX BuferOUT
 LDY  indx
#debug usint indx
 RCHK 179   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left word BuferOUT[indx]
#srcline 349 ;              tusint := _GsmLib_CodeTo7bitHEX(HEX := ADR(BuferOUT[indx+2]), PlcCoding := PlcCoding, Text := l_MessToSend);
 NXT
 LEAX BuferOUT
 LDY  indx
#debug usint indx
 LD   usint 2
 ADD
 AND  $FF
 RCHK 179   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
#debug pointer BuferOUT[indx+2]
 LEA  __Instance___GsmLib_CodeTo7bitHEX~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_CodeTo7bitHEX~HEX
 LDX  PlcCoding
#debug usint PlcCoding
 WR   __Instance___GsmLib_CodeTo7bitHEX~PlcCoding
#debug_left usint __Instance___GsmLib_CodeTo7bitHEX~PlcCoding
 LEAX l_MessToSend
 WR   __Instance___GsmLib_CodeTo7bitHEX~Text
#debug_left pointer __Instance___GsmLib_CodeTo7bitHEX.Text
 PRV
 LEA  __Instance___GsmLib_CodeTo7bitHEX
 CAL  _GsmLib_CodeTo7bitHEX_L0
 WRY  tusint
#debug_left usint tusint
 JMP  SMS_HANDLER_2_L61
SMS_HANDLER_2_L62:
 LD   1
 LDY  P2__st__
 EQ  
 JMC  SMS_HANDLER_2_L63
#srcline 350 ;            ggsc_8bit :
#srcline 351 ;              BuferOUT[indx] := 16#3430; //04
 LD   word $3430
 LEAX BuferOUT
 LDY  indx
#debug usint indx
 RCHK 179   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left word BuferOUT[indx]
#srcline 352 ;              tusint := _GsmLib_CodeTo8bitHEX(HEX := ADR(BuferOUT[indx+2]), Text := l_MessToSend);
 NXT
 LEAX BuferOUT
 LDY  indx
#debug usint indx
 LD   usint 2
 ADD
 AND  $FF
 RCHK 179   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
#debug pointer BuferOUT[indx+2]
 LEA  __Instance___GsmLib_CodeTo8bitHEX~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_CodeTo8bitHEX~HEX
 LEAX l_MessToSend
 WR   __Instance___GsmLib_CodeTo8bitHEX~Text
#debug_left pointer __Instance___GsmLib_CodeTo8bitHEX.Text
 PRV
 LEA  __Instance___GsmLib_CodeTo8bitHEX
 CAL  _GsmLib_CodeTo8bitHEX_L0
 WRY  tusint
#debug_left usint tusint
 JMP  SMS_HANDLER_2_L61
SMS_HANDLER_2_L63:
 LD   2
 LDY  P2__st__
 EQ  
 JMC  SMS_HANDLER_2_L64
#srcline 353 ;            ggsc_UCS2    :
#srcline 354 ;              BuferOUT[indx] := 16#3830; //08
 LD   word $3830
 LEAX BuferOUT
 LDY  indx
#debug usint indx
 RCHK 179   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left word BuferOUT[indx]
#srcline 355 ;              tusint := _GsmLib_CodeTo16bitHEX(HEX := ADR(BuferOUT[indx+2]), PlcCoding := PlcCoding, Text := l_MessToSend);
 NXT
 LEAX BuferOUT
 LDY  indx
#debug usint indx
 LD   usint 2
 ADD
 AND  $FF
 RCHK 179   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
#debug pointer BuferOUT[indx+2]
 LEA  __Instance___GsmLib_CodeTo16bitHEX~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_CodeTo16bitHEX~HEX
 LDX  PlcCoding
#debug usint PlcCoding
 WR   __Instance___GsmLib_CodeTo16bitHEX~PlcCoding
#debug_left usint __Instance___GsmLib_CodeTo16bitHEX~PlcCoding
 LEAX l_MessToSend
 WR   __Instance___GsmLib_CodeTo16bitHEX~Text
#debug_left pointer __Instance___GsmLib_CodeTo16bitHEX.Text
 PRV
 LEA  __Instance___GsmLib_CodeTo16bitHEX
 CAL  _GsmLib_CodeTo16bitHEX_L0
 WRY  tusint
#debug_left usint tusint
 JMP  SMS_HANDLER_2_L61
SMS_HANDLER_2_L64:
SMS_HANDLER_2_L61:
#srcline 357 ;          indx := indx + 1;
 LDY  indx
#debug usint indx
 LD   usint 1
 ADD
 AND  $FF
 WRY  indx
#debug_left usint indx
#srcline 358 ;          IF SmsCoding = ggsc_GSM7bit THEN
 LDX  SmsCoding
#debug usint SmsCoding
 LD   udint 0  ; TGSMGateSmsCoding#ggsc_GSM7bit
 EQ
 JMC  SMS_HANDLER_2_L65
#srcline 359 ;            BuferOUT[indx] := _GsmLib_BYTE_TO_HEX(UDINT_TO_BYTE(USINT_TO_UDINT(tusint)*8/7));
 NXT
 LDY  tusint
#debug usint tusint
 LD   udint 8
 MUL
 LD   udint 7
 DIVL
 AND  $FF
 WR   __Instance___GsmLib_BYTE_TO_HEX~B
#debug_left byte __Instance___GsmLib_BYTE_TO_HEX~B
 PRV
 LEA  __Instance___GsmLib_BYTE_TO_HEX
 CAL  _GsmLib_BYTE_TO_HEX_L0
 LEAX BuferOUT
 LDY  indx
#debug usint indx
 RCHK 179   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left word BuferOUT[indx]
#srcline 360 ;          ELSE
 JMP  SMS_HANDLER_2_L66
SMS_HANDLER_2_L65:
#srcline 361 ;            BuferOUT[indx] := _GsmLib_BYTE_TO_HEX(USINT_TO_BYTE(tusint));
 NXT
 LDY  tusint
#debug usint tusint
 AND  $FF
 WR   __Instance___GsmLib_BYTE_TO_HEX~B
#debug_left byte __Instance___GsmLib_BYTE_TO_HEX~B
 PRV
 LEA  __Instance___GsmLib_BYTE_TO_HEX
 CAL  _GsmLib_BYTE_TO_HEX_L0
 LEAX BuferOUT
 LDY  indx
#debug usint indx
 RCHK 179   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left word BuferOUT[indx]
#srcline 362 ;          END_IF;
SMS_HANDLER_2_L66:
#srcline 363 ;          OctetLen := USINT_TO_UINT(indx+tusint+1)*2+1;
 LDY  indx
#debug usint indx
 LDY  tusint
#debug usint tusint
 ADD
 AND  $FF
 LD   usint 1
 ADD
 AND  $FF
 AND  $FFFF
 LD   uint 2
 MUL
 AND  $FFFF
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  OctetLen
#debug_left uint OctetLen
#srcline 364 ;          BuferOUT[indx+tusint+1] := 16#1A;
 LD   word $1A
 LEAX BuferOUT
 LDY  indx
#debug usint indx
 LDY  tusint
#debug usint tusint
 ADD
 AND  $FF
 LD   usint 1
 ADD
 AND  $FF
 RCHK 179   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left word BuferOUT[indx+tusint+1]
#srcline 365 ;          if tusint > 140 THEN
 LDY  tusint
#debug usint tusint
 LD   usint 140
 GT
 JMC  SMS_HANDLER_2_L67
#srcline 366 ;            State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 367 ;            Error := gger_Message_Text_Too_Long;
 LD   udint 17  ; TGSMGateError#gger_Message_Text_Too_Long
 WRX  Error
#debug_left usint Error
#srcline 368 ;          ELSE
 JMP  SMS_HANDLER_2_L68
SMS_HANDLER_2_L67:
#srcline 369 ;            DataOUT := _GsmLib_AtCommandATCMGS2+USINT_TO_STRING(indx+tusint)+_GsmLib_CrLfString;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   32
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATCMGS2
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   32
 DST    ; Level 2
 LDY  indx
#debug usint indx
 LDY  tusint
#debug usint tusint
 ADD
 AND  $FF
 SCNV $0830;  IEC_USINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 LEA  _GsmLib_CrLfString
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX DataOUT
 WRI  
 LEAX DataOUT
 LD   32
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string DataOUT
 PDST   ; Level 1
#srcline 370 ;          END_IF;
SMS_HANDLER_2_L68:
#srcline 371 ;        END_IF;
SMS_HANDLER_2_L55:
 JMP  SMS_HANDLER_2_L32
SMS_HANDLER_2_L53:
 LD   17
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_2_L69
#srcline 372 ;        //Stop := true;
#srcline 373 ;      ggso_SendText:
#srcline 374 ;        IF LEN(IN := l_MessToSend) > 0 THEN
 LEAX l_MessToSend
#debug string l_MessToSend
 SLEN 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_2_L70
#srcline 375 ;          SendTo.lenTx := OctetLen;
 LDX  OctetLen
#debug uint OctetLen
 WRX  SendTo~lenTx
#debug_left uint SendTo.lenTx
#srcline 376 ;        ELSE
 JMP  SMS_HANDLER_2_L71
SMS_HANDLER_2_L70:
#srcline 377 ;          State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 378 ;          Error := gger_Empty_Message_Text;
 LD   udint 16  ; TGSMGateError#gger_Empty_Message_Text
 WRX  Error
#debug_left usint Error
#srcline 379 ;        END_IF;
SMS_HANDLER_2_L71:
 JMP  SMS_HANDLER_2_L32
SMS_HANDLER_2_L69:
 LD   15
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_2_L72
#srcline 380 ;      ggso_Read:
#srcline 381 ;        DataOUT := _GsmLib_AtCommandATCMGR+USINT_TO_STRING(Counter)+_GsmLib_CrLfString;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   32
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATCMGR
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   32
 DST    ; Level 2
 LDX  Counter
#debug usint Counter
 SCNV $0830;  IEC_USINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 LEA  _GsmLib_CrLfString
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX DataOUT
 WRI  
 LEAX DataOUT
 LD   32
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string DataOUT
 PDST   ; Level 1
 JMP  SMS_HANDLER_2_L32
SMS_HANDLER_2_L72:
 LD   13
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_2_L73
#srcline 382 ;      ggso_EraseOne:
#srcline 383 ;        {$IFDEF DO_NOT_ERASE}
#srcline 384 ;        DataOUT := _GsmLib_AtCommandATE0;
#srcline 385 ;        {$ELSE}
#srcline 386 ;        DataOUT := _GsmLib_AtCommandATCMGD+USINT_TO_STRING(Counter)+_GsmLib_CrLfString;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   32
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATCMGD
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   32
 DST    ; Level 2
 LDX  Counter
#debug usint Counter
 SCNV $0830;  IEC_USINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 LEA  _GsmLib_CrLfString
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX DataOUT
 WRI  
 LEAX DataOUT
 LD   32
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string DataOUT
 PDST   ; Level 1
 JMP  SMS_HANDLER_2_L32
SMS_HANDLER_2_L73:
 LD   20
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_2_L74
#srcline 387 ;        {$END_IF}
#srcline 388 ;      ggso_SignalQ:
#srcline 389 ;        {ASM}
#srcline 390
          initstring(DataOUT, __Init_____GsmLib_AtCommandATCSQ, 32)
#srcline 391 ;        {END_ASM}
#srcline 392 ;        //DataOUT := AtCommandATCSQ;
#srcline 393 ;      ggso_RingNumber:
 JMP  SMS_HANDLER_2_L32
SMS_HANDLER_2_L74:
 LD   21
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_2_L75
#srcline 394 ;        {ASM}
#srcline 395
          initstring(DataOUT, __Init_____GsmLib_AtCommandATCLCC, 32)
#srcline 396 ;        {END_ASM}
#srcline 397 ;        //DataOUT := AtCommandATCLCC;
#srcline 398 ;      ggso_Ringing:
 JMP  SMS_HANDLER_2_L32
SMS_HANDLER_2_L75:
 LD   22
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_2_L76
#srcline 399 ;        IF LEN(IN := Recipient) > 0 THEN
 LDX  Recipient
#debug string Recipient
 SLEN 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_2_L77
#srcline 400 ;          DataOUT := CONCAT(_GsmLib_AtCommandATD,Recipient,_GsmLib_SemiColonCrLfString);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   32
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATD
 SCON
 LDX  Recipient
#debug string Recipient
 SCON
 LEA  _GsmLib_SemiColonCrLfString

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX DataOUT
 WRI  
 LEAX DataOUT
 LD   32
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string DataOUT
 PDST   ; Level 1
#srcline 401 ;        ELSE
 JMP  SMS_HANDLER_2_L78
SMS_HANDLER_2_L77:
#srcline 402 ;          State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 403 ;          Error := gger_No_Recipient_Number;
 LD   udint 8  ; TGSMGateError#gger_No_Recipient_Number
 WRX  Error
#debug_left usint Error
#srcline 404 ;        END_IF;
SMS_HANDLER_2_L78:
 JMP  SMS_HANDLER_2_L32
SMS_HANDLER_2_L76:
 LD   23
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_2_L79
#srcline 405 ;      ggso_CancelCall:
#srcline 406 ;        {ASM}
#srcline 407
          initstring(DataOUT, __Init_____GsmLib_AtCommandATH, 32)
#srcline 408 ;        {END_ASM}
#srcline 409 ;        //DataOUT := AtCommandATH;
#srcline 410 ;        Ring := false;
 LD   bool 0       ; false
 WRX  Ring
#debug_left bool Ring
 JMP  SMS_HANDLER_2_L32
SMS_HANDLER_2_L79:
#srcline 411 ;    ELSE
#srcline 412 ;    ;
#srcline 413 ;    END_CASE;
SMS_HANDLER_2_L32:
#srcline 414 ;    SendTo.rq := Error = gger_None;
 LDX  Error
#debug usint Error
 LD   udint 0  ; TGSMGateError#gger_None
 EQ
 WRX  SendTo~rq
#debug_left bool SendTo.rq
#srcline 415 ;    SendTo.chanCode := chanCode;
 LDX  chanCode
#debug uint chanCode
 WRX  SendTo~chanCode
#debug_left uint SendTo.chanCode
#srcline 416 ;    IF State <> ggso_SendText THEN
 LDX  State
#debug usint State
 LD   udint 17  ; TGSMGateStateOut#ggso_SendText
 EQ
 NEG
 JMC  SMS_HANDLER_2_L80
#srcline 417 ;      SendTo(lenTx := LEN(DataOUT), data := void(DataOUT));
 LEAX DataOUT
#debug string DataOUT
 SLEN 
 WRX  SendTo~lenTx
#debug_left uint SendTo~lenTx
 LEAX DataOUT
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 418 ;    ELSE
 JMP  SMS_HANDLER_2_L81
SMS_HANDLER_2_L80:
#srcline 419 ;      SendTo(data := void(BuferOUT));
 LEAX BuferOUT
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 420 ;    END_IF;
SMS_HANDLER_2_L81:
#srcline 421 ;    MessOut := false;                         //wait for next request
 LD   bool 0       ; false
 WRX  MessOut
#debug_left bool MessOut
#srcline 422 ;  END_IF;
SMS_HANDLER_2_L30:
#srcline 425 ;  //receiving messages from channel
#srcline 426 ;  IF NewMessage THEN //ARC
 LDY  NewMessage
#debug bool NewMessage
 JMC  SMS_HANDLER_2_L82
#srcline 427 ;    pBuferIN := ADR(BuferIN);
 LEAX BuferIN
#debug pointer BuferIN
 LEAY pBuferIN
 WRIL 
#debug_left pointer pBuferIN
#srcline 428 ;    
#srcline 429 ;    IF ChanError <> 0 THEN
 LDY  ChanError
#debug usint ChanError
 LD   usint 0
 EQ
 NEG
 JMC  SMS_HANDLER_2_L84
#srcline 430 ;      State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 431 ;      Error := gger_Channel_error;
 LD   udint 12  ; TGSMGateError#gger_Channel_error
 WRX  Error
#debug_left usint Error
#srcline 432 ;      RecvMess := GetLastComErrTxt(errCode := ChanError);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   160
 DST    ; Level 1
 NXT
 LDY  ChanError
#debug usint ChanError
 WR   __Instance__GetLastComErrTxt~errCode
#debug_left usint __Instance__GetLastComErrTxt~errCode
 PRV
 LEA  __Instance__GetLastComErrTxt
 CAL  GetLastComErrTxt_L0

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  RecvMess
 WRI  
 LDX  RecvMess
 LD   160
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string RecvMess
 PDST   ; Level 1
#srcline 433 ;      RETURN;
 JMP  SMS_HANDLER_2_RET
#srcline 434 ;    END_IF;
SMS_HANDLER_2_L84:
#srcline 436 ;    //unsolicited messages
#srcline 437 ;    //RING
#srcline 438 ;    IF FIND(pBuferIN^, _GsmLib_AtReplyRING) = 1 THEN
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_AtReplyRING
 SFND 
 LD   int 1
 EQ
 JMC  SMS_HANDLER_2_L86
#srcline 439 ;      //Ring := true; presunuto do prijmu ggso_RingNumber
#srcline 440 ;      IF State <> ggso_CancelCall THEN
 LDX  State
#debug usint State
 LD   udint 23  ; TGSMGateStateOut#ggso_CancelCall
 EQ
 NEG
 JMC  SMS_HANDLER_2_L88
#srcline 441 ;        RingCount := 0;
 LD   usint 0
 WRX  RingCount
#debug_left usint RingCount
#srcline 442 ;        State := ggso_RingNumber;
 LD   udint 21  ; TGSMGateStateOut#ggso_RingNumber
 WRX  State
#debug_left usint State
#srcline 443 ;        MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 444 ;      ELSE
 JMP  SMS_HANDLER_2_L89
SMS_HANDLER_2_L88:
#srcline 445 ;        WaitTime.PT := T#11s;
 LD   time 11000
 WRX  WaitTime~PT
#debug_left time WaitTime.PT
#srcline 446 ;        RingCount := RingCount + 1;
 LDX  RingCount
#debug usint RingCount
 LD   usint 1
 ADD
 AND  $FF
 WRX  RingCount
#debug_left usint RingCount
#srcline 447 ;      END_IF;
SMS_HANDLER_2_L89:
#srcline 448 ;      RETURN;
 JMP  SMS_HANDLER_2_RET
#srcline 449 ;    END_IF;
SMS_HANDLER_2_L86:
#srcline 450 ;    //+CMTI
#srcline 451 ;    IF FIND(pBuferIN^, _GsmLib_AtReplyCMTI) > 0 THEN
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_AtReplyCMTI
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_2_L90
#srcline 452 ;      State   := ggso_SignalQ;
 LD   udint 20  ; TGSMGateStateOut#ggso_SignalQ
 WRX  State
#debug_left usint State
#srcline 453 ;      MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 454 ;      RETURN;
 JMP  SMS_HANDLER_2_RET
#srcline 455 ;    END_IF;
SMS_HANDLER_2_L90:
#srcline 456 ;    
#srcline 457 ;    ok := FIND(pBuferIN^, _GsmLib_OkString) > 0;
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_OkString
 SFND 
 LD   int 0
 GTS
 WRX  ok
#debug_left bool ok
#srcline 459 ;    IF WaitForOk AND ok THEN
 LDX  WaitForOk
#debug bool WaitForOk
 LDX  ok
#debug bool ok
 AND
 JMC  SMS_HANDLER_2_L92
#srcline 460 ;      WaitForOk := false;
 LD   bool 0       ; false
 WRX  WaitForOk
#debug_left bool WaitForOk
#srcline 461 ;    ELSE
 JMP  SMS_HANDLER_2_L93
SMS_HANDLER_2_L92:
#srcline 462 ;      WaitForOk := false;
 LD   bool 0       ; false
 WRX  WaitForOk
#debug_left bool WaitForOk
#srcline 463 ;      //states
#srcline 464 ;      CASE State OF
 LDX  State
#debug usint State
 WRY  P3__st__
 LD   0
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_2_L95
#srcline 465 ;        ggso_Init :
#srcline 466 ;          MaxReadErrs := 50;
 LD   usint 50
 WRX  MaxReadErrs
#debug_left usint MaxReadErrs
#srcline 467 ;          WaitTime.PT := Pause4;
 LD   time 3000
 WRX  WaitTime~PT
#debug_left time WaitTime.PT
#srcline 468 ;          IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_2_L96
#srcline 469 ;            IF ColdRestart THEN
 LDX  ColdRestart
#debug bool ColdRestart
 JMC  SMS_HANDLER_2_L98
#srcline 470 ;              WaitTime.PT := Pause1;
 LD   time 500
 WRX  WaitTime~PT
#debug_left time WaitTime.PT
#srcline 471 ;              ColdRestart := false;
 LD   bool 0       ; false
 WRX  ColdRestart
#debug_left bool ColdRestart
#srcline 472 ;              State := ggso_BaudRate;
 LD   udint 1  ; TGSMGateStateOut#ggso_BaudRate
 WRX  State
#debug_left usint State
#srcline 473 ;            ELSE
 JMP  SMS_HANDLER_2_L99
SMS_HANDLER_2_L98:
#srcline 474 ;              State := ggso_Conf6;
 LD   udint 26  ; TGSMGateStateOut#ggso_Conf6
 WRX  State
#debug_left usint State
#srcline 475 ;            END_IF;
SMS_HANDLER_2_L99:
#srcline 476 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 477 ;          END_IF;
SMS_HANDLER_2_L96:
 JMP  SMS_HANDLER_2_L94
SMS_HANDLER_2_L95:
 LD   1
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_2_L100
#srcline 478 ;        ggso_BaudRate:
#srcline 479 ;          IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_2_L101
#srcline 480 ;            State := ggso_Reset;
 LD   udint 2  ; TGSMGateStateOut#ggso_Reset
 WRX  State
#debug_left usint State
#srcline 481 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 482 ;          END_IF;
SMS_HANDLER_2_L101:
 JMP  SMS_HANDLER_2_L94
SMS_HANDLER_2_L100:
 LD   2
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_2_L103
#srcline 483 ;        ggso_Reset:
#srcline 484 ;          IF FIND(pBuferIN^, _GsmLib_AtReplySYSSTART) > 0 THEN
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_AtReplySYSSTART
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_2_L104
#srcline 485 ;            State := ggso_Init;
 LD   udint 0  ; TGSMGateStateOut#ggso_Init
 WRX  State
#debug_left usint State
#srcline 486 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 487 ;          END_IF;
SMS_HANDLER_2_L104:
 JMP  SMS_HANDLER_2_L94
SMS_HANDLER_2_L103:
 LD   3
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_2_L106
#srcline 488 ;        ggso_Pin:
#srcline 489 ;          WaitTime.PT := Pause3;
 LD   time 2000
 WRX  WaitTime~PT
#debug_left time WaitTime.PT
#srcline 490 ;          IF FIND(pBuferIN^, _GsmLib_AtReplyCPIN) > 0 THEN
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_AtReplyCPIN
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_2_L107
#srcline 491 ;            ReadErrs := 0;
 LD   usint 0
 WRX  ReadErrs
#debug_left usint ReadErrs
#srcline 492 ;            IF FIND(pBuferIN^, _GsmLib_AtReplyREADY) > 0 THEN //PIN code is not required
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_AtReplyREADY
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_2_L109
#srcline 493 ;              State :=  ggso_Conf2;
 LD   udint 6  ; TGSMGateStateOut#ggso_Conf2
 WRX  State
#debug_left usint State
#srcline 494 ;              MessOut   := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 495 ;              WaitForOk := true;
 LD   bool -1       ; true
 WRX  WaitForOk
#debug_left bool WaitForOk
#srcline 496 ;            END_IF;
SMS_HANDLER_2_L109:
#srcline 497 ;            IF FIND(pBuferIN^, _GsmLib_AtReplySIMPIN) > 0 THEN //PIN code is required
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_AtReplySIMPIN
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_2_L111
#srcline 498 ;              State := ggso_PinValue;
 LD   udint 4  ; TGSMGateStateOut#ggso_PinValue
 WRX  State
#debug_left usint State
#srcline 499 ;              MessOut   := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 500 ;              WaitForOk := true;
 LD   bool -1       ; true
 WRX  WaitForOk
#debug_left bool WaitForOk
#srcline 501 ;            END_IF;
SMS_HANDLER_2_L111:
#srcline 502 ;            IF NOT MessOut THEN
 LDX  MessOut
#debug bool MessOut
 NEG
 JMC  SMS_HANDLER_2_L113
#srcline 503 ;              State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 504 ;              Error := gger_Pin_Error;
 LD   udint 2  ; TGSMGateError#gger_Pin_Error
 WRX  Error
#debug_left usint Error
#srcline 505 ;            END_IF;
SMS_HANDLER_2_L113:
#srcline 506 ;            IF FIND(pBuferIN^, _GsmLib_AtReplySIMPUK) > 0 THEN //PUK code is required => error
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_AtReplySIMPUK
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_2_L115
#srcline 507 ;              State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 508 ;              Error := gger_Puk_Required;
 LD   udint 3  ; TGSMGateError#gger_Puk_Required
 WRX  Error
#debug_left usint Error
#srcline 509 ;              HardErr := true;
 LD   bool -1       ; true
 WRX  HardErr
#debug_left bool HardErr
#srcline 510 ;            END_IF;
SMS_HANDLER_2_L115:
#srcline 511 ;          ELSE
 JMP  SMS_HANDLER_2_L108
SMS_HANDLER_2_L107:
#srcline 512 ;            ReadErrs := ReadErrs + 1;
 LDX  ReadErrs
#debug usint ReadErrs
 LD   usint 1
 ADD
 AND  $FF
 WRX  ReadErrs
#debug_left usint ReadErrs
#srcline 513 ;            IF ReadErrs > 1 THEN
 LDX  ReadErrs
#debug usint ReadErrs
 LD   usint 1
 GT
 JMC  SMS_HANDLER_2_L117
#srcline 514 ;              State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 515 ;              Error := gger_Pin_Error;
 LD   udint 2  ; TGSMGateError#gger_Pin_Error
 WRX  Error
#debug_left usint Error
#srcline 516 ;            ELSE
 JMP  SMS_HANDLER_2_L118
SMS_HANDLER_2_L117:
#srcline 517 ;              State := ggso_Pin;
 LD   udint 3  ; TGSMGateStateOut#ggso_Pin
 WRX  State
#debug_left usint State
#srcline 518 ;              MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 519 ;            END_IF;
SMS_HANDLER_2_L118:
#srcline 520 ;          END_IF;
SMS_HANDLER_2_L108:
 JMP  SMS_HANDLER_2_L94
SMS_HANDLER_2_L106:
 LD   4
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_2_L119
#srcline 521 ;        ggso_PinValue:
#srcline 522 ;          WaitTime.PT := Pause4; //timeout after PIN set
 LD   time 3000
 WRX  WaitTime~PT
#debug_left time WaitTime.PT
#srcline 523 ;          IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_2_L120
#srcline 524 ;            State := ggso_Conf2;
 LD   udint 6  ; TGSMGateStateOut#ggso_Conf2
 WRX  State
#debug_left usint State
#srcline 525 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 526 ;          ELSE
 JMP  SMS_HANDLER_2_L121
SMS_HANDLER_2_L120:
#srcline 527 ;            State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 528 ;            Error := gger_Pin_Error;
 LD   udint 2  ; TGSMGateError#gger_Pin_Error
 WRX  Error
#debug_left usint Error
#srcline 529 ;            HardErr := true;
 LD   bool -1       ; true
 WRX  HardErr
#debug_left bool HardErr
#srcline 530 ;          END_IF;
SMS_HANDLER_2_L121:
 JMP  SMS_HANDLER_2_L94
SMS_HANDLER_2_L119:
 LD   5
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_2_L122
#srcline 531 ;        ggso_Conf1:
#srcline 532 ;          WaitTime.PT := Pause1;
 LD   time 500
 WRX  WaitTime~PT
#debug_left time WaitTime.PT
#srcline 533 ;          IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_2_L123
#srcline 534 ;            State := ggso_Pin;
 LD   udint 3  ; TGSMGateStateOut#ggso_Pin
 WRX  State
#debug_left usint State
#srcline 535 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 536 ;          ELSE
 JMP  SMS_HANDLER_2_L124
SMS_HANDLER_2_L123:
#srcline 537 ;            State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 538 ;            Error := gger_Cfg_Error;
 LD   udint 4  ; TGSMGateError#gger_Cfg_Error
 WRX  Error
#debug_left usint Error
#srcline 539 ;          END_IF;
SMS_HANDLER_2_L124:
 JMP  SMS_HANDLER_2_L94
SMS_HANDLER_2_L122:
 LD   6
 LDY  P3__st__
 EQ   
 JMD  SMS_HANDLER_2_L125
 LD   7
 LDY  P3__st__
 EQ   
 JMC  SMS_HANDLER_2_L126
SMS_HANDLER_2_L125:
#srcline 540 ;        ggso_Conf2, ggso_Conf3:
#srcline 541 ;          WaitTime.PT := Pause1;
 LD   time 500
 WRX  WaitTime~PT
#debug_left time WaitTime.PT
#srcline 542 ;          IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_2_L127
#srcline 543 ;            pusint := ADR(State);
 LEAX State
#debug pointer State
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 544 ;            pusint^ := pusint^ + 1;
 LEAY pusint
 LDIL    ; dereference 
 LDI  
#debug usint pusint^
 LD   usint 1
 ADD
 AND  $FF
 LEAY pusint
 LDIL    ; dereference 
 WRI 
#debug_left usint pusint^
#srcline 545 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 546 ;          ELSE
 JMP  SMS_HANDLER_2_L128
SMS_HANDLER_2_L127:
#srcline 547 ;            State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 548 ;            Error := gger_Cfg_Error;
 LD   udint 4  ; TGSMGateError#gger_Cfg_Error
 WRX  Error
#debug_left usint Error
#srcline 549 ;          END_IF;
SMS_HANDLER_2_L128:
 JMP  SMS_HANDLER_2_L94
SMS_HANDLER_2_L126:
 LD   8
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_2_L129
#srcline 550 ;        ggso_Conf4:
#srcline 551 ;          NeedErase := true;
 LD   bool -1       ; true
 WRX  NeedErase
#debug_left bool NeedErase
#srcline 552 ;          IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_2_L130
#srcline 553 ;            State := ggso_Conf5; //ggso_Center; //MC35
 LD   udint 9  ; TGSMGateStateOut#ggso_Conf5
 WRX  State
#debug_left usint State
#srcline 554 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 555 ;          ELSIF FIND(pBuferIN^,_GsmLib_AtReplyCPMS) > 0 THEN
 JMP  SMS_HANDLER_2_L131
SMS_HANDLER_2_L130:
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_AtReplyCPMS
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_2_L132
#srcline 556 ;            pstring := ADR(BuferIN[7]);
 LEAX BuferIN
 ADD  7  ; + offset 
#debug pointer BuferIN[7]
 LEAY pstring
 WRIL 
#debug_left pointer pstring
#srcline 557 ;            NeedErase := STRING_TO_USINT(pstring^) <> 0;
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 SCNV $3008;  IEC_STRING _TO_ IEC_USINT
 LD   usint 0
 EQ
 NEG
 WRX  NeedErase
#debug_left bool NeedErase
#srcline 558 ;            pos := FIND(pstring^, _GsmLib_CommaString);
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 LEA  _GsmLib_CommaString
 SFND 
 WRY  pos
#debug_left int pos
#srcline 559 ;            IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_2_L133
#srcline 560 ;              pstring := pstring + INT_TO_UDINT(pos);
 LEAY pstring
 LDIL 
#debug pointer pstring
 LDY  pos
#debug int pos
 EXTW 
 ADD
 LEAY pstring
 WRIL 
#debug_left pointer pstring
#srcline 561 ;              MessagesCnt := STRING_TO_USINT(pstring^);
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 SCNV $3008;  IEC_STRING _TO_ IEC_USINT
 WRX  MessagesCnt
#debug_left usint MessagesCnt
#srcline 562 ;            ELSE
 JMP  SMS_HANDLER_2_L134
SMS_HANDLER_2_L133:
#srcline 563 ;              MessagesCnt := 10;
 LD   usint 10
 WRX  MessagesCnt
#debug_left usint MessagesCnt
#srcline 564 ;            END_IF;
SMS_HANDLER_2_L134:
#srcline 565 ;          ELSE
 JMP  SMS_HANDLER_2_L131
SMS_HANDLER_2_L132:
#srcline 566 ;            State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 567 ;            Error := gger_Cfg_Error;
 LD   udint 4  ; TGSMGateError#gger_Cfg_Error
 WRX  Error
#debug_left usint Error
#srcline 568 ;          END_IF;
SMS_HANDLER_2_L131:
 JMP  SMS_HANDLER_2_L94
SMS_HANDLER_2_L129:
 LD   9
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_2_L135
#srcline 569 ;        ggso_Conf5:
#srcline 570 ;          IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_2_L136
#srcline 571 ;            IF LEN(SMSCenter) > 0 THEN
 LDX  SMSCenter
#debug string SMSCenter
 SLEN 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_2_L138
#srcline 572 ;              State := ggso_Center;
 LD   udint 10  ; TGSMGateStateOut#ggso_Center
 WRX  State
#debug_left usint State
#srcline 573 ;            ELSE
 JMP  SMS_HANDLER_2_L139
SMS_HANDLER_2_L138:
#srcline 574 ;              State := ggso_EraseQuery;
 LD   udint 11  ; TGSMGateStateOut#ggso_EraseQuery
 WRX  State
#debug_left usint State
#srcline 575 ;            END_IF;
SMS_HANDLER_2_L139:
#srcline 576 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 577 ;          ELSE
 JMP  SMS_HANDLER_2_L137
SMS_HANDLER_2_L136:
#srcline 578 ;            State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 579 ;            Error := gger_Cfg_Error;
 LD   udint 4  ; TGSMGateError#gger_Cfg_Error
 WRX  Error
#debug_left usint Error
#srcline 580 ;          END_IF;
SMS_HANDLER_2_L137:
 JMP  SMS_HANDLER_2_L94
SMS_HANDLER_2_L135:
 LD   26
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_2_L140
#srcline 581 ;        ggso_Conf6:
#srcline 582 ;          IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_2_L141
#srcline 583 ;            pusint := ADR(State);
 LEAX State
#debug pointer State
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 584 ;            State := ggso_Conf1;
 LD   udint 5  ; TGSMGateStateOut#ggso_Conf1
 WRX  State
#debug_left usint State
#srcline 585 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 586 ;          ELSE
 JMP  SMS_HANDLER_2_L142
SMS_HANDLER_2_L141:
#srcline 587 ;            State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 588 ;            Error := gger_Cfg_Error;
 LD   udint 4  ; TGSMGateError#gger_Cfg_Error
 WRX  Error
#debug_left usint Error
#srcline 589 ;          END_IF;
SMS_HANDLER_2_L142:
 JMP  SMS_HANDLER_2_L94
SMS_HANDLER_2_L140:
 LD   10
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_2_L143
#srcline 590 ;        ggso_Center:
#srcline 591 ;          IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_2_L144
#srcline 592 ;            State := ggso_EraseQuery;
 LD   udint 11  ; TGSMGateStateOut#ggso_EraseQuery
 WRX  State
#debug_left usint State
#srcline 593 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 594 ;          ELSE
 JMP  SMS_HANDLER_2_L145
SMS_HANDLER_2_L144:
#srcline 595 ;            State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 596 ;            Error := gger_SMS_Center_Error;
 LD   udint 6  ; TGSMGateError#gger_SMS_Center_Error
 WRX  Error
#debug_left usint Error
#srcline 597 ;          END_IF;
SMS_HANDLER_2_L145:
 JMP  SMS_HANDLER_2_L94
SMS_HANDLER_2_L143:
 LD   12
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_2_L146
#srcline 598 ;        ggso_Erase:
#srcline 599 ;          IF Counter < MessagesCnt THEN
 LDX  Counter
#debug usint Counter
 LDX  MessagesCnt
#debug usint MessagesCnt
 LT
 JMC  SMS_HANDLER_2_L147
#srcline 600 ;            IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_2_L149
#srcline 601 ;              Counter := Counter+1;
 LDX  Counter
#debug usint Counter
 LD   usint 1
 ADD
 AND  $FF
 WRX  Counter
#debug_left usint Counter
#srcline 602 ;              MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 603 ;            ELSE
 JMP  SMS_HANDLER_2_L150
SMS_HANDLER_2_L149:
#srcline 604 ;              State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 605 ;              Error := gger_Erase_Failed;
 LD   udint 5  ; TGSMGateError#gger_Erase_Failed
 WRX  Error
#debug_left usint Error
#srcline 606 ;            END_IF;
SMS_HANDLER_2_L150:
#srcline 607 ;          ELSE
 JMP  SMS_HANDLER_2_L148
SMS_HANDLER_2_L147:
#srcline 608 ;            State := ggso_SignalQ;
 LD   udint 20  ; TGSMGateStateOut#ggso_SignalQ
 WRX  State
#debug_left usint State
#srcline 609 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 610 ;          END_IF;
SMS_HANDLER_2_L148:
 JMP  SMS_HANDLER_2_L94
SMS_HANDLER_2_L146:
 LD   13
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_2_L151
#srcline 611 ;        ggso_EraseOne:
#srcline 612 ;          IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_2_L152
#srcline 613 ;            Counter := Counter+1;
 LDX  Counter
#debug usint Counter
 LD   usint 1
 ADD
 AND  $FF
 WRX  Counter
#debug_left usint Counter
#srcline 614 ;            IF SendPending THEN
 LDX  SendPending
#debug bool SendPending
 JMC  SMS_HANDLER_2_L154
#srcline 615 ;              State := ggso_Send;
 LD   udint 18  ; TGSMGateStateOut#ggso_Send
 WRX  State
#debug_left usint State
#srcline 616 ;            ELSIF UssdPending THEN
 JMP  SMS_HANDLER_2_L155
SMS_HANDLER_2_L154:
 LDX  UssdPending
#debug bool UssdPending
 JMC  SMS_HANDLER_2_L156
#srcline 617 ;              State := ggso_Ussd;
 LD   udint 19  ; TGSMGateStateOut#ggso_Ussd
 WRX  State
#debug_left usint State
#srcline 618 ;            ELSE
 JMP  SMS_HANDLER_2_L155
SMS_HANDLER_2_L156:
#srcline 619 ;              State := ggso_Read;
 LD   udint 15  ; TGSMGateStateOut#ggso_Read
 WRX  State
#debug_left usint State
#srcline 620 ;            END_IF;
SMS_HANDLER_2_L155:
#srcline 621 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 622 ;          ELSE
 JMP  SMS_HANDLER_2_L153
SMS_HANDLER_2_L152:
#srcline 623 ;            State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 624 ;            Error := gger_Erase_Failed;
 LD   udint 5  ; TGSMGateError#gger_Erase_Failed
 WRX  Error
#debug_left usint Error
#srcline 625 ;          END_IF;
SMS_HANDLER_2_L153:
 JMP  SMS_HANDLER_2_L94
SMS_HANDLER_2_L151:
 LD   18
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_2_L157
#srcline 626 ;        ggso_Send:
#srcline 627 ;          IF BuferIN[0] = 62 THEN //'>'
 LDX  BuferIN[0]
#debug usint BuferIN[0]
 LD   usint 62
 EQ
 JMC  SMS_HANDLER_2_L158
#srcline 628 ;            State := ggso_SendText;
 LD   udint 17  ; TGSMGateStateOut#ggso_SendText
 WRX  State
#debug_left usint State
#srcline 629 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 630 ;          ELSE
 JMP  SMS_HANDLER_2_L159
SMS_HANDLER_2_L158:
#srcline 631 ;            State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 632 ;            Error := gger_Sending_failed;
 LD   udint 9  ; TGSMGateError#gger_Sending_failed
 WRX  Error
#debug_left usint Error
#srcline 633 ;          END_IF;
SMS_HANDLER_2_L159:
 JMP  SMS_HANDLER_2_L94
SMS_HANDLER_2_L157:
 LD   17
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_2_L160
#srcline 634 ;        ggso_SendText:
#srcline 635 ;          IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_2_L161
#srcline 636 ;            SendPending := 0;
 LD   bool 0       ; false
 WRX  SendPending
#debug_left bool SendPending
#srcline 637 ;            State := ggso_SignalQ;
 LD   udint 20  ; TGSMGateStateOut#ggso_SignalQ
 WRX  State
#debug_left usint State
#srcline 638 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 639 ;          ELSE
 JMP  SMS_HANDLER_2_L162
SMS_HANDLER_2_L161:
#srcline 640 ;            IF FIND(pBuferIN^, _GsmLib_AtReplyCMGS) > 0 THEN
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_AtReplyCMGS
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_2_L163
#srcline 641 ;              pstring := ADR(BuferIN[7]);
 LEAX BuferIN
 ADD  7  ; + offset 
#debug pointer BuferIN[7]
 LEAY pstring
 WRIL 
#debug_left pointer pstring
#srcline 642 ;              SmsRef  := STRING_TO_USINT(pstring^);
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 SCNV $3008;  IEC_STRING _TO_ IEC_USINT
 WRX  SmsRef
#debug_left usint SmsRef
#srcline 643 ;            ELSIF BuferIN[0] <> 62 THEN
 JMP  SMS_HANDLER_2_L164
SMS_HANDLER_2_L163:
 LDX  BuferIN[0]
#debug usint BuferIN[0]
 LD   usint 62
 EQ
 NEG
 JMC  SMS_HANDLER_2_L165
#srcline 644 ;              State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 645 ;              Error := gger_Sending_failed;
 LD   udint 9  ; TGSMGateError#gger_Sending_failed
 WRX  Error
#debug_left usint Error
#srcline 646 ;            END_IF;
 JMP  SMS_HANDLER_2_L164
SMS_HANDLER_2_L165:
SMS_HANDLER_2_L164:
#srcline 647 ;          END_IF;
SMS_HANDLER_2_L162:
 JMP  SMS_HANDLER_2_L94
SMS_HANDLER_2_L160:
 LD   19
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_2_L166
#srcline 648 ;        ggso_Ussd:
#srcline 649 ;          //TODO: *#06#
#srcline 650 ;          IF FIND(pBuferIN^, _GsmLib_AtReplyCUSD) > 0 THEN
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_AtReplyCUSD
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_2_L167
#srcline 651 ;            pos := FIND(pBuferIN^, _GsmLib_QuoteString);
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_QuoteString
 SFND 
 WRY  pos
#debug_left int pos
#srcline 652 ;            IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_2_L169
#srcline 653 ;              pstring := ADR(BuferIN) + INT_TO_UDINT(pos);
 LEAX BuferIN
#debug pointer BuferIN
 LDY  pos
#debug int pos
 EXTW 
 ADD
 LEAY pstring
 WRIL 
#debug_left pointer pstring
#srcline 654 ;              pos := FIND(pstring^, _GsmLib_QuoteString);
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 LEA  _GsmLib_QuoteString
 SFND 
 WRY  pos
#debug_left int pos
#srcline 655 ;              IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_2_L171
#srcline 656 ;                RecvMess  := LEFT(IN := pstring^, L := pos-1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   160
 DST    ; Level 1
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 LDY  pos
#debug int pos
 EXTW 
 LD   int 1
 SUB
 EXTW
 SLFT 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  RecvMess
 WRI  
 LDX  RecvMess
 LD   160
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string RecvMess
 PDST   ; Level 1
#srcline 657 ;                NewMess   := true;
 LD   bool -1       ; true
 WRX  NewMess
#debug_left bool NewMess
#srcline 658 ;                RecvTime := LREAL_TO_DATE_AND_TIME(0.0) ;
 LDQ  lreal 0.0
 WRX  RecvTime
#debug_left dt RecvTime
#srcline 659 ;                Sender   := l_USSD;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   20
 DST    ; Level 1
 LEAX l_USSD
#debug string l_USSD
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  Sender
 WRI  
 LDX  Sender
 LD   20
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string Sender
 PDST   ; Level 1
#srcline 660 ;                State    := ggso_SignalQ;
 LD   udint 20  ; TGSMGateStateOut#ggso_SignalQ
 WRX  State
#debug_left usint State
#srcline 661 ;                MessOut  := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 662 ;                UssdPending := false;
 LD   bool 0       ; false
 WRX  UssdPending
#debug_left bool UssdPending
#srcline 663 ;              END_IF;
SMS_HANDLER_2_L171:
#srcline 664 ;            END_IF;
SMS_HANDLER_2_L169:
#srcline 665 ;          ELSIF not ok THEN
 JMP  SMS_HANDLER_2_L168
SMS_HANDLER_2_L167:
 LDX  ok
#debug bool ok
 NEG
 JMC  SMS_HANDLER_2_L173
#srcline 666 ;            State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 667 ;            Error := gger_USSD_Not_Executed;
 LD   udint 19  ; TGSMGateError#gger_USSD_Not_Executed
 WRX  Error
#debug_left usint Error
#srcline 668 ;          END_IF;
 JMP  SMS_HANDLER_2_L168
SMS_HANDLER_2_L173:
SMS_HANDLER_2_L168:
 JMP  SMS_HANDLER_2_L94
SMS_HANDLER_2_L166:
 LD   15
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_2_L174
#srcline 669 ;        ggso_Read:
#srcline 670 ;          IF FIND(pBuferIN^, _GsmLib_AtReplyCMGR) > 0 THEN
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_AtReplyCMGR
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_2_L175
#srcline 671 ;            ReadErrs := 0;
 LD   usint 0
 WRX  ReadErrs
#debug_left usint ReadErrs
#srcline 672 ;            MaxReadErrs := 2;
 LD   usint 2
 WRX  MaxReadErrs
#debug_left usint MaxReadErrs
#srcline 673 ;            pos := FIND(pBuferIN^, _GsmLib_CommaString);
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_CommaString
 SFND 
 WRY  pos
#debug_left int pos
#srcline 674 ;            IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_2_L177
#srcline 675 ;              pstring := ADR(BuferIN) + INT_TO_UDINT(pos) + 1;
 LEAX BuferIN
#debug pointer BuferIN
 LDY  pos
#debug int pos
 EXTW 
 ADD
 LD   udint 1
 ADD
 LEAY pstring
 WRIL 
#debug_left pointer pstring
#srcline 676 ;              OctetCnt := STRING_TO_USINT(pstring^);
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 SCNV $3008;  IEC_STRING _TO_ IEC_USINT
 WRX  OctetCnt
#debug_left usint OctetCnt
#srcline 677 ;              IF OctetCnt > 0 THEN
 LDX  OctetCnt
#debug usint OctetCnt
 LD   usint 0
 GT
 JMC  SMS_HANDLER_2_L179
#srcline 678 ;                State := ggso_ReadOctets;
 LD   udint 25  ; TGSMGateStateOut#ggso_ReadOctets
 WRX  State
#debug_left usint State
#srcline 679 ;              ELSE
 JMP  SMS_HANDLER_2_L180
SMS_HANDLER_2_L179:
#srcline 680 ;                State := ggso_ReadOk;
 LD   udint 16  ; TGSMGateStateOut#ggso_ReadOk
 WRX  State
#debug_left usint State
#srcline 681 ;              END_IF;
SMS_HANDLER_2_L180:
#srcline 682 ;            END_IF;
SMS_HANDLER_2_L177:
#srcline 683 ;          ELSIF FIND(pBuferIN^, _GsmLib_AtReplyERROR) > 0 THEN
 JMP  SMS_HANDLER_2_L176
SMS_HANDLER_2_L175:
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_AtReplyERROR
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_2_L181
#srcline 684 ;            ReadErrs := ReadErrs + 1;
 LDX  ReadErrs
#debug usint ReadErrs
 LD   usint 1
 ADD
 AND  $FF
 WRX  ReadErrs
#debug_left usint ReadErrs
#srcline 685 ;            IF ReadErrs < MaxReadErrs THEN
 LDX  ReadErrs
#debug usint ReadErrs
 LDX  MaxReadErrs
#debug usint MaxReadErrs
 LT
 JMC  SMS_HANDLER_2_L182
#srcline 686 ;              State := ggso_SignalQ;
 LD   udint 20  ; TGSMGateStateOut#ggso_SignalQ
 WRX  State
#debug_left usint State
#srcline 687 ;              MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 688 ;            ELSE
 JMP  SMS_HANDLER_2_L183
SMS_HANDLER_2_L182:
#srcline 689 ;              State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 690 ;              Error := gger_Receiving_failed;
 LD   udint 10  ; TGSMGateError#gger_Receiving_failed
 WRX  Error
#debug_left usint Error
#srcline 691 ;            END_IF;
SMS_HANDLER_2_L183:
#srcline 692 ;          END_IF;
 JMP  SMS_HANDLER_2_L176
SMS_HANDLER_2_L181:
SMS_HANDLER_2_L176:
 JMP  SMS_HANDLER_2_L94
SMS_HANDLER_2_L174:
 LD   25
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_2_L184
#srcline 693 ;        ggso_ReadOctets:
#srcline 694 ;          pusint  := ADR(RecvMess);
 LDX  RecvMess
#debug pointer RecvMess
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 695 ;          pusint^  := 0;              //clear recvmess
 LD   usint 0
 LEAY pusint
 LDIL    ; dereference 
 WRI 
#debug_left usint pusint^
#srcline 696 ;          pusint  := ADR(BuferIN);
 LEAX BuferIN
#debug pointer BuferIN
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 697 ;          lenNum := BYTE_TO_USINT(_GsmLib_HEX_TO_BYTE(pusint));
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LEA  __Instance___GsmLib_HEX_TO_BYTE~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_HEX_TO_BYTE~HEX
 PRV
 LEA  __Instance___GsmLib_HEX_TO_BYTE
 CAL  _GsmLib_HEX_TO_BYTE_L0
 WRY  lenNum
#debug_left usint lenNum
#srcline 698 ;          IF lenNum > 0 THEN
 LDY  lenNum
#debug usint lenNum
 LD   usint 0
 GT
 JMC  SMS_HANDLER_2_L185
#srcline 699 ;            typNum := _GsmLib_HEX_TO_BYTE(pusint+2);
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LD   udint 2
 ADD
 LEA  __Instance___GsmLib_HEX_TO_BYTE~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_HEX_TO_BYTE~HEX
 PRV
 LEA  __Instance___GsmLib_HEX_TO_BYTE
 CAL  _GsmLib_HEX_TO_BYTE_L0
 WRY  typNum
#debug_left byte typNum
#srcline 700 ;            pusint  := pusint + 4 + USINT_TO_UDINT(_GsmLib_DecodeSemiOctetsNumber(pusint+4, (lenNum-1)*2, l_SMSCenter));
 LEAY pusint
 LDIL 
#debug pointer pusint
 LD   udint 4
 ADD
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LD   udint 4
 ADD
 LEA  __Instance___GsmLib_DecodeSemiOctetsNumber~IN
 WRIL 
#debug_left udint __Instance___GsmLib_DecodeSemiOctetsNumber~IN
 LDY  lenNum
#debug usint lenNum
 LD   usint 1
 SUB
 AND  $FF
 LD   usint 2
 MUL
 AND  $FF
 WR   __Instance___GsmLib_DecodeSemiOctetsNumber~LNG
#debug_left usint __Instance___GsmLib_DecodeSemiOctetsNumber~LNG
 LEAX l_SMSCenter
 WR   __Instance___GsmLib_DecodeSemiOctetsNumber~Num
#debug_left pointer __Instance___GsmLib_DecodeSemiOctetsNumber.Num
 PRV
 LEA  __Instance___GsmLib_DecodeSemiOctetsNumber
 CAL  _GsmLib_DecodeSemiOctetsNumber_L0
 ADD
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 701 ;            IF typNum.4 THEN
 LDY  typNum.4
#debug bool typNum.4
 JMC  SMS_HANDLER_2_L187
#srcline 702 ;              l_SMSCenter := _GsmLib_PlusString + l_SMSCenter;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   20
 DST    ; Level 1
 LEA  _GsmLib_PlusString
 SCON 
 LEAX l_SMSCenter
#debug string l_SMSCenter
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX l_SMSCenter
 WRI  
 LEAX l_SMSCenter
 LD   20
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string l_SMSCenter
 PDST   ; Level 1
#srcline 703 ;            END_IF;
SMS_HANDLER_2_L187:
#srcline 704 ;          ELSE
 JMP  SMS_HANDLER_2_L186
SMS_HANDLER_2_L185:
#srcline 705 ;            pusint  := pusint + 2;
 LEAY pusint
 LDIL 
#debug pointer pusint
 LD   udint 2
 ADD
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 706 ;          END_IF;
SMS_HANDLER_2_L186:
#srcline 707 ;          StatTime := LREAL_TO_DATE_AND_TIME(0.0);
 LDQ  lreal 0.0
 WRX  StatTime
#debug_left dt StatTime
#srcline 708 ;          RecvTime := LREAL_TO_DATE_AND_TIME(0.0);
 LDQ  lreal 0.0
 WRX  RecvTime
#debug_left dt RecvTime
#srcline 709 ;          firstOctet := _GsmLib_HEX_TO_BYTE(pusint);
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LEA  __Instance___GsmLib_HEX_TO_BYTE~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_HEX_TO_BYTE~HEX
 PRV
 LEA  __Instance___GsmLib_HEX_TO_BYTE
 CAL  _GsmLib_HEX_TO_BYTE_L0
 WRY  firstOctet
#debug_left byte firstOctet
#srcline 710 ;          IF firstOctet <> 16#FF THEN
 LDY  firstOctet
#debug byte firstOctet
 LD   byte $FF
 EQ
 NEG
 JMC  SMS_HANDLER_2_L189
#srcline 711 ;            MessStat := firstOctet.1;
 LDY  firstOctet.1
#debug bool firstOctet.1
 WRX  MessStat
#debug_left bool MessStat
#srcline 712 ;            IF firstOctet.0 OR firstOctet.1 THEN //firstOctet AND 3 > 0 THEN
 LDY  firstOctet.0
#debug bool firstOctet.0
 LDY  firstOctet.1
#debug bool firstOctet.1
 OR  
 JMC  SMS_HANDLER_2_L191
#srcline 713 ;              //SMS STATUS REPORT OR SMS SUBMIT
#srcline 714 ;              pusint   := pusint + 2;
 LEAY pusint
 LDIL 
#debug pointer pusint
 LD   udint 2
 ADD
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 715 ;              SmsRef   := BYTE_TO_USINT(_GsmLib_HEX_TO_BYTE(pusint));
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LEA  __Instance___GsmLib_HEX_TO_BYTE~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_HEX_TO_BYTE~HEX
 PRV
 LEA  __Instance___GsmLib_HEX_TO_BYTE
 CAL  _GsmLib_HEX_TO_BYTE_L0
 WRX  SmsRef
#debug_left usint SmsRef
#srcline 716 ;            ELSE
 JMP  SMS_HANDLER_2_L192
SMS_HANDLER_2_L191:
#srcline 717 ;              //SMS STATUS DELIVERY
#srcline 718 ;              SmsRef := 0;
 LD   usint 0
 WRX  SmsRef
#debug_left usint SmsRef
#srcline 719 ;            END_IF;
SMS_HANDLER_2_L192:
#srcline 720 ;            pusint := pusint + 2;
 LEAY pusint
 LDIL 
#debug pointer pusint
 LD   udint 2
 ADD
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 721 ;            lenNum := BYTE_TO_USINT(_GsmLib_HEX_TO_BYTE(pusint));
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LEA  __Instance___GsmLib_HEX_TO_BYTE~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_HEX_TO_BYTE~HEX
 PRV
 LEA  __Instance___GsmLib_HEX_TO_BYTE
 CAL  _GsmLib_HEX_TO_BYTE_L0
 WRY  lenNum
#debug_left usint lenNum
#srcline 722 ;            typNum := _GsmLib_HEX_TO_BYTE(pusint+2);
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LD   udint 2
 ADD
 LEA  __Instance___GsmLib_HEX_TO_BYTE~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_HEX_TO_BYTE~HEX
 PRV
 LEA  __Instance___GsmLib_HEX_TO_BYTE
 CAL  _GsmLib_HEX_TO_BYTE_L0
 WRY  typNum
#debug_left byte typNum
#srcline 723 ;            pusint := pusint + 4 + USINT_TO_UDINT(_GsmLib_DecodeSemiOctetsNumber(pusint+4, lenNum, Sender));
 LEAY pusint
 LDIL 
#debug pointer pusint
 LD   udint 4
 ADD
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LD   udint 4
 ADD
 LEA  __Instance___GsmLib_DecodeSemiOctetsNumber~IN
 WRIL 
#debug_left udint __Instance___GsmLib_DecodeSemiOctetsNumber~IN
 LDY  lenNum
#debug usint lenNum
 WR   __Instance___GsmLib_DecodeSemiOctetsNumber~LNG
#debug_left usint __Instance___GsmLib_DecodeSemiOctetsNumber~LNG
 LDX  Sender
 WR   __Instance___GsmLib_DecodeSemiOctetsNumber~Num
#debug_left pointer __Instance___GsmLib_DecodeSemiOctetsNumber.Num
 PRV
 LEA  __Instance___GsmLib_DecodeSemiOctetsNumber
 CAL  _GsmLib_DecodeSemiOctetsNumber_L0
 ADD
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 724 ;            IF typNum.4 THEN
 LDY  typNum.4
#debug bool typNum.4
 JMC  SMS_HANDLER_2_L193
#srcline 725 ;              Sender := _GsmLib_PlusString + Sender;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   20
 DST    ; Level 1
 LEA  _GsmLib_PlusString
 SCON 
 LDX  Sender
#debug string Sender
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  Sender
 WRI  
 LDX  Sender
 LD   20
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string Sender
 PDST   ; Level 1
#srcline 726 ;            END_IF;
SMS_HANDLER_2_L193:
#srcline 727 ;            IF NOT firstOctet.1 THEN
 LDY  firstOctet.1
#debug bool firstOctet.1
 NEG
 JMC  SMS_HANDLER_2_L195
#srcline 728 ;              //NOT SMS STATUS
#srcline 729 ;              protId   := _GsmLib_HEX_TO_BYTE(pusint);
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LEA  __Instance___GsmLib_HEX_TO_BYTE~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_HEX_TO_BYTE~HEX
 PRV
 LEA  __Instance___GsmLib_HEX_TO_BYTE
 CAL  _GsmLib_HEX_TO_BYTE_L0
 WRY  protId
#debug_left byte protId
#srcline 730 ;              dataCode := _GsmLib_HEX_TO_BYTE(pusint+2);
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LD   udint 2
 ADD
 LEA  __Instance___GsmLib_HEX_TO_BYTE~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_HEX_TO_BYTE~HEX
 PRV
 LEA  __Instance___GsmLib_HEX_TO_BYTE
 CAL  _GsmLib_HEX_TO_BYTE_L0
 WRY  dataCode
#debug_left byte dataCode
#srcline 731 ;              pusint   := pusint + 4;
 LEAY pusint
 LDIL 
#debug pointer pusint
 LD   udint 4
 ADD
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 732 ;            END_IF;
SMS_HANDLER_2_L195:
#srcline 733 ;            RecvTime := _GsmLib_GetGSMDateTime(pusint);
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LEA  __Instance___GsmLib_GetGSMDateTime~pGSMDT
 WRIL 
#debug_left udint __Instance___GsmLib_GetGSMDateTime~pGSMDT
 PRV
 LEA  __Instance___GsmLib_GetGSMDateTime
 CAL  _GsmLib_GetGSMDateTime_L0
 WRX  RecvTime
#debug_left dt RecvTime
#srcline 734 ;            IF DT_TO_LREAL(RecvTime) = 0.0 THEN
 LDX  RecvTime
#debug dt RecvTime
 LDQ  lreal 0.0
 EQDF
 JMC  SMS_HANDLER_2_L197
#srcline 735 ;              pusint := pusint + 2;
 LEAY pusint
 LDIL 
#debug pointer pusint
 LD   udint 2
 ADD
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 736 ;            ELSE
 JMP  SMS_HANDLER_2_L198
SMS_HANDLER_2_L197:
#srcline 737 ;              pusint := pusint + 14;
 LEAY pusint
 LDIL 
#debug pointer pusint
 LD   udint 14
 ADD
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 738 ;            END_IF;
SMS_HANDLER_2_L198:
#srcline 739 ;            IF firstOctet.1 THEN
 LDY  firstOctet.1
#debug bool firstOctet.1
 JMC  SMS_HANDLER_2_L199
#srcline 740 ;              //SMS STATUS
#srcline 741 ;              StatTime := _GsmLib_GetGSMDateTime(pusint);
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LEA  __Instance___GsmLib_GetGSMDateTime~pGSMDT
 WRIL 
#debug_left udint __Instance___GsmLib_GetGSMDateTime~pGSMDT
 PRV
 LEA  __Instance___GsmLib_GetGSMDateTime
 CAL  _GsmLib_GetGSMDateTime_L0
 WRX  StatTime
#debug_left dt StatTime
#srcline 742 ;              IF DT_TO_LREAL(StatTime) = 0.0 THEN
 LDX  StatTime
#debug dt StatTime
 LDQ  lreal 0.0
 EQDF
 JMC  SMS_HANDLER_2_L201
#srcline 743 ;                pusint := pusint + 2;
 LEAY pusint
 LDIL 
#debug pointer pusint
 LD   udint 2
 ADD
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 744 ;              ELSE
 JMP  SMS_HANDLER_2_L202
SMS_HANDLER_2_L201:
#srcline 745 ;                pusint := pusint + 14;
 LEAY pusint
 LDIL 
#debug pointer pusint
 LD   udint 14
 ADD
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 746 ;              END_IF;
SMS_HANDLER_2_L202:
#srcline 747 ;              MessStatCode := BYTE_TO_USINT(_GsmLib_HEX_TO_BYTE(pusint));
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LEA  __Instance___GsmLib_HEX_TO_BYTE~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_HEX_TO_BYTE~HEX
 PRV
 LEA  __Instance___GsmLib_HEX_TO_BYTE
 CAL  _GsmLib_HEX_TO_BYTE_L0
 WRX  MessStatCode
#debug_left usint MessStatCode
#srcline 748 ;            ELSE
 JMP  SMS_HANDLER_2_L200
SMS_HANDLER_2_L199:
#srcline 749 ;              StatTime  := REAL_TO_DT(0.0);
 LD   real 0.0
 FDF
 WRX  StatTime
#debug_left dt StatTime
#srcline 750 ;              tusint    := BYTE_TO_USINT(_GsmLib_HEX_TO_BYTE(pusint));
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LEA  __Instance___GsmLib_HEX_TO_BYTE~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_HEX_TO_BYTE~HEX
 PRV
 LEA  __Instance___GsmLib_HEX_TO_BYTE
 CAL  _GsmLib_HEX_TO_BYTE_L0
 WRY  tusint
#debug_left usint tusint
#srcline 751 ;              pusint    := pusint + 2;
 LEAY pusint
 LDIL 
#debug pointer pusint
 LD   udint 2
 ADD
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 752 ;              IF firstOctet.6 THEN
 LDY  firstOctet.6
#debug bool firstOctet.6
 JMC  SMS_HANDLER_2_L203
#srcline 753 ;                lenUserHead := 1 + BYTE_TO_USINT(_GsmLib_HEX_TO_BYTE(pusint));
 LD   usint 1
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LEA  __Instance___GsmLib_HEX_TO_BYTE~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_HEX_TO_BYTE~HEX
 PRV
 LEA  __Instance___GsmLib_HEX_TO_BYTE
 CAL  _GsmLib_HEX_TO_BYTE_L0
 ADD
 AND  $FF
 WRY  lenUserHead
#debug_left usint lenUserHead
#srcline 754 ;              ELSE
 JMP  SMS_HANDLER_2_L204
SMS_HANDLER_2_L203:
#srcline 755 ;                lenUserHead := 0;
 LD   usint 0
 WRY  lenUserHead
#debug_left usint lenUserHead
#srcline 756 ;              END_IF;
SMS_HANDLER_2_L204:
#srcline 757 ;              IF dataCode.3 THEN
 LDY  dataCode.3
#debug bool dataCode.3
 JMC  SMS_HANDLER_2_L205
#srcline 758 ;                tusint := _GsmLib_Decode16bitHEX(HEX := pusint, N := tusint, U := lenuserhead, Text := RecvMess);
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LEA  __Instance___GsmLib_Decode16bitHEX~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_Decode16bitHEX~HEX
 LDY  tusint
#debug usint tusint
 WR   __Instance___GsmLib_Decode16bitHEX~N
#debug_left usint __Instance___GsmLib_Decode16bitHEX~N
 LDY  lenuserhead
#debug usint lenuserhead
 WR   __Instance___GsmLib_Decode16bitHEX~U
#debug_left usint __Instance___GsmLib_Decode16bitHEX~U
 LDX  RecvMess
 WR   __Instance___GsmLib_Decode16bitHEX~Text
#debug_left pointer __Instance___GsmLib_Decode16bitHEX.Text
 PRV
 LEA  __Instance___GsmLib_Decode16bitHEX
 CAL  _GsmLib_Decode16bitHEX_L0
 WRY  tusint
#debug_left usint tusint
#srcline 759 ;              ELSIF dataCode.2 THEN
 JMP  SMS_HANDLER_2_L206
SMS_HANDLER_2_L205:
 LDY  dataCode.2
#debug bool dataCode.2
 JMC  SMS_HANDLER_2_L207
#srcline 760 ;                tusint := _GsmLib_Decode8bitHEX(HEX := pusint, N := tusint, U := lenuserhead, Text := RecvMess);
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LEA  __Instance___GsmLib_Decode8bitHEX~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_Decode8bitHEX~HEX
 LDY  tusint
#debug usint tusint
 WR   __Instance___GsmLib_Decode8bitHEX~N
#debug_left usint __Instance___GsmLib_Decode8bitHEX~N
 LDY  lenuserhead
#debug usint lenuserhead
 WR   __Instance___GsmLib_Decode8bitHEX~U
#debug_left usint __Instance___GsmLib_Decode8bitHEX~U
 LDX  RecvMess
 WR   __Instance___GsmLib_Decode8bitHEX~Text
#debug_left pointer __Instance___GsmLib_Decode8bitHEX.Text
 PRV
 LEA  __Instance___GsmLib_Decode8bitHEX
 CAL  _GsmLib_Decode8bitHEX_L0
 WRY  tusint
#debug_left usint tusint
#srcline 761 ;              ELSE
 JMP  SMS_HANDLER_2_L206
SMS_HANDLER_2_L207:
#srcline 762 ;                tusint := _GsmLib_Decode7bitHEX(HEX := pusint, N := tusint, U := lenuserhead, Text := RecvMess);
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LEA  __Instance___GsmLib_Decode7bitHEX~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_Decode7bitHEX~HEX
 LDY  tusint
#debug usint tusint
 WR   __Instance___GsmLib_Decode7bitHEX~N
#debug_left usint __Instance___GsmLib_Decode7bitHEX~N
 LDY  lenuserhead
#debug usint lenuserhead
 WR   __Instance___GsmLib_Decode7bitHEX~U
#debug_left usint __Instance___GsmLib_Decode7bitHEX~U
 LDX  RecvMess
 WR   __Instance___GsmLib_Decode7bitHEX~Text
#debug_left pointer __Instance___GsmLib_Decode7bitHEX.Text
 PRV
 LEA  __Instance___GsmLib_Decode7bitHEX
 CAL  _GsmLib_Decode7bitHEX_L0
 WRY  tusint
#debug_left usint tusint
#srcline 763 ;              END_IF;
SMS_HANDLER_2_L206:
#srcline 764 ;            END_IF;
SMS_HANDLER_2_L200:
#srcline 765 ;          END_IF;
SMS_HANDLER_2_L189:
#srcline 766 ;          State := ggso_ReadOk;
 LD   udint 16  ; TGSMGateStateOut#ggso_ReadOk
 WRX  State
#debug_left usint State
 JMP  SMS_HANDLER_2_L94
SMS_HANDLER_2_L184:
 LD   16
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_2_L208
#srcline 767 ;        ggso_ReadOk:
#srcline 768 ;          IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_2_L209
#srcline 769 ;            InitDone := true;
 LD   bool -1       ; true
 WRX  InitDone
#debug_left bool InitDone
#srcline 770 ;            IF OctetCnt > 0 THEN
 LDX  OctetCnt
#debug usint OctetCnt
 LD   usint 0
 GT
 JMC  SMS_HANDLER_2_L211
#srcline 771 ;              NewMess := NOT MessStat;
 LDX  MessStat
#debug bool MessStat
 NEG
 WRX  NewMess
#debug_left bool NewMess
#srcline 772 ;              NewStat := MessStat;
 LDX  MessStat
#debug bool MessStat
 WRX  NewStat
#debug_left bool NewStat
#srcline 773 ;              IF NewStat THEN
 LDX  NewStat
#debug bool NewStat
 JMC  SMS_HANDLER_2_L213
#srcline 774 ;                pusint := ADR(StatCode);
 LEAX StatCode
#debug pointer StatCode
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 775 ;                CASE MessStatCode OF
 LDX  MessStatCode
#debug usint MessStatCode
 WRY  P4__st__
 LDY  P4__st__
 LD   $02
 GT  
 JMD SMS_HANDLER_2_L216
 LDY  P4__st__
 LD   $00
 LT  
 JMD SMS_HANDLER_2_L216
#srcline 776 ;                  16#00..16#02 :
#srcline 777 ;                    pusint^ := MessStatCode + 1;
 LDX  MessStatCode
#debug usint MessStatCode
 LD   usint 1
 ADD
 AND  $FF
 LEAY pusint
 LDIL    ; dereference 
 WRI 
#debug_left usint pusint^
 JMP  SMS_HANDLER_2_L215
SMS_HANDLER_2_L216:
 LDY  P4__st__
 LD   $25
 GT  
 JMD SMS_HANDLER_2_L217
 LDY  P4__st__
 LD   $20
 LT  
 JMD SMS_HANDLER_2_L217
#srcline 778 ;                  16#20..16#25 :
#srcline 779 ;                    pusint^ := MessStatCode - 16#1D; // + 4 - 16#20
 LDX  MessStatCode
#debug usint MessStatCode
 LD   usint $1D
 SUB
 AND  $FF
 LEAY pusint
 LDIL    ; dereference 
 WRI 
#debug_left usint pusint^
 JMP  SMS_HANDLER_2_L215
SMS_HANDLER_2_L217:
 LDY  P4__st__
 LD   $49
 GT  
 JMD SMS_HANDLER_2_L218
 LDY  P4__st__
 LD   $40
 LT  
 JMD SMS_HANDLER_2_L218
#srcline 780 ;                  16#40..16#49 :
#srcline 781 ;                    pusint^ := MessStatCode - 16#36; // + 10 - 16#40
 LDX  MessStatCode
#debug usint MessStatCode
 LD   usint $36
 SUB
 AND  $FF
 LEAY pusint
 LDIL    ; dereference 
 WRI 
#debug_left usint pusint^
 JMP  SMS_HANDLER_2_L215
SMS_HANDLER_2_L218:
#srcline 782 ;                ELSE
#srcline 783 ;                  StatCode     := ggss_Unknown;
 LD   udint 0  ; TGSMGateSmsStatus#ggss_Unknown
 WRX  StatCode
#debug_left usint StatCode
#srcline 784 ;                END_CASE;
SMS_HANDLER_2_L215:
#srcline 785 ;              ELSE
 JMP  SMS_HANDLER_2_L214
SMS_HANDLER_2_L213:
#srcline 786 ;                StatCode     := ggss_Unknown;
 LD   udint 0  ; TGSMGateSmsStatus#ggss_Unknown
 WRX  StatCode
#debug_left usint StatCode
#srcline 787 ;              END_IF;
SMS_HANDLER_2_L214:
#srcline 788 ;              State := ggso_EraseOne;
 LD   udint 13  ; TGSMGateStateOut#ggso_EraseOne
 WRX  State
#debug_left usint State
#srcline 789 ;              MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 790 ;            ELSIF SendPending THEN
 JMP  SMS_HANDLER_2_L212
SMS_HANDLER_2_L211:
 LDX  SendPending
#debug bool SendPending
 JMC  SMS_HANDLER_2_L219
#srcline 791 ;              State := ggso_Send;
 LD   udint 18  ; TGSMGateStateOut#ggso_Send
 WRX  State
#debug_left usint State
#srcline 792 ;            ELSIF UssdPending THEN
 JMP  SMS_HANDLER_2_L212
SMS_HANDLER_2_L219:
 LDX  UssdPending
#debug bool UssdPending
 JMC  SMS_HANDLER_2_L220
#srcline 793 ;              State := ggso_Ussd;
 LD   udint 19  ; TGSMGateStateOut#ggso_Ussd
 WRX  State
#debug_left usint State
#srcline 794 ;            ELSIF DialPending THEN
 JMP  SMS_HANDLER_2_L212
SMS_HANDLER_2_L220:
 LDX  DialPending
#debug bool DialPending
 JMC  SMS_HANDLER_2_L221
#srcline 795 ;              State := ggso_Ringing;
 LD   udint 22  ; TGSMGateStateOut#ggso_Ringing
 WRX  State
#debug_left usint State
#srcline 796 ;              TimeOut.PT := DialTime;
 LDX  DialTime
#debug time DialTime
 WRX  TimeOut~PT
#debug_left time TimeOut.PT
#srcline 797 ;            ELSE
 JMP  SMS_HANDLER_2_L212
SMS_HANDLER_2_L221:
#srcline 798 ;              IF Counter < MessagesCnt THEN
 LDX  Counter
#debug usint Counter
 LDX  MessagesCnt
#debug usint MessagesCnt
 LT
 JMC  SMS_HANDLER_2_L222
#srcline 799 ;                State   := ggso_Read;
 LD   udint 15  ; TGSMGateStateOut#ggso_Read
 WRX  State
#debug_left usint State
#srcline 800 ;                Counter := Counter + 1;
 LDX  Counter
#debug usint Counter
 LD   usint 1
 ADD
 AND  $FF
 WRX  Counter
#debug_left usint Counter
#srcline 801 ;              ELSE //all memory slots read
 JMP  SMS_HANDLER_2_L223
SMS_HANDLER_2_L222:
#srcline 802 ;                State := ggso_SignalQ;
 LD   udint 20  ; TGSMGateStateOut#ggso_SignalQ
 WRX  State
#debug_left usint State
#srcline 803 ;              END_IF;
SMS_HANDLER_2_L223:
#srcline 804 ;            END_IF;
SMS_HANDLER_2_L212:
#srcline 805 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 806 ;          ELSE
 JMP  SMS_HANDLER_2_L210
SMS_HANDLER_2_L209:
#srcline 807 ;            State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 808 ;            Error := gger_Receiving_failed;
 LD   udint 10  ; TGSMGateError#gger_Receiving_failed
 WRX  Error
#debug_left usint Error
#srcline 809 ;          END_IF;
SMS_HANDLER_2_L210:
 JMP  SMS_HANDLER_2_L94
SMS_HANDLER_2_L208:
 LD   20
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_2_L224
#srcline 810 ;        ggso_SignalQ:
#srcline 811 ;          IF FIND(pBuferIN^, _GsmLib_AtReplyCSQ) > 0 THEN
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_AtReplyCSQ
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_2_L225
#srcline 812 ;            pstring := ADR(BuferIN[6]);
 LEAX BuferIN
 ADD  6  ; + offset 
#debug pointer BuferIN[6]
 LEAY pstring
 WRIL 
#debug_left pointer pstring
#srcline 813 ;            tusint := STRING_TO_USINT(pstring^);
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 SCNV $3008;  IEC_STRING _TO_ IEC_USINT
 WRY  tusint
#debug_left usint tusint
#srcline 814 ;            IF tusint = 99 THEN
 LDY  tusint
#debug usint tusint
 LD   usint 99
 EQ
 JMC  SMS_HANDLER_2_L227
#srcline 815 ;              Signal := -1;
 LD   sint -1
 WRX  Signal
#debug_left sint Signal
#srcline 816 ;            ELSE
 JMP  SMS_HANDLER_2_L228
SMS_HANDLER_2_L227:
#srcline 817 ;              Signal := UDINT_TO_SINT((USINT_TO_UDINT(tusint)*100)/31);
 LDY  tusint
#debug usint tusint
 LD   udint 100
 MUL
 LD   udint 31
 DIVL
 EXTB
 WRX  Signal
#debug_left sint Signal
#srcline 818 ;            END_IF;
SMS_HANDLER_2_L228:
#srcline 819 ;          END_IF;
SMS_HANDLER_2_L225:
#srcline 820 ;          State := ggso_ReadQuery; //and again
 LD   udint 14  ; TGSMGateStateOut#ggso_ReadQuery
 WRX  State
#debug_left usint State
 JMP  SMS_HANDLER_2_L94
SMS_HANDLER_2_L224:
 LD   21
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_2_L229
#srcline 821 ;        ggso_RingNumber:
#srcline 822 ;          Ring := true;
 LD   bool -1       ; true
 WRX  Ring
#debug_left bool Ring
#srcline 823 ;          RingCount := 1;
 LD   usint 1
 WRX  RingCount
#debug_left usint RingCount
#srcline 824 ;          IF FIND(pBuferIN^, _GsmLib_AtReplyCLCC) > 0 THEN
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_AtReplyCLCC
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_2_L230
#srcline 825 ;            pos := FIND(pBuferIN^, _GsmLib_QuoteString);
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_QuoteString
 SFND 
 WRY  pos
#debug_left int pos
#srcline 826 ;            IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_2_L232
#srcline 827 ;              pstring := ADR(BuferIN) + INT_TO_UDINT(pos);
 LEAX BuferIN
#debug pointer BuferIN
 LDY  pos
#debug int pos
 EXTW 
 ADD
 LEAY pstring
 WRIL 
#debug_left pointer pstring
#srcline 828 ;              pos := FIND(pstring^, _GsmLib_QuoteString);
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 LEA  _GsmLib_QuoteString
 SFND 
 WRY  pos
#debug_left int pos
#srcline 829 ;              IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_2_L234
#srcline 830 ;                Caller := LEFT(pstring^, Pos-1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   20
 DST    ; Level 1
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 LDY  Pos
#debug int Pos
 EXTW 
 LD   int 1
 SUB
 EXTW
 SLFT 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  Caller
 WRI  
 LDX  Caller
 LD   20
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string Caller
 PDST   ; Level 1
#srcline 831 ;              END_IF;
SMS_HANDLER_2_L234:
#srcline 832 ;            END_IF;
SMS_HANDLER_2_L232:
#srcline 833 ;          END_IF;
SMS_HANDLER_2_L230:
#srcline 834 ;          WaitTime.PT := T#5.5s;    //timeout to cancel call
 LD   time 5500
 WRX  WaitTime~PT
#debug_left time WaitTime.PT
#srcline 835 ;          IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_2_L236
#srcline 836 ;            State := ggso_CancelCall; //cancel call
 LD   udint 23  ; TGSMGateStateOut#ggso_CancelCall
 WRX  State
#debug_left usint State
#srcline 837 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 838 ;          END_IF;
SMS_HANDLER_2_L236:
 JMP  SMS_HANDLER_2_L94
SMS_HANDLER_2_L229:
 LD   22
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_2_L238
#srcline 839 ;        ggso_Ringing:
#srcline 840 ;          (*
#srcline 841 ;          IF FIND(pBuferIN^, _GsmLib_AtReplyNOCARRIER) > 0 OR FIND(pBuferIN^, _GsmLib_AtReplyERROR) > 0 THEN
#srcline 842 ;            State := ggso_Error;
#srcline 843 ;            Error := gger_Dialing_Failed;
#srcline 844 ;          END_IF;
#srcline 845 ;          IF ok THEN
#srcline 846 ;            State := ggso_CancelCall;
#srcline 847 ;            MessOut := true;
#srcline 848 ;          END_IF;
#srcline 849 ;          *)
#srcline 850 ;        ggso_CancelCall:
 JMP  SMS_HANDLER_2_L94
SMS_HANDLER_2_L238:
 LD   23
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_2_L239
#srcline 851 ;          State := ggso_ReadQuery; //and again
 LD   udint 14  ; TGSMGateStateOut#ggso_ReadQuery
 WRX  State
#debug_left usint State
#srcline 852 ;          DialPending := false;
 LD   bool 0       ; false
 WRX  DialPending
#debug_left bool DialPending
 JMP  SMS_HANDLER_2_L94
SMS_HANDLER_2_L239:
SMS_HANDLER_2_L94:
#srcline 854 ;    END_IF;
SMS_HANDLER_2_L93:
#srcline 855 ;  END_IF;
SMS_HANDLER_2_L82:
#srcline 857 ;  IF State = ggso_Error THEN
 LDX  State
#debug usint State
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 EQ
 JMC  SMS_HANDLER_2_L240
#srcline 858 ;    pos := FIND(pBuferIN^, _GsmLib_AtReplyERROR);
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_AtReplyERROR
 SFND 
 WRY  pos
#debug_left int pos
#srcline 859 ;    IF pos  > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_2_L242
#srcline 860 ;      datalen := RecvFrom.lenMess - 2;
 LDX  RecvFrom~lenMess
#debug uint RecvFrom.lenMess
 LD   uint 2
 SUB
 AND  $FFFF
 WRY  datalen
#debug_left uint datalen
#srcline 861 ;      pUsint  := ADR(BuferIN) + UINT_TO_UDINT(datalen);
 LEAX BuferIN
#debug pointer BuferIN
 LDY  datalen
#debug uint datalen
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 862 ;      pusint^ := 0;
 LD   usint 0
 LEAY pusint
 LDIL    ; dereference 
 WRI 
#debug_left usint pusint^
#srcline 863 ;      pstring := ADR(BuferIN) + INT_TO_UDINT(pos) - 1;
 LEAX BuferIN
#debug pointer BuferIN
 LDY  pos
#debug int pos
 EXTW 
 ADD
 LD   udint 1
 SUB
 LEAY pstring
 WRIL 
#debug_left pointer pstring
#srcline 864 ;      RecvMess := pstring^;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   160
 DST    ; Level 1
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  RecvMess
 WRI  
 LDX  RecvMess
 LD   160
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string RecvMess
 PDST   ; Level 1
#srcline 865 ;      pusint^ := 13;
 LD   usint 13
 LEAY pusint
 LDIL    ; dereference 
 WRI 
#debug_left usint pusint^
#srcline 866 ;    END_IF;
SMS_HANDLER_2_L242:
#srcline 867 ;  END_IF;
SMS_HANDLER_2_L240:
#srcline 869 ;  //debug
#srcline 870 ;  //Stop := true;
#srcline 871 ;  (**)
#srcline 872 ;END_FUNCTION_BLOCK
SMS_HANDLER_2_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
SMS_HANDLER_2__InstanceInit__:
 LINK 0
 LD   time 20000
 WRX  DialTime
 LD   sint -1
 WRX  Signal
 LD   bool -1   ; true
 WRX  MessOut
 LD   bool -1   ; true
 WRX  ColdRestart
 LEAX RecvFrom
 CAL  fbRecvToCrLf__InstanceInit__
 LEAX SendTo
 CAL  fbSendTo__InstanceInit__
 LD   udint $FFFFFFFF    ; nil
 WRX  pusintdbg
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'D:\TECOLIB\GSM_LIBRARYX2\GSMLIBCONTROL\SMS_HANDLER3.ST'
#pou SMS_HANDLER_3
#srcline 1 ;FUNCTION_BLOCK SMS_HANDLER_3

#struct SMS_HANDLER_3__temp__
  bool NewMessage,
  int pos,
  uint datalen,
  usint lenNum,
  byte typNum,
  byte protId,
  byte dataCode,
  byte firstOctet,
  usint lenUserHead,
  usint ChanError,
  usint tusint,
  usint indx,
  pointer pusint,
  pointer pstring,
  pointer pBuferIN,
  TUniDesc UniDesc,
  usint P0__st__,
  usint P1__st__,
  usint P2__st__,
  usint P3__st__,
  udint P4__st__,
  string[162] PS0__st__,
  string[257] PSC__st__
P     61
SMS_HANDLER_3_L0:
 LINK __SizeOf(SMS_HANDLER_3__temp__)
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  pusint
 LD   udint $FFFFFFFF    ; nil
 WRY  pstring
 LD   udint $FFFFFFFF    ; nil
 WRY  pBuferIN
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  Send
 LETX __EDGE_R__Send
 WRX  Send
 LDX  Ussd
 LETX __EDGE_R__Ussd
 WRX  Ussd
 LDX  Reset
 LETX __EDGE_R__Reset
 WRX  Reset
 LDX  Dial
 LETX __EDGE_R__Dial
 WRX  Dial
#srcline 104 ;  UniDesc := GetChanDesc(chanCode := chanCode) ;
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetChanDesc~chanCode
#debug_left uint __Instance__GetChanDesc~chanCode
 PRV
 LEA  __Instance__GetChanDesc
 CAL  GetChanDesc_L0
 LEAY UniDesc
#debug_left pointer UniDesc
 LD   26   ;SizeOf() 
 MOV  %IB0
#srcline 106 ;  IF UniDesc.modeChan <> 5 THEN
 LDY  UniDesc~modeChan
#debug byte UniDesc.modeChan
 LD   byte 5
 EQ
 NEG
 JMC  SMS_HANDLER_3_L1
#srcline 107 ;    State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 108 ;    Error := gger_Wrong_channel_mode;
 LD   udint 13  ; TGSMGateError#gger_Wrong_channel_mode
 WRX  Error
#debug_left usint Error
#srcline 109 ;    RETURN;
 JMP  SMS_HANDLER_3_RET
#srcline 110 ;  ELSE
 JMP  SMS_HANDLER_3_L2
SMS_HANDLER_3_L1:
#srcline 111 ;    IF UniDesc.lenUniIn < 380 THEN
 LDY  UniDesc~lenUniIn
#debug uint UniDesc.lenUniIn
 LD   uint 380
 LT
 JMC  SMS_HANDLER_3_L3
#srcline 112 ;      Error := gger_ZoneIn_is_short;
 LD   udint 14  ; TGSMGateError#gger_ZoneIn_is_short
 WRX  Error
#debug_left usint Error
#srcline 113 ;      RETURN;
 JMP  SMS_HANDLER_3_RET
#srcline 114 ;    END_IF;
SMS_HANDLER_3_L3:
#srcline 115 ;    IF UniDesc.lenUniOut < 360 THEN
 LDY  UniDesc~lenUniOut
#debug uint UniDesc.lenUniOut
 LD   uint 360
 LT
 JMC  SMS_HANDLER_3_L5
#srcline 116 ;      Error := gger_ZoneOut_is_short;
 LD   udint 15  ; TGSMGateError#gger_ZoneOut_is_short
 WRX  Error
#debug_left usint Error
#srcline 117 ;      RETURN;
 JMP  SMS_HANDLER_3_RET
#srcline 118 ;    END_IF;
SMS_HANDLER_3_L5:
#srcline 119 ;  END_IF;
SMS_HANDLER_3_L2:
#srcline 121 ;  NewMess := 0; //clear new SMS flag
 LD   bool 0       ; false
 WRX  NewMess
#debug_left bool NewMess
#srcline 122 ;  NewStat := 0; //clear new SMS status flag
 LD   bool 0       ; false
 WRX  NewStat
#debug_left bool NewStat
#srcline 124 ;  RecvFrom(getMess := NOT Stop, lenBuf := 512, chanCode := ChanCode, buffer := BuferIN[0],
 LDX  Stop
#debug bool Stop
 NEG
 WRX  RecvFrom~getMess
#debug_left bool RecvFrom~getMess
 LD   uint 512
 WRX  RecvFrom~lenBuf
#debug_left uint RecvFrom~lenBuf
 LDX  ChanCode
#debug uint ChanCode
 WRX  RecvFrom~chanCode
#debug_left uint RecvFrom~chanCode
 LEAX BuferIN
 WRX  RecvFrom~buffer
#debug_left pointer RecvFrom.buffer
#srcline 125 ;           reset := Reset OR TimeOut.Q);
 LDX  Reset
#debug bool Reset
 LDX  TimeOut~Q
#debug bool TimeOut.Q
 OR  
 WRX  RecvFrom~reset
#debug_left bool RecvFrom~reset
 LEAX RecvFrom
 CAL  fbRecvToCrLf_L0
#srcline 126 ;           
#srcline 127 ;  NewMessage := RecvFrom.lenMess > 2 OR BuferIN[0] = 62; //62 = '>'
 LDX  RecvFrom~lenMess
#debug uint RecvFrom.lenMess
 LD   uint 2
 GT
 LDX  BuferIN[0]
#debug usint BuferIN[0]
 LD   usint 62
 EQ
 OR  
 WRY  NewMessage
#debug_left bool NewMessage
#srcline 129 ;  IF Stop THEN return; END_IF;
 LDX  Stop
#debug bool Stop
 JMC  SMS_HANDLER_3_L7
 JMP  SMS_HANDLER_3_RET
SMS_HANDLER_3_L7:
#srcline 131 ;  (* //debug
#srcline 132 ;  IF WaitTime.Q THEN
#srcline 133 ;    pusint := ADR(TextIn);
#srcline 134 ;    pusint^ := 0;
#srcline 135 ;  END_IF;
#srcline 136 ;  IF NewMessage THEN
#srcline 138 ;    pusint := ADR(TextIn) + UINT_TO_UDINT(datalen);
#srcline 139 ;    pusint^ := 0;
#srcline 140 ;  END_IF;
#srcline 141 ;  (* *)
#srcline 142 ;  
#srcline 143 ;  //timeout settings
#srcline 144 ;  IF State <> ggso_Ringing THEN
 LDX  State
#debug usint State
 LD   udint 22  ; TGSMGateStateOut#ggso_Ringing
 EQ
 NEG
 JMC  SMS_HANDLER_3_L9
#srcline 145 ;    IF SendPending OR UssdPending OR State = ggso_Reset THEN
 LDX  SendPending
#debug bool SendPending
 LDX  UssdPending
#debug bool UssdPending
 OR  
 LDX  State
#debug usint State
 LD   udint 2  ; TGSMGateStateOut#ggso_Reset
 EQ
 OR  
 JMC  SMS_HANDLER_3_L11
#srcline 146 ;      TimeOut.PT := longtimeout;
 LD   time 10000
 WRX  TimeOut~PT
#debug_left time TimeOut.PT
#srcline 147 ;    ELSE
 JMP  SMS_HANDLER_3_L12
SMS_HANDLER_3_L11:
#srcline 148 ;      TimeOut.PT := shorttimeout;
 LD   time 5000
 WRX  TimeOut~PT
#debug_left time TimeOut.PT
#srcline 149 ;    END_IF;
SMS_HANDLER_3_L12:
#srcline 150 ;  END_IF;
SMS_HANDLER_3_L9:
#srcline 152 ;  TimeOut(IN := NOT NewMessage & NOT MessOut & NOT WaitTime.Q & NOT HardErr);
 LDY  NewMessage
#debug bool NewMessage
 NEG
 LDX  MessOut
#debug bool MessOut
 NEG
 AND
 LDX  WaitTime~Q
#debug bool WaitTime.Q
 NEG
 AND
 LDX  HardErr
#debug bool HardErr
 NEG
 AND
 WRX  TimeOut~IN
#debug_left bool TimeOut~IN
 LEAX TimeOut
 CAL  TON_L0
#srcline 154 ;  //cancel call after timeout
#srcline 155 ;  IF TimeOut.Q AND State = ggso_Ringing THEN
 LDX  TimeOut~Q
#debug bool TimeOut.Q
 LDX  State
#debug usint State
 LD   udint 22  ; TGSMGateStateOut#ggso_Ringing
 EQ
 AND
 JMC  SMS_HANDLER_3_L13
#srcline 156 ;    TimeOut(IN := false);       //reset timeout
 LD   bool 0       ; false
 WRX  TimeOut~IN
#debug_left bool TimeOut~IN
 LEAX TimeOut
 CAL  TON_L0
#srcline 157 ;    State := ggso_CancelCall;
 LD   udint 23  ; TGSMGateStateOut#ggso_CancelCall
 WRX  State
#debug_left usint State
#srcline 158 ;    MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 159 ;  END_IF;
SMS_HANDLER_3_L13:
#srcline 161 ;  //reset
#srcline 162 ;  IF Reset OR TimeOut.Q THEN
 LDX  Reset
#debug bool Reset
 LDX  TimeOut~Q
#debug bool TimeOut.Q
 OR  
 JMC  SMS_HANDLER_3_L15
#srcline 163 ;    pusint := ADR(RecvMess);
 LDX  RecvMess
#debug pointer RecvMess
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 164 ;    pusintdbg := pusint;
 LEAY pusint
 LDIL 
#debug pointer pusint
 LEAX pusintdbg
 WRIL 
#debug_left pointer pusintdbg
#srcline 165 ;    pusint^ := 0;
 LD   usint 0
 LEAY pusint
 LDIL    ; dereference 
 WRI 
#debug_left usint pusint^
#srcline 166 ;    WaitForOk := false;
 LD   bool 0       ; false
 WRX  WaitForOk
#debug_left bool WaitForOk
#srcline 167 ;    InitDone  := false;
 LD   bool 0       ; false
 WRX  InitDone
#debug_left bool InitDone
#srcline 168 ;    Ring      := false;
 LD   bool 0       ; false
 WRX  Ring
#debug_left bool Ring
#srcline 169 ;    HardErr   := false;
 LD   bool 0       ; false
 WRX  HardErr
#debug_left bool HardErr
#srcline 170 ;    ColdRestart := Cold;
 LDX  Cold
#debug bool Cold
 WRX  ColdRestart
#debug_left bool ColdRestart
#srcline 171 ;    SendPending := false;
 LD   bool 0       ; false
 WRX  SendPending
#debug_left bool SendPending
#srcline 172 ;    UssdPending := false;
 LD   bool 0       ; false
 WRX  UssdPending
#debug_left bool UssdPending
#srcline 173 ;    DialPending := false;
 LD   bool 0       ; false
 WRX  DialPending
#debug_left bool DialPending
#srcline 174 ;    State := ggso_Init;
 LD   udint 0  ; TGSMGateStateOut#ggso_Init
 WRX  State
#debug_left usint State
#srcline 175 ;    MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 176 ;    Error := gger_None;
 LD   udint 0  ; TGSMGateError#gger_None
 WRX  Error
#debug_left usint Error
#srcline 177 ;    ReadErrs := 0;
 LD   usint 0
 WRX  ReadErrs
#debug_left usint ReadErrs
#srcline 178 ;    RingCount := 0;    
 LD   usint 0
 WRX  RingCount
#debug_left usint RingCount
#srcline 179 ;  END_IF;
SMS_HANDLER_3_L15:
#srcline 181 ;  //store request to send SMS
#srcline 182 ;  IF Send THEN
 LDX  Send
#debug bool Send
 JMC  SMS_HANDLER_3_L17
#srcline 183 ;    SendPending    := true;
 LD   bool -1       ; true
 WRX  SendPending
#debug_left bool SendPending
#srcline 184 ;    l_Stat         := Stat;
 LDX  Stat
#debug bool Stat
 WRX  l_Stat
#debug_left bool l_Stat
#srcline 185 ;    l_Recipient    := Recipient;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   20
 DST    ; Level 1
 LDX  Recipient
#debug string Recipient
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX l_Recipient
 WRI  
 LEAX l_Recipient
 LD   20
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string l_Recipient
 PDST   ; Level 1
#srcline 186 ;    Memcpy(length := USINT_TO_UINT(MessLen), source := MessToSend, dest := l_MessToSend[0]);
 NXT
 LDX  MessLen
#debug usint MessLen
 AND  $FFFF
 WR   __Instance__Memcpy~length
#debug_left uint __Instance__Memcpy~length
 LDX  MessToSend
 WR   __Instance__Memcpy~source
#debug_left pointer __Instance__Memcpy.source
 LEAX l_MessToSend
 WR   __Instance__Memcpy~dest
#debug_left pointer __Instance__Memcpy.dest
 PRV
 LEA  __Instance__Memcpy
 CAL  Memcpy_L0
#srcline 187 ;  END_IF;
SMS_HANDLER_3_L17:
#srcline 189 ;  //store request to send USSD
#srcline 190 ;  IF Ussd THEN
 LDX  Ussd
#debug bool Ussd
 JMC  SMS_HANDLER_3_L19
#srcline 191 ;    UssdPending := true;
 LD   bool -1       ; true
 WRX  UssdPending
#debug_left bool UssdPending
#srcline 192 ;    l_USSD := Recipient;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   20
 DST    ; Level 1
 LDX  Recipient
#debug string Recipient
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX l_USSD
 WRI  
 LEAX l_USSD
 LD   20
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string l_USSD
 PDST   ; Level 1
#srcline 193 ;  END_IF;
SMS_HANDLER_3_L19:
#srcline 195 ;  //set flag when dialing number
#srcline 196 ;  IF Ready AND Dial THEN
 LDX  Ready
#debug bool Ready
 LDX  Dial
#debug bool Dial
 AND
 JMC  SMS_HANDLER_3_L21
#srcline 197 ;    IF State <> ggso_Ringing THEN
 LDX  State
#debug usint State
 LD   udint 22  ; TGSMGateStateOut#ggso_Ringing
 EQ
 NEG
 JMC  SMS_HANDLER_3_L23
#srcline 198 ;      DialPending := true;
 LD   bool -1       ; true
 WRX  DialPending
#debug_left bool DialPending
#srcline 199 ;    END_IF;
SMS_HANDLER_3_L23:
#srcline 200 ;  END_IF;
SMS_HANDLER_3_L21:
#srcline 202 ;  //pusint := ADR(State); //pointer to state variable for numeric comparations
#srcline 204 ;  //set GSM gateway ready flag
#srcline 205 ;  Ready := InitDone & Error = gger_None & NOT SendPending & NOT UssdPending & NOT DialPending & NOT Ring & Signal <> -1;
 LDX  InitDone
#debug bool InitDone
 LDX  Error
#debug usint Error
 LD   udint 0  ; TGSMGateError#gger_None
 EQ
 AND
 LDX  SendPending
#debug bool SendPending
 NEG
 AND
 LDX  UssdPending
#debug bool UssdPending
 NEG
 AND
 LDX  DialPending
#debug bool DialPending
 NEG
 AND
 LDX  Ring
#debug bool Ring
 NEG
 AND
 LDX  Signal
#debug sint Signal
 EXTB 
 LD   sint -1
 EQ
 NEG
 AND
 WRX  Ready
#debug_left bool Ready
#srcline 207 ;  //quasi-states
#srcline 208 ;  CASE State OF
 LDX  State
#debug usint State
 WRY  P0__st__
 LD   11
 LDY  P0__st__
 EQ  
 JMC  SMS_HANDLER_3_L26
#srcline 209 ;    ggso_EraseQuery:
#srcline 210 ;      Counter := 1;
 LD   usint 1
 WRX  Counter
#debug_left usint Counter
#srcline 211 ;      IF Erase & NeedErase THEN
 LDX  Erase
#debug bool Erase
 LDX  NeedErase
#debug bool NeedErase
 AND
 JMC  SMS_HANDLER_3_L27
#srcline 212 ;        State := ggso_Erase;
 LD   udint 12  ; TGSMGateStateOut#ggso_Erase
 WRX  State
#debug_left usint State
#srcline 213 ;      ELSE
 JMP  SMS_HANDLER_3_L28
SMS_HANDLER_3_L27:
#srcline 214 ;        State := ggso_SignalQ;
 LD   udint 20  ; TGSMGateStateOut#ggso_SignalQ
 WRX  State
#debug_left usint State
#srcline 215 ;      END_IF;
SMS_HANDLER_3_L28:
#srcline 216 ;      MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
 JMP  SMS_HANDLER_3_L25
SMS_HANDLER_3_L26:
 LD   14
 LDY  P0__st__
 EQ  
 JMC  SMS_HANDLER_3_L29
#srcline 217 ;    ggso_ReadQuery:
#srcline 218 ;      WaitTime.PT := Pause1;
 LD   time 500
 WRX  WaitTime~PT
#debug_left time WaitTime.PT
#srcline 219 ;      Counter := 1;
 LD   usint 1
 WRX  Counter
#debug_left usint Counter
#srcline 220 ;      State := ggso_Read;
 LD   udint 15  ; TGSMGateStateOut#ggso_Read
 WRX  State
#debug_left usint State
#srcline 221 ;      MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
 JMP  SMS_HANDLER_3_L25
SMS_HANDLER_3_L29:
SMS_HANDLER_3_L25:
#srcline 224 ;  //transmiting
#srcline 225 ;  WaitTime(IN := MessOut); //timeout between recieve and transmit
 LDX  MessOut
#debug bool MessOut
 WRX  WaitTime~IN
#debug_left bool WaitTime~IN
 LEAX WaitTime
 CAL  TON_L0
#srcline 226 ;  IF WaitTime.Q THEN
 LDX  WaitTime~Q
#debug bool WaitTime.Q
 JMC  SMS_HANDLER_3_L30
#srcline 227 ;    //states
#srcline 228 ;    CASE State OF
 LDX  State
#debug usint State
 WRY  P1__st__
 LD   0
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_3_L33
#srcline 229 ;      ggso_Init :
#srcline 230 ;        WaitTime.PT := Pause1;
 LD   time 500
 WRX  WaitTime~PT
#debug_left time WaitTime.PT
#srcline 231 ;        ReadErrs := 0;
 LD   usint 0
 WRX  ReadErrs
#debug_left usint ReadErrs
#srcline 232 ;        Signal := -1;
 LD   sint -1
 WRX  Signal
#debug_left sint Signal
 JMP  SMS_HANDLER_3_L32
SMS_HANDLER_3_L33:
 LD   1
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_3_L34
#srcline 233 ;        {ASM}
#srcline 234
          #macro initstring3(DES, SRC, LEN)
#srcline 235
          LD   0   ; null string
#srcline 236
          WRX  DES
#srcline 237
          LEAX DES
#srcline 238
          LD   LEN
#srcline 239
          DST    ; Level 1
#srcline 240
          LEA  SRC
#srcline 241
          SCON
#srcline 242
          PDST ;level 1
#srcline 243
          #endm
#srcline 244
          initstring3(DataOUT, __Init_____GsmLib_AtCommandATE0, 32)
#srcline 245 ;        {END_ASM}
#srcline 246 ;        
#srcline 247 ;        //DataOUT := _GsmLib_AtCommandATE0;
#srcline 249 ;      ggso_BaudRate:
#srcline 250 ;        {ASM}
#srcline 251
        initstring3(DataOUT, __Init_____GsmLib_AtCommandATIPR, 32)
#srcline 252 ;        {END_ASM}
#srcline 253 ;        //DataOUT := _GsmLib_AtCommandATIPR;
#srcline 254 ;      ggso_Reset:
 JMP  SMS_HANDLER_3_L32
SMS_HANDLER_3_L34:
 LD   2
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_3_L35
#srcline 255 ;        {ASM}
#srcline 256
        initstring3(DataOUT, __Init_____GsmLib_AtCommandATCFUN, 32)
#srcline 257 ;        {END_ASM}
#srcline 258 ;        //DataOUT := _GsmLib_AtCommandATCFUN;
#srcline 259 ;      ggso_Pin:
 JMP  SMS_HANDLER_3_L32
SMS_HANDLER_3_L35:
 LD   3
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_3_L36
#srcline 260 ;        {ASM}
#srcline 261
        initstring3(DataOUT, __Init_____GsmLib_AtCommandATCPIN1, 32)
#srcline 262 ;        {END_ASM}
#srcline 263 ;        //DataOUT := _GsmLib_AtCommandATCPIN1;
#srcline 264 ;      ggso_PinValue:
 JMP  SMS_HANDLER_3_L32
SMS_HANDLER_3_L36:
 LD   4
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_3_L37
#srcline 265 ;        IF LEN(IN := Pin) > 0 THEN
 LDX  Pin
#debug string Pin
 SLEN 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_3_L38
#srcline 266 ;          DataOUT := CONCAT(_GsmLib_AtCommandATCPIN2,Pin,_GsmLib_CrLfString);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   32
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATCPIN2
 SCON
 LDX  Pin
#debug string Pin
 SCON
 LEA  _GsmLib_CrLfString

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX DataOUT
 WRI  
 LEAX DataOUT
 LD   32
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string DataOUT
 PDST   ; Level 1
#srcline 267 ;        ELSE
 JMP  SMS_HANDLER_3_L39
SMS_HANDLER_3_L38:
#srcline 268 ;          State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 269 ;          Error := gger_No_Pin;
 LD   udint 1  ; TGSMGateError#gger_No_Pin
 WRX  Error
#debug_left usint Error
#srcline 270 ;        END_IF;
SMS_HANDLER_3_L39:
 JMP  SMS_HANDLER_3_L32
SMS_HANDLER_3_L37:
 LD   5
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_3_L40
#srcline 271 ;      ggso_Conf1:
#srcline 272 ;        {ASM}
#srcline 273
        initstring3(DataOUT, __Init_____GsmLib_AtCommandATCMEE, 32)
#srcline 274 ;        {END_ASM}
#srcline 275 ;        //DataOUT := _GsmLib_AtCommandATCMEE;
#srcline 276 ;      ggso_Conf2:
 JMP  SMS_HANDLER_3_L32
SMS_HANDLER_3_L40:
 LD   6
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_3_L41
#srcline 277 ;        {ASM}
#srcline 278
        initstring3(DataOUT, __Init_____GsmLib_AtCommandATCMGF0, 32)
#srcline 279 ;        {END_ASM}
#srcline 280 ;        //DataOUT := _GsmLib_AtCommandATCMGF0;
#srcline 281 ;      ggso_Conf3:
 JMP  SMS_HANDLER_3_L32
SMS_HANDLER_3_L41:
 LD   7
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_3_L42
#srcline 282 ;        {ASM}
#srcline 283
        initstring3(DataOUT, __Init_____GsmLib_AtCommandATCNMI, 32)
#srcline 284 ;        {END_ASM}
#srcline 285 ;        //DataOUT := _GsmLib_AtCommandATCNMI;
#srcline 286 ;      ggso_Conf4:
 JMP  SMS_HANDLER_3_L32
SMS_HANDLER_3_L42:
 LD   8
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_3_L43
#srcline 287 ;        {ASM}
#srcline 288
        initstring3(DataOUT, __Init_____GsmLib_AtCommandATCPMS, 32)
#srcline 289 ;        {END_ASM}
#srcline 290 ;        //DataOUT := _GsmLib_AtCommandATCPMS;
#srcline 291 ;      ggso_Conf5:
 JMP  SMS_HANDLER_3_L32
SMS_HANDLER_3_L43:
 LD   9
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_3_L44
#srcline 292 ;        {ASM}
#srcline 293
        initstring3(DataOUT, __Init_____GsmLib_AtCommandATSSMSS, 32)
#srcline 294 ;        {END_ASM}
#srcline 295 ;        //DataOUT := _GsmLib_AtCommandATSSMSS;
#srcline 296 ;      ggso_Center:
 JMP  SMS_HANDLER_3_L32
SMS_HANDLER_3_L44:
 LD   10
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_3_L45
#srcline 297 ;        IF LEN(SMSCenter) > 0 THEN
 LDX  SMSCenter
#debug string SMSCenter
 SLEN 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_3_L46
#srcline 298 ;          DataOUT := CONCAT(_GsmLib_AtCommandATCSCA,SMSCenter,_GsmLib_QuoteCrLfString);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   32
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATCSCA
 SCON
 LDX  SMSCenter
#debug string SMSCenter
 SCON
 LEA  _GsmLib_QuoteCrLfString

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX DataOUT
 WRI  
 LEAX DataOUT
 LD   32
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string DataOUT
 PDST   ; Level 1
#srcline 299 ;        ELSE
 JMP  SMS_HANDLER_3_L47
SMS_HANDLER_3_L46:
#srcline 300 ;          State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 301 ;          Error := gger_No_Center_Number;
 LD   udint 7  ; TGSMGateError#gger_No_Center_Number
 WRX  Error
#debug_left usint Error
#srcline 302 ;        END_IF;
SMS_HANDLER_3_L47:
 JMP  SMS_HANDLER_3_L32
SMS_HANDLER_3_L45:
 LD   12
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_3_L48
#srcline 303 ;      ggso_Erase:
#srcline 304 ;        {$IFDEF DO_NOT_ERASE}
#srcline 305 ;        DataOUT := _GsmLib_AtCommandATE0;
#srcline 306 ;        {$ELSE}
#srcline 307 ;        DataOUT := _GsmLib_AtCommandATCMGD + USINT_TO_STRING(Counter) + _GsmLib_CrLfString;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   32
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATCMGD
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   32
 DST    ; Level 2
 LDX  Counter
#debug usint Counter
 SCNV $0830;  IEC_USINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 LEA  _GsmLib_CrLfString
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX DataOUT
 WRI  
 LEAX DataOUT
 LD   32
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string DataOUT
 PDST   ; Level 1
 JMP  SMS_HANDLER_3_L32
SMS_HANDLER_3_L48:
 LD   19
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_3_L49
#srcline 308 ;        {$END_IF}
#srcline 309 ;      ggso_Ussd:
#srcline 310 ;        IF LEN(IN := l_USSD) > 0 THEN
 LEAX l_USSD
#debug string l_USSD
 SLEN 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_3_L50
#srcline 311 ;          DataOUT := CONCAT(_GsmLib_AtCommandATD,l_USSD,_GsmLib_SemiColonCrLfString);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   32
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATD
 SCON
 LEAX l_USSD
#debug string l_USSD
 SCON
 LEA  _GsmLib_SemiColonCrLfString

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX DataOUT
 WRI  
 LEAX DataOUT
 LD   32
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string DataOUT
 PDST   ; Level 1
#srcline 312 ;        ELSE
 JMP  SMS_HANDLER_3_L51
SMS_HANDLER_3_L50:
#srcline 313 ;          State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 314 ;          Error := gger_No_Recipient_Number;
 LD   udint 8  ; TGSMGateError#gger_No_Recipient_Number
 WRX  Error
#debug_left usint Error
#srcline 315 ;        END_IF;
SMS_HANDLER_3_L51:
 JMP  SMS_HANDLER_3_L32
SMS_HANDLER_3_L49:
 LD   18
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_3_L52
#srcline 316 ;      ggso_Send:
#srcline 317 ;        IF LEN(IN := l_Recipient) = 0 THEN
 LEAX l_Recipient
#debug string l_Recipient
 SLEN 
 LD   int 0
 EQ
 JMC  SMS_HANDLER_3_L53
#srcline 318 ;          State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 319 ;          Error := gger_No_Recipient_Number;
 LD   udint 8  ; TGSMGateError#gger_No_Recipient_Number
 WRX  Error
#debug_left usint Error
#srcline 320 ;        ELSIF MessLen = 0 THEN
 JMP  SMS_HANDLER_3_L54
SMS_HANDLER_3_L53:
 LDX  MessLen
#debug usint MessLen
 LD   usint 0
 EQ
 JMC  SMS_HANDLER_3_L55
#srcline 321 ;          State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 322 ;          Error := gger_Empty_Message_Text;
 LD   udint 16  ; TGSMGateError#gger_Empty_Message_Text
 WRX  Error
#debug_left usint Error
#srcline 323 ;        ELSE
 JMP  SMS_HANDLER_3_L54
SMS_HANDLER_3_L55:
#srcline 324 ;          SmsRef := 0;
 LD   usint 0
 WRX  SmsRef
#debug_left usint SmsRef
#srcline 325 ;          pusint := ADR(l_Recipient);
 LEAX l_Recipient
#debug pointer l_Recipient
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 326 ;          BuferOUT[0] := 16#3030; //00
 LD   word $3030
 WRX  BuferOUT[0]
#debug_left word BuferOUT[0]
#srcline 327 ;          IF l_Stat  THEN
 LDX  l_Stat
#debug bool l_Stat
 JMC  SMS_HANDLER_3_L56
#srcline 328 ;            BuferOUT[1] := _GsmLib_BYTE_TO_HEX(2#0010_0001);
 NXT
 LD   byte 33
 WR   __Instance___GsmLib_BYTE_TO_HEX~B
#debug_left byte __Instance___GsmLib_BYTE_TO_HEX~B
 PRV
 LEA  __Instance___GsmLib_BYTE_TO_HEX
 CAL  _GsmLib_BYTE_TO_HEX_L0
 WRX  BuferOUT[1]
#debug_left word BuferOUT[1]
#srcline 329 ;          ELSE
 JMP  SMS_HANDLER_3_L57
SMS_HANDLER_3_L56:
#srcline 330 ;            BuferOUT[1] := _GsmLib_BYTE_TO_HEX(2#0000_0001);
 NXT
 LD   byte 1
 WR   __Instance___GsmLib_BYTE_TO_HEX~B
#debug_left byte __Instance___GsmLib_BYTE_TO_HEX~B
 PRV
 LEA  __Instance___GsmLib_BYTE_TO_HEX
 CAL  _GsmLib_BYTE_TO_HEX_L0
 WRX  BuferOUT[1]
#debug_left word BuferOUT[1]
#srcline 331 ;          END_IF;
SMS_HANDLER_3_L57:
#srcline 332 ;          BuferOUT[2] := 16#3030; //00
 LD   word $3030
 WRX  BuferOUT[2]
#debug_left word BuferOUT[2]
#srcline 333 ;          IF pusint^ = 43 THEN      //'+'
 LEAY pusint
 LDIL    ; dereference 
 LDI  
#debug usint pusint^
 LD   usint 43
 EQ
 JMC  SMS_HANDLER_3_L58
#srcline 334 ;            BuferOUT[4] := 16#3139; //91 - internacional number
 LD   word $3139
 WRX  BuferOUT[4]
#debug_left word BuferOUT[4]
#srcline 335 ;          ELSE
 JMP  SMS_HANDLER_3_L59
SMS_HANDLER_3_L58:
#srcline 336 ;            BuferOUT[4] := 16#3138; //81 - local number
 LD   word $3138
 WRX  BuferOUT[4]
#debug_left word BuferOUT[4]
#srcline 337 ;          END_IF;
SMS_HANDLER_3_L59:
#srcline 338 ;          indx := _GsmLib_CodeSemiOctetsNumber(ADR(BuferOUT[5]), l_Recipient);
 NXT
 LEAX BuferOUT
 ADD  10  ; + offset 
#debug pointer BuferOUT[5]
 LEA  __Instance___GsmLib_CodeSemiOctetsNumber~IN
 WRIL 
#debug_left udint __Instance___GsmLib_CodeSemiOctetsNumber~IN
 LEAX l_Recipient
 WR   __Instance___GsmLib_CodeSemiOctetsNumber~Num
#debug_left pointer __Instance___GsmLib_CodeSemiOctetsNumber.Num
 PRV
 LEA  __Instance___GsmLib_CodeSemiOctetsNumber
 CAL  _GsmLib_CodeSemiOctetsNumber_L0
 WRY  indx
#debug_left usint indx
#srcline 339 ;          BuferOUT[3] := _GsmLib_BYTE_TO_HEX(USINT_TO_BYTE(indx));
 NXT
 LDY  indx
#debug usint indx
 AND  $FF
 WR   __Instance___GsmLib_BYTE_TO_HEX~B
#debug_left byte __Instance___GsmLib_BYTE_TO_HEX~B
 PRV
 LEA  __Instance___GsmLib_BYTE_TO_HEX
 CAL  _GsmLib_BYTE_TO_HEX_L0
 WRX  BuferOUT[3]
#debug_left word BuferOUT[3]
#srcline 340 ;          indx :=  (11 + indx) / 2;     //5 + (tusint + 1) / 2;
 LD   usint 11
 LDY  indx
#debug usint indx
 ADD
 AND  $FF
 LD   usint 2
 DIVL
 AND  $FF
 WRY  indx
#debug_left usint indx
#srcline 341 ;          BuferOUT[indx]   := 16#3030; //00
 LD   word $3030
 LEAX BuferOUT
 LDY  indx
#debug usint indx
 RCHK 179   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left word BuferOUT[indx]
#srcline 342 ;          indx := indx + 1;
 LDY  indx
#debug usint indx
 LD   usint 1
 ADD
 AND  $FF
 WRY  indx
#debug_left usint indx
#srcline 343 ;          CASE SmsCoding OF
 LDX  SmsCoding
#debug usint SmsCoding
 WRY  P2__st__
 LD   0
 LDY  P2__st__
 EQ  
 JMC  SMS_HANDLER_3_L61
#srcline 344 ;            ggsc_GSM7bit :
#srcline 345 ;              BuferOUT[indx] := 16#3030; //00
 LD   word $3030
 LEAX BuferOUT
 LDY  indx
#debug usint indx
 RCHK 179   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left word BuferOUT[indx]
#srcline 346 ;              l_MessToSend[MessLen] := 0;
 LD   usint 0
 LEAX l_MessToSend
 LDX  MessLen
#debug usint MessLen
 RCHK 159   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint l_MessToSend[MessLen]
#srcline 347 ;              tusint := _GsmLib_CodeTo7bitHEX(HEX := ADR(BuferOUT[indx+2]), PlcCoding := PlcCoding, Text := void(l_MessToSend));
 NXT
 LEAX BuferOUT
 LDY  indx
#debug usint indx
 LD   usint 2
 ADD
 AND  $FF
 RCHK 179   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
#debug pointer BuferOUT[indx+2]
 LEA  __Instance___GsmLib_CodeTo7bitHEX~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_CodeTo7bitHEX~HEX
 LDX  PlcCoding
#debug usint PlcCoding
 WR   __Instance___GsmLib_CodeTo7bitHEX~PlcCoding
#debug_left usint __Instance___GsmLib_CodeTo7bitHEX~PlcCoding
 LEAX l_MessToSend
 WR   __Instance___GsmLib_CodeTo7bitHEX~Text
#debug_left pointer __Instance___GsmLib_CodeTo7bitHEX.Text
 PRV
 LEA  __Instance___GsmLib_CodeTo7bitHEX
 CAL  _GsmLib_CodeTo7bitHEX_L0
 WRY  tusint
#debug_left usint tusint
 JMP  SMS_HANDLER_3_L60
SMS_HANDLER_3_L61:
 LD   1
 LDY  P2__st__
 EQ  
 JMC  SMS_HANDLER_3_L62
#srcline 348 ;            ggsc_8bit :
#srcline 349 ;              BuferOUT[indx] := 16#3430; //04
 LD   word $3430
 LEAX BuferOUT
 LDY  indx
#debug usint indx
 RCHK 179   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left word BuferOUT[indx]
#srcline 350 ;              tusint := _GsmLib_CodeTo8bitHEX2(HEX := ADR(BuferOUT[indx+2]), Lenght := MessLen, Text := l_MessToSend[0]);
 NXT
 LEAX BuferOUT
 LDY  indx
#debug usint indx
 LD   usint 2
 ADD
 AND  $FF
 RCHK 179   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
#debug pointer BuferOUT[indx+2]
 LEA  __Instance___GsmLib_CodeTo8bitHEX2~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_CodeTo8bitHEX2~HEX
 LDX  MessLen
#debug usint MessLen
 WR   __Instance___GsmLib_CodeTo8bitHEX2~Lenght
#debug_left usint __Instance___GsmLib_CodeTo8bitHEX2~Lenght
 LEAX l_MessToSend
 WR   __Instance___GsmLib_CodeTo8bitHEX2~Text
#debug_left pointer __Instance___GsmLib_CodeTo8bitHEX2.Text
 PRV
 LEA  __Instance___GsmLib_CodeTo8bitHEX2
 CAL  _GsmLib_CodeTo8bitHEX2_L0
 WRY  tusint
#debug_left usint tusint
 JMP  SMS_HANDLER_3_L60
SMS_HANDLER_3_L62:
 LD   2
 LDY  P2__st__
 EQ  
 JMC  SMS_HANDLER_3_L63
#srcline 351 ;            ggsc_UCS2    :
#srcline 352 ;              BuferOUT[indx] := 16#3830; //08
 LD   word $3830
 LEAX BuferOUT
 LDY  indx
#debug usint indx
 RCHK 179   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left word BuferOUT[indx]
#srcline 353 ;              l_MessToSend[MessLen] := 0;
 LD   usint 0
 LEAX l_MessToSend
 LDX  MessLen
#debug usint MessLen
 RCHK 159   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint l_MessToSend[MessLen]
#srcline 354 ;              tusint := _GsmLib_CodeTo16bitHEX(HEX := ADR(BuferOUT[indx+2]), PlcCoding := PlcCoding, Text := void(l_MessToSend));
 NXT
 LEAX BuferOUT
 LDY  indx
#debug usint indx
 LD   usint 2
 ADD
 AND  $FF
 RCHK 179   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
#debug pointer BuferOUT[indx+2]
 LEA  __Instance___GsmLib_CodeTo16bitHEX~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_CodeTo16bitHEX~HEX
 LDX  PlcCoding
#debug usint PlcCoding
 WR   __Instance___GsmLib_CodeTo16bitHEX~PlcCoding
#debug_left usint __Instance___GsmLib_CodeTo16bitHEX~PlcCoding
 LEAX l_MessToSend
 WR   __Instance___GsmLib_CodeTo16bitHEX~Text
#debug_left pointer __Instance___GsmLib_CodeTo16bitHEX.Text
 PRV
 LEA  __Instance___GsmLib_CodeTo16bitHEX
 CAL  _GsmLib_CodeTo16bitHEX_L0
 WRY  tusint
#debug_left usint tusint
 JMP  SMS_HANDLER_3_L60
SMS_HANDLER_3_L63:
SMS_HANDLER_3_L60:
#srcline 356 ;          indx := indx + 1;
 LDY  indx
#debug usint indx
 LD   usint 1
 ADD
 AND  $FF
 WRY  indx
#debug_left usint indx
#srcline 357 ;          IF SmsCoding = ggsc_GSM7bit THEN
 LDX  SmsCoding
#debug usint SmsCoding
 LD   udint 0  ; TGSMGateSmsCoding#ggsc_GSM7bit
 EQ
 JMC  SMS_HANDLER_3_L64
#srcline 358 ;            BuferOUT[indx] := _GsmLib_BYTE_TO_HEX(UDINT_TO_BYTE(USINT_TO_UDINT(tusint)*8/7));
 NXT
 LDY  tusint
#debug usint tusint
 LD   udint 8
 MUL
 LD   udint 7
 DIVL
 AND  $FF
 WR   __Instance___GsmLib_BYTE_TO_HEX~B
#debug_left byte __Instance___GsmLib_BYTE_TO_HEX~B
 PRV
 LEA  __Instance___GsmLib_BYTE_TO_HEX
 CAL  _GsmLib_BYTE_TO_HEX_L0
 LEAX BuferOUT
 LDY  indx
#debug usint indx
 RCHK 179   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left word BuferOUT[indx]
#srcline 359 ;          ELSE
 JMP  SMS_HANDLER_3_L65
SMS_HANDLER_3_L64:
#srcline 360 ;            BuferOUT[indx] := _GsmLib_BYTE_TO_HEX(USINT_TO_BYTE(tusint));
 NXT
 LDY  tusint
#debug usint tusint
 AND  $FF
 WR   __Instance___GsmLib_BYTE_TO_HEX~B
#debug_left byte __Instance___GsmLib_BYTE_TO_HEX~B
 PRV
 LEA  __Instance___GsmLib_BYTE_TO_HEX
 CAL  _GsmLib_BYTE_TO_HEX_L0
 LEAX BuferOUT
 LDY  indx
#debug usint indx
 RCHK 179   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left word BuferOUT[indx]
#srcline 361 ;          END_IF;
SMS_HANDLER_3_L65:
#srcline 362 ;          OctetLen := USINT_TO_UINT(indx+tusint+1)*2+1;
 LDY  indx
#debug usint indx
 LDY  tusint
#debug usint tusint
 ADD
 AND  $FF
 LD   usint 1
 ADD
 AND  $FF
 AND  $FFFF
 LD   uint 2
 MUL
 AND  $FFFF
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  OctetLen
#debug_left uint OctetLen
#srcline 363 ;          BuferOUT[indx+tusint+1] := 16#1A;
 LD   word $1A
 LEAX BuferOUT
 LDY  indx
#debug usint indx
 LDY  tusint
#debug usint tusint
 ADD
 AND  $FF
 LD   usint 1
 ADD
 AND  $FF
 RCHK 179   ; Range Check
 MUL  2   ; SizeOf(...)
 ADD     ; + offset 
 WRIW 
#debug_left word BuferOUT[indx+tusint+1]
#srcline 364 ;          if tusint > 140 THEN
 LDY  tusint
#debug usint tusint
 LD   usint 140
 GT
 JMC  SMS_HANDLER_3_L66
#srcline 365 ;            State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 366 ;            Error := gger_Message_Text_Too_Long;
 LD   udint 17  ; TGSMGateError#gger_Message_Text_Too_Long
 WRX  Error
#debug_left usint Error
#srcline 367 ;          ELSE
 JMP  SMS_HANDLER_3_L67
SMS_HANDLER_3_L66:
#srcline 368 ;            DataOUT := _GsmLib_AtCommandATCMGS2+USINT_TO_STRING(indx+tusint)+_GsmLib_CrLfString;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   32
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATCMGS2
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   32
 DST    ; Level 2
 LDY  indx
#debug usint indx
 LDY  tusint
#debug usint tusint
 ADD
 AND  $FF
 SCNV $0830;  IEC_USINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 LEA  _GsmLib_CrLfString
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX DataOUT
 WRI  
 LEAX DataOUT
 LD   32
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string DataOUT
 PDST   ; Level 1
#srcline 369 ;          END_IF;
SMS_HANDLER_3_L67:
#srcline 370 ;        END_IF;
SMS_HANDLER_3_L54:
 JMP  SMS_HANDLER_3_L32
SMS_HANDLER_3_L52:
 LD   17
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_3_L68
#srcline 371 ;        //Stop := true;
#srcline 372 ;      ggso_SendText:
#srcline 373 ;        IF MessLen > 0 THEN
 LDX  MessLen
#debug usint MessLen
 LD   usint 0
 GT
 JMC  SMS_HANDLER_3_L69
#srcline 374 ;          SendTo.lenTx := OctetLen;
 LDX  OctetLen
#debug uint OctetLen
 WRX  SendTo~lenTx
#debug_left uint SendTo.lenTx
#srcline 375 ;        ELSE
 JMP  SMS_HANDLER_3_L70
SMS_HANDLER_3_L69:
#srcline 376 ;          State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 377 ;          Error := gger_Empty_Message_Text;
 LD   udint 16  ; TGSMGateError#gger_Empty_Message_Text
 WRX  Error
#debug_left usint Error
#srcline 378 ;        END_IF;
SMS_HANDLER_3_L70:
 JMP  SMS_HANDLER_3_L32
SMS_HANDLER_3_L68:
 LD   15
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_3_L71
#srcline 379 ;      ggso_Read:
#srcline 380 ;        DataOUT := _GsmLib_AtCommandATCMGR+USINT_TO_STRING(Counter)+_GsmLib_CrLfString;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   32
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATCMGR
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   32
 DST    ; Level 2
 LDX  Counter
#debug usint Counter
 SCNV $0830;  IEC_USINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 LEA  _GsmLib_CrLfString
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX DataOUT
 WRI  
 LEAX DataOUT
 LD   32
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string DataOUT
 PDST   ; Level 1
 JMP  SMS_HANDLER_3_L32
SMS_HANDLER_3_L71:
 LD   13
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_3_L72
#srcline 381 ;      ggso_EraseOne:
#srcline 382 ;        {$IFDEF DO_NOT_ERASE}
#srcline 383 ;        DataOUT := _GsmLib_AtCommandATE0;
#srcline 384 ;        {$ELSE}
#srcline 385 ;        DataOUT := _GsmLib_AtCommandATCMGD+USINT_TO_STRING(Counter)+_GsmLib_CrLfString;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   32
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATCMGD
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   32
 DST    ; Level 2
 LDX  Counter
#debug usint Counter
 SCNV $0830;  IEC_USINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 LEA  _GsmLib_CrLfString
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX DataOUT
 WRI  
 LEAX DataOUT
 LD   32
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string DataOUT
 PDST   ; Level 1
 JMP  SMS_HANDLER_3_L32
SMS_HANDLER_3_L72:
 LD   20
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_3_L73
#srcline 386 ;        {$END_IF}
#srcline 387 ;      ggso_SignalQ:
#srcline 388 ;        {ASM}
#srcline 389
        initstring3(DataOUT, __Init_____GsmLib_AtCommandATCSQ, 32)
#srcline 390 ;        {END_ASM}
#srcline 391 ;        //DataOUT := _GsmLib_AtCommandATCSQ;
#srcline 392 ;      ggso_RingNumber:
 JMP  SMS_HANDLER_3_L32
SMS_HANDLER_3_L73:
 LD   21
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_3_L74
#srcline 393 ;        {ASM}
#srcline 394
        initstring3(DataOUT, __Init_____GsmLib_AtCommandATCLCC, 32)
#srcline 395 ;        {END_ASM}
#srcline 396 ;        //DataOUT := _GsmLib_AtCommandATCLCC;
#srcline 397 ;      ggso_Ringing:
 JMP  SMS_HANDLER_3_L32
SMS_HANDLER_3_L74:
 LD   22
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_3_L75
#srcline 398 ;        IF LEN(IN := Recipient) > 0 THEN
 LDX  Recipient
#debug string Recipient
 SLEN 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_3_L76
#srcline 399 ;          DataOUT := CONCAT(_GsmLib_AtCommandATD,Recipient,_GsmLib_SemiColonCrLfString);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   32
 DST    ; Level 1
 LEA  _GsmLib_AtCommandATD
 SCON
 LDX  Recipient
#debug string Recipient
 SCON
 LEA  _GsmLib_SemiColonCrLfString

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX DataOUT
 WRI  
 LEAX DataOUT
 LD   32
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string DataOUT
 PDST   ; Level 1
#srcline 400 ;        ELSE
 JMP  SMS_HANDLER_3_L77
SMS_HANDLER_3_L76:
#srcline 401 ;          State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 402 ;          Error := gger_No_Recipient_Number;
 LD   udint 8  ; TGSMGateError#gger_No_Recipient_Number
 WRX  Error
#debug_left usint Error
#srcline 403 ;        END_IF;
SMS_HANDLER_3_L77:
 JMP  SMS_HANDLER_3_L32
SMS_HANDLER_3_L75:
 LD   23
 LDY  P1__st__
 EQ  
 JMC  SMS_HANDLER_3_L78
#srcline 404 ;      ggso_CancelCall:
#srcline 405 ;        {ASM}
#srcline 406
        initstring3(DataOUT, __Init_____GsmLib_AtCommandATH, 32)
#srcline 407 ;        {END_ASM}
#srcline 408 ;        //DataOUT := _GsmLib_AtCommandATH;
#srcline 409 ;        Ring := false;
 LD   bool 0       ; false
 WRX  Ring
#debug_left bool Ring
 JMP  SMS_HANDLER_3_L32
SMS_HANDLER_3_L78:
#srcline 410 ;    ELSE
#srcline 411 ;    ;
#srcline 412 ;    END_CASE;
SMS_HANDLER_3_L32:
#srcline 413 ;    SendTo.rq := Error = gger_None;
 LDX  Error
#debug usint Error
 LD   udint 0  ; TGSMGateError#gger_None
 EQ
 WRX  SendTo~rq
#debug_left bool SendTo.rq
#srcline 414 ;    SendTo.chanCode := chanCode;
 LDX  chanCode
#debug uint chanCode
 WRX  SendTo~chanCode
#debug_left uint SendTo.chanCode
#srcline 415 ;    IF State <> ggso_SendText THEN
 LDX  State
#debug usint State
 LD   udint 17  ; TGSMGateStateOut#ggso_SendText
 EQ
 NEG
 JMC  SMS_HANDLER_3_L79
#srcline 416 ;      SendTo(lenTx := LEN(DataOUT), data := void(DataOUT));
 LEAX DataOUT
#debug string DataOUT
 SLEN 
 WRX  SendTo~lenTx
#debug_left uint SendTo~lenTx
 LEAX DataOUT
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 417 ;    ELSE
 JMP  SMS_HANDLER_3_L80
SMS_HANDLER_3_L79:
#srcline 418 ;      SendTo(data := void(BuferOUT));
 LEAX BuferOUT
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 419 ;    END_IF;
SMS_HANDLER_3_L80:
#srcline 420 ;    MessOut := false;                         //wait for next request
 LD   bool 0       ; false
 WRX  MessOut
#debug_left bool MessOut
#srcline 421 ;  END_IF;
SMS_HANDLER_3_L30:
#srcline 424 ;  //receiving messages from channel
#srcline 425 ;  IF NewMessage THEN //ARC
 LDY  NewMessage
#debug bool NewMessage
 JMC  SMS_HANDLER_3_L81
#srcline 426 ;    pBuferIN := ADR(BuferIN);
 LEAX BuferIN
#debug pointer BuferIN
 LEAY pBuferIN
 WRIL 
#debug_left pointer pBuferIN
#srcline 427 ;    
#srcline 428 ;    IF ChanError <> 0 THEN
 LDY  ChanError
#debug usint ChanError
 LD   usint 0
 EQ
 NEG
 JMC  SMS_HANDLER_3_L83
#srcline 429 ;      State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 430 ;      Error := gger_Channel_error;
 LD   udint 12  ; TGSMGateError#gger_Channel_error
 WRX  Error
#debug_left usint Error
#srcline 431 ;      RecvMess := GetLastComErrTxt(errCode := ChanError);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   160
 DST    ; Level 1
 NXT
 LDY  ChanError
#debug usint ChanError
 WR   __Instance__GetLastComErrTxt~errCode
#debug_left usint __Instance__GetLastComErrTxt~errCode
 PRV
 LEA  __Instance__GetLastComErrTxt
 CAL  GetLastComErrTxt_L0

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  RecvMess
 WRI  
 LDX  RecvMess
 LD   160
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string RecvMess
 PDST   ; Level 1
#srcline 432 ;      RETURN;
 JMP  SMS_HANDLER_3_RET
#srcline 433 ;    END_IF;
SMS_HANDLER_3_L83:
#srcline 435 ;    //unsolicited messages
#srcline 436 ;    //RING
#srcline 437 ;    IF FIND(pBuferIN^, _GsmLib_AtReplyRING) = 1 THEN
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_AtReplyRING
 SFND 
 LD   int 1
 EQ
 JMC  SMS_HANDLER_3_L85
#srcline 438 ;      //Ring := true; presunuto do prijmu ggso_RingNumber
#srcline 439 ;      IF State <> ggso_CancelCall THEN
 LDX  State
#debug usint State
 LD   udint 23  ; TGSMGateStateOut#ggso_CancelCall
 EQ
 NEG
 JMC  SMS_HANDLER_3_L87
#srcline 440 ;        RingCount := 0;
 LD   usint 0
 WRX  RingCount
#debug_left usint RingCount
#srcline 441 ;        State := ggso_RingNumber;
 LD   udint 21  ; TGSMGateStateOut#ggso_RingNumber
 WRX  State
#debug_left usint State
#srcline 442 ;        MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 443 ;      ELSE
 JMP  SMS_HANDLER_3_L88
SMS_HANDLER_3_L87:
#srcline 444 ;        WaitTime.PT := T#11s;
 LD   time 11000
 WRX  WaitTime~PT
#debug_left time WaitTime.PT
#srcline 445 ;        RingCount := RingCount + 1;
 LDX  RingCount
#debug usint RingCount
 LD   usint 1
 ADD
 AND  $FF
 WRX  RingCount
#debug_left usint RingCount
#srcline 446 ;      END_IF;
SMS_HANDLER_3_L88:
#srcline 447 ;      RETURN;
 JMP  SMS_HANDLER_3_RET
#srcline 448 ;    END_IF;
SMS_HANDLER_3_L85:
#srcline 449 ;    //+CMTI
#srcline 450 ;    IF FIND(pBuferIN^, _GsmLib_AtReplyCMTI) > 0 THEN
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_AtReplyCMTI
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_3_L89
#srcline 451 ;      State   := ggso_SignalQ;
 LD   udint 20  ; TGSMGateStateOut#ggso_SignalQ
 WRX  State
#debug_left usint State
#srcline 452 ;      MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 453 ;      RETURN;
 JMP  SMS_HANDLER_3_RET
#srcline 454 ;    END_IF;
SMS_HANDLER_3_L89:
#srcline 455 ;    
#srcline 456 ;    ok := FIND(pBuferIN^, _GsmLib_OkString) > 0;
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_OkString
 SFND 
 LD   int 0
 GTS
 WRX  ok
#debug_left bool ok
#srcline 458 ;    IF WaitForOk AND ok THEN
 LDX  WaitForOk
#debug bool WaitForOk
 LDX  ok
#debug bool ok
 AND
 JMC  SMS_HANDLER_3_L91
#srcline 459 ;      WaitForOk := false;
 LD   bool 0       ; false
 WRX  WaitForOk
#debug_left bool WaitForOk
#srcline 460 ;    ELSE
 JMP  SMS_HANDLER_3_L92
SMS_HANDLER_3_L91:
#srcline 461 ;      WaitForOk := false;
 LD   bool 0       ; false
 WRX  WaitForOk
#debug_left bool WaitForOk
#srcline 462 ;      //states
#srcline 463 ;      CASE State OF
 LDX  State
#debug usint State
 WRY  P3__st__
 LD   0
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_3_L94
#srcline 464 ;        ggso_Init :
#srcline 465 ;          MaxReadErrs := 50;
 LD   usint 50
 WRX  MaxReadErrs
#debug_left usint MaxReadErrs
#srcline 466 ;          WaitTime.PT := Pause4;
 LD   time 3000
 WRX  WaitTime~PT
#debug_left time WaitTime.PT
#srcline 467 ;          IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_3_L95
#srcline 468 ;            IF ColdRestart THEN
 LDX  ColdRestart
#debug bool ColdRestart
 JMC  SMS_HANDLER_3_L97
#srcline 469 ;              WaitTime.PT := Pause1;
 LD   time 500
 WRX  WaitTime~PT
#debug_left time WaitTime.PT
#srcline 470 ;              ColdRestart := false;
 LD   bool 0       ; false
 WRX  ColdRestart
#debug_left bool ColdRestart
#srcline 471 ;              State := ggso_BaudRate;
 LD   udint 1  ; TGSMGateStateOut#ggso_BaudRate
 WRX  State
#debug_left usint State
#srcline 472 ;            ELSE
 JMP  SMS_HANDLER_3_L98
SMS_HANDLER_3_L97:
#srcline 473 ;              State := ggso_Conf1;
 LD   udint 5  ; TGSMGateStateOut#ggso_Conf1
 WRX  State
#debug_left usint State
#srcline 474 ;            END_IF;
SMS_HANDLER_3_L98:
#srcline 475 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 476 ;          END_IF;
SMS_HANDLER_3_L95:
 JMP  SMS_HANDLER_3_L93
SMS_HANDLER_3_L94:
 LD   1
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_3_L99
#srcline 477 ;        ggso_BaudRate:
#srcline 478 ;          IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_3_L100
#srcline 479 ;            State := ggso_Reset;
 LD   udint 2  ; TGSMGateStateOut#ggso_Reset
 WRX  State
#debug_left usint State
#srcline 480 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 481 ;          END_IF;
SMS_HANDLER_3_L100:
 JMP  SMS_HANDLER_3_L93
SMS_HANDLER_3_L99:
 LD   2
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_3_L102
#srcline 482 ;        ggso_Reset:
#srcline 483 ;          IF FIND(pBuferIN^, _GsmLib_AtReplySYSSTART) > 0 THEN
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_AtReplySYSSTART
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_3_L103
#srcline 484 ;            State := ggso_Init;
 LD   udint 0  ; TGSMGateStateOut#ggso_Init
 WRX  State
#debug_left usint State
#srcline 485 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 486 ;          END_IF;
SMS_HANDLER_3_L103:
 JMP  SMS_HANDLER_3_L93
SMS_HANDLER_3_L102:
 LD   3
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_3_L105
#srcline 487 ;        ggso_Pin:
#srcline 488 ;          WaitTime.PT := Pause3;
 LD   time 2000
 WRX  WaitTime~PT
#debug_left time WaitTime.PT
#srcline 489 ;          IF FIND(pBuferIN^, _GsmLib_AtReplyCPIN) > 0 THEN
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_AtReplyCPIN
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_3_L106
#srcline 490 ;            ReadErrs := 0;
 LD   usint 0
 WRX  ReadErrs
#debug_left usint ReadErrs
#srcline 491 ;            IF FIND(pBuferIN^, _GsmLib_AtReplyREADY) > 0 THEN //PIN code is not required
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_AtReplyREADY
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_3_L108
#srcline 492 ;              State := ggso_Conf2;
 LD   udint 6  ; TGSMGateStateOut#ggso_Conf2
 WRX  State
#debug_left usint State
#srcline 493 ;              MessOut   := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 494 ;              WaitForOk := true;
 LD   bool -1       ; true
 WRX  WaitForOk
#debug_left bool WaitForOk
#srcline 495 ;            END_IF;
SMS_HANDLER_3_L108:
#srcline 496 ;            IF FIND(pBuferIN^, _GsmLib_AtReplySIMPIN) > 0 THEN //PIN code is required
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_AtReplySIMPIN
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_3_L110
#srcline 497 ;              State := ggso_PinValue;
 LD   udint 4  ; TGSMGateStateOut#ggso_PinValue
 WRX  State
#debug_left usint State
#srcline 498 ;              MessOut   := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 499 ;              WaitForOk := true;
 LD   bool -1       ; true
 WRX  WaitForOk
#debug_left bool WaitForOk
#srcline 500 ;            END_IF;
SMS_HANDLER_3_L110:
#srcline 501 ;            IF NOT MessOut THEN
 LDX  MessOut
#debug bool MessOut
 NEG
 JMC  SMS_HANDLER_3_L112
#srcline 502 ;              State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 503 ;              Error := gger_Pin_Error;
 LD   udint 2  ; TGSMGateError#gger_Pin_Error
 WRX  Error
#debug_left usint Error
#srcline 504 ;            END_IF;
SMS_HANDLER_3_L112:
#srcline 505 ;            IF FIND(pBuferIN^, _GsmLib_AtReplySIMPUK) > 0 THEN //PUK code is required => error
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_AtReplySIMPUK
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_3_L114
#srcline 506 ;              State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 507 ;              Error := gger_Puk_Required;
 LD   udint 3  ; TGSMGateError#gger_Puk_Required
 WRX  Error
#debug_left usint Error
#srcline 508 ;              HardErr := true;
 LD   bool -1       ; true
 WRX  HardErr
#debug_left bool HardErr
#srcline 509 ;            END_IF;
SMS_HANDLER_3_L114:
#srcline 510 ;          ELSE
 JMP  SMS_HANDLER_3_L107
SMS_HANDLER_3_L106:
#srcline 511 ;            ReadErrs := ReadErrs + 1;
 LDX  ReadErrs
#debug usint ReadErrs
 LD   usint 1
 ADD
 AND  $FF
 WRX  ReadErrs
#debug_left usint ReadErrs
#srcline 512 ;            IF ReadErrs > 1 THEN
 LDX  ReadErrs
#debug usint ReadErrs
 LD   usint 1
 GT
 JMC  SMS_HANDLER_3_L116
#srcline 513 ;              State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 514 ;              Error := gger_Pin_Error;
 LD   udint 2  ; TGSMGateError#gger_Pin_Error
 WRX  Error
#debug_left usint Error
#srcline 515 ;            ELSE
 JMP  SMS_HANDLER_3_L117
SMS_HANDLER_3_L116:
#srcline 516 ;              State := ggso_Pin;
 LD   udint 3  ; TGSMGateStateOut#ggso_Pin
 WRX  State
#debug_left usint State
#srcline 517 ;              MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 518 ;            END_IF;
SMS_HANDLER_3_L117:
#srcline 519 ;          END_IF;
SMS_HANDLER_3_L107:
 JMP  SMS_HANDLER_3_L93
SMS_HANDLER_3_L105:
 LD   4
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_3_L118
#srcline 520 ;        ggso_PinValue:
#srcline 521 ;          WaitTime.PT := Pause4; //timeout after PIN set
 LD   time 3000
 WRX  WaitTime~PT
#debug_left time WaitTime.PT
#srcline 522 ;          IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_3_L119
#srcline 523 ;            State := ggso_Conf2;
 LD   udint 6  ; TGSMGateStateOut#ggso_Conf2
 WRX  State
#debug_left usint State
#srcline 524 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 525 ;          ELSE
 JMP  SMS_HANDLER_3_L120
SMS_HANDLER_3_L119:
#srcline 526 ;            State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 527 ;            Error := gger_Pin_Error;
 LD   udint 2  ; TGSMGateError#gger_Pin_Error
 WRX  Error
#debug_left usint Error
#srcline 528 ;            HardErr := true;
 LD   bool -1       ; true
 WRX  HardErr
#debug_left bool HardErr
#srcline 529 ;          END_IF;
SMS_HANDLER_3_L120:
 JMP  SMS_HANDLER_3_L93
SMS_HANDLER_3_L118:
 LD   5
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_3_L121
#srcline 530 ;        ggso_Conf1:
#srcline 531 ;          WaitTime.PT := Pause1;
 LD   time 500
 WRX  WaitTime~PT
#debug_left time WaitTime.PT
#srcline 532 ;          IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_3_L122
#srcline 533 ;            State := ggso_Pin;
 LD   udint 3  ; TGSMGateStateOut#ggso_Pin
 WRX  State
#debug_left usint State
#srcline 534 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 535 ;          ELSE
 JMP  SMS_HANDLER_3_L123
SMS_HANDLER_3_L122:
#srcline 536 ;            State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 537 ;            Error := gger_Cfg_Error;
 LD   udint 4  ; TGSMGateError#gger_Cfg_Error
 WRX  Error
#debug_left usint Error
#srcline 538 ;          END_IF;
SMS_HANDLER_3_L123:
 JMP  SMS_HANDLER_3_L93
SMS_HANDLER_3_L121:
 LD   6
 LDY  P3__st__
 EQ   
 JMD  SMS_HANDLER_3_L124
 LD   7
 LDY  P3__st__
 EQ   
 JMC  SMS_HANDLER_3_L125
SMS_HANDLER_3_L124:
#srcline 539 ;        ggso_Conf2, ggso_Conf3:
#srcline 540 ;          WaitTime.PT := Pause1;
 LD   time 500
 WRX  WaitTime~PT
#debug_left time WaitTime.PT
#srcline 541 ;          IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_3_L126
#srcline 542 ;            pusint := ADR(State);
 LEAX State
#debug pointer State
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 543 ;            pusint^ := pusint^ + 1;
 LEAY pusint
 LDIL    ; dereference 
 LDI  
#debug usint pusint^
 LD   usint 1
 ADD
 AND  $FF
 LEAY pusint
 LDIL    ; dereference 
 WRI 
#debug_left usint pusint^
#srcline 544 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 545 ;          ELSE
 JMP  SMS_HANDLER_3_L127
SMS_HANDLER_3_L126:
#srcline 546 ;            State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 547 ;            Error := gger_Cfg_Error;
 LD   udint 4  ; TGSMGateError#gger_Cfg_Error
 WRX  Error
#debug_left usint Error
#srcline 548 ;          END_IF;
SMS_HANDLER_3_L127:
 JMP  SMS_HANDLER_3_L93
SMS_HANDLER_3_L125:
 LD   8
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_3_L128
#srcline 549 ;        ggso_Conf4:
#srcline 550 ;          NeedErase := true;
 LD   bool -1       ; true
 WRX  NeedErase
#debug_left bool NeedErase
#srcline 551 ;          IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_3_L129
#srcline 552 ;            State := ggso_Conf5; //ggso_Center; //MC35
 LD   udint 9  ; TGSMGateStateOut#ggso_Conf5
 WRX  State
#debug_left usint State
#srcline 553 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 554 ;          ELSIF FIND(pBuferIN^, _GsmLib_AtReplyCPMS) > 0 THEN
 JMP  SMS_HANDLER_3_L130
SMS_HANDLER_3_L129:
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_AtReplyCPMS
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_3_L131
#srcline 555 ;            pstring := ADR(BuferIN[7]);
 LEAX BuferIN
 ADD  7  ; + offset 
#debug pointer BuferIN[7]
 LEAY pstring
 WRIL 
#debug_left pointer pstring
#srcline 556 ;            NeedErase := STRING_TO_USINT(pstring^) <> 0;
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 SCNV $3008;  IEC_STRING _TO_ IEC_USINT
 LD   usint 0
 EQ
 NEG
 WRX  NeedErase
#debug_left bool NeedErase
#srcline 557 ;            pos := FIND(pstring^, _GsmLib_CommaString);
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 LEA  _GsmLib_CommaString
 SFND 
 WRY  pos
#debug_left int pos
#srcline 558 ;            IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_3_L132
#srcline 559 ;              pstring := pstring + INT_TO_UDINT(pos);
 LEAY pstring
 LDIL 
#debug pointer pstring
 LDY  pos
#debug int pos
 EXTW 
 ADD
 LEAY pstring
 WRIL 
#debug_left pointer pstring
#srcline 560 ;              MessagesCnt := STRING_TO_USINT(pstring^);
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 SCNV $3008;  IEC_STRING _TO_ IEC_USINT
 WRX  MessagesCnt
#debug_left usint MessagesCnt
#srcline 561 ;            ELSE
 JMP  SMS_HANDLER_3_L133
SMS_HANDLER_3_L132:
#srcline 562 ;              MessagesCnt := 10;
 LD   usint 10
 WRX  MessagesCnt
#debug_left usint MessagesCnt
#srcline 563 ;            END_IF;
SMS_HANDLER_3_L133:
#srcline 564 ;          ELSE
 JMP  SMS_HANDLER_3_L130
SMS_HANDLER_3_L131:
#srcline 565 ;            State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 566 ;            Error := gger_Cfg_Error;
 LD   udint 4  ; TGSMGateError#gger_Cfg_Error
 WRX  Error
#debug_left usint Error
#srcline 567 ;          END_IF;
SMS_HANDLER_3_L130:
 JMP  SMS_HANDLER_3_L93
SMS_HANDLER_3_L128:
 LD   9
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_3_L134
#srcline 568 ;        ggso_Conf5:
#srcline 569 ;          IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_3_L135
#srcline 570 ;            IF LEN(SMSCenter) > 0 THEN
 LDX  SMSCenter
#debug string SMSCenter
 SLEN 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_3_L137
#srcline 571 ;              State := ggso_Center;
 LD   udint 10  ; TGSMGateStateOut#ggso_Center
 WRX  State
#debug_left usint State
#srcline 572 ;            ELSE
 JMP  SMS_HANDLER_3_L138
SMS_HANDLER_3_L137:
#srcline 573 ;              State := ggso_EraseQuery;
 LD   udint 11  ; TGSMGateStateOut#ggso_EraseQuery
 WRX  State
#debug_left usint State
#srcline 574 ;            END_IF;
SMS_HANDLER_3_L138:
#srcline 575 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 576 ;          ELSE
 JMP  SMS_HANDLER_3_L136
SMS_HANDLER_3_L135:
#srcline 577 ;            State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 578 ;            Error := gger_Cfg_Error;
 LD   udint 4  ; TGSMGateError#gger_Cfg_Error
 WRX  Error
#debug_left usint Error
#srcline 579 ;          END_IF;
SMS_HANDLER_3_L136:
 JMP  SMS_HANDLER_3_L93
SMS_HANDLER_3_L134:
 LD   10
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_3_L139
#srcline 580 ;        ggso_Center:
#srcline 581 ;          IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_3_L140
#srcline 582 ;            State := ggso_EraseQuery;
 LD   udint 11  ; TGSMGateStateOut#ggso_EraseQuery
 WRX  State
#debug_left usint State
#srcline 583 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 584 ;          ELSE
 JMP  SMS_HANDLER_3_L141
SMS_HANDLER_3_L140:
#srcline 585 ;            State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 586 ;            Error := gger_SMS_Center_Error;
 LD   udint 6  ; TGSMGateError#gger_SMS_Center_Error
 WRX  Error
#debug_left usint Error
#srcline 587 ;          END_IF;
SMS_HANDLER_3_L141:
 JMP  SMS_HANDLER_3_L93
SMS_HANDLER_3_L139:
 LD   12
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_3_L142
#srcline 588 ;        ggso_Erase:
#srcline 589 ;          IF Counter < MessagesCnt THEN
 LDX  Counter
#debug usint Counter
 LDX  MessagesCnt
#debug usint MessagesCnt
 LT
 JMC  SMS_HANDLER_3_L143
#srcline 590 ;            IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_3_L145
#srcline 591 ;              Counter := Counter+1;
 LDX  Counter
#debug usint Counter
 LD   usint 1
 ADD
 AND  $FF
 WRX  Counter
#debug_left usint Counter
#srcline 592 ;              MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 593 ;            ELSE
 JMP  SMS_HANDLER_3_L146
SMS_HANDLER_3_L145:
#srcline 594 ;              State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 595 ;              Error := gger_Erase_Failed;
 LD   udint 5  ; TGSMGateError#gger_Erase_Failed
 WRX  Error
#debug_left usint Error
#srcline 596 ;            END_IF;
SMS_HANDLER_3_L146:
#srcline 597 ;          ELSE
 JMP  SMS_HANDLER_3_L144
SMS_HANDLER_3_L143:
#srcline 598 ;            State := ggso_SignalQ;
 LD   udint 20  ; TGSMGateStateOut#ggso_SignalQ
 WRX  State
#debug_left usint State
#srcline 599 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 600 ;          END_IF;
SMS_HANDLER_3_L144:
 JMP  SMS_HANDLER_3_L93
SMS_HANDLER_3_L142:
 LD   13
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_3_L147
#srcline 601 ;        ggso_EraseOne:
#srcline 602 ;          IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_3_L148
#srcline 603 ;            Counter := Counter+1;
 LDX  Counter
#debug usint Counter
 LD   usint 1
 ADD
 AND  $FF
 WRX  Counter
#debug_left usint Counter
#srcline 604 ;            IF SendPending THEN
 LDX  SendPending
#debug bool SendPending
 JMC  SMS_HANDLER_3_L150
#srcline 605 ;              State := ggso_Send;
 LD   udint 18  ; TGSMGateStateOut#ggso_Send
 WRX  State
#debug_left usint State
#srcline 606 ;            ELSIF UssdPending THEN
 JMP  SMS_HANDLER_3_L151
SMS_HANDLER_3_L150:
 LDX  UssdPending
#debug bool UssdPending
 JMC  SMS_HANDLER_3_L152
#srcline 607 ;              State := ggso_Ussd;
 LD   udint 19  ; TGSMGateStateOut#ggso_Ussd
 WRX  State
#debug_left usint State
#srcline 608 ;            ELSE
 JMP  SMS_HANDLER_3_L151
SMS_HANDLER_3_L152:
#srcline 609 ;              State := ggso_Read;
 LD   udint 15  ; TGSMGateStateOut#ggso_Read
 WRX  State
#debug_left usint State
#srcline 610 ;            END_IF;
SMS_HANDLER_3_L151:
#srcline 611 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 612 ;          ELSE
 JMP  SMS_HANDLER_3_L149
SMS_HANDLER_3_L148:
#srcline 613 ;            State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 614 ;            Error := gger_Erase_Failed;
 LD   udint 5  ; TGSMGateError#gger_Erase_Failed
 WRX  Error
#debug_left usint Error
#srcline 615 ;          END_IF;
SMS_HANDLER_3_L149:
 JMP  SMS_HANDLER_3_L93
SMS_HANDLER_3_L147:
 LD   18
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_3_L153
#srcline 616 ;        ggso_Send:
#srcline 617 ;          IF BuferIN[0] = 62 THEN //'>'
 LDX  BuferIN[0]
#debug usint BuferIN[0]
 LD   usint 62
 EQ
 JMC  SMS_HANDLER_3_L154
#srcline 618 ;            State := ggso_SendText;
 LD   udint 17  ; TGSMGateStateOut#ggso_SendText
 WRX  State
#debug_left usint State
#srcline 619 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 620 ;          ELSE
 JMP  SMS_HANDLER_3_L155
SMS_HANDLER_3_L154:
#srcline 621 ;            State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 622 ;            Error := gger_Sending_failed;
 LD   udint 9  ; TGSMGateError#gger_Sending_failed
 WRX  Error
#debug_left usint Error
#srcline 623 ;          END_IF;
SMS_HANDLER_3_L155:
 JMP  SMS_HANDLER_3_L93
SMS_HANDLER_3_L153:
 LD   17
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_3_L156
#srcline 624 ;        ggso_SendText:
#srcline 625 ;          IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_3_L157
#srcline 626 ;            SendPending := 0;
 LD   bool 0       ; false
 WRX  SendPending
#debug_left bool SendPending
#srcline 627 ;            State := ggso_SignalQ;
 LD   udint 20  ; TGSMGateStateOut#ggso_SignalQ
 WRX  State
#debug_left usint State
#srcline 628 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 629 ;          ELSE
 JMP  SMS_HANDLER_3_L158
SMS_HANDLER_3_L157:
#srcline 630 ;            IF FIND(pBuferIN^, _GsmLib_AtReplyCMGS) > 0 THEN
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_AtReplyCMGS
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_3_L159
#srcline 631 ;              pstring := ADR(BuferIN[7]);
 LEAX BuferIN
 ADD  7  ; + offset 
#debug pointer BuferIN[7]
 LEAY pstring
 WRIL 
#debug_left pointer pstring
#srcline 632 ;              SmsRef  := STRING_TO_USINT(pstring^);
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 SCNV $3008;  IEC_STRING _TO_ IEC_USINT
 WRX  SmsRef
#debug_left usint SmsRef
#srcline 633 ;            ELSIF BuferIN[0] <> 62 THEN
 JMP  SMS_HANDLER_3_L160
SMS_HANDLER_3_L159:
 LDX  BuferIN[0]
#debug usint BuferIN[0]
 LD   usint 62
 EQ
 NEG
 JMC  SMS_HANDLER_3_L161
#srcline 634 ;              State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 635 ;              Error := gger_Sending_failed;
 LD   udint 9  ; TGSMGateError#gger_Sending_failed
 WRX  Error
#debug_left usint Error
#srcline 636 ;            END_IF;
 JMP  SMS_HANDLER_3_L160
SMS_HANDLER_3_L161:
SMS_HANDLER_3_L160:
#srcline 637 ;          END_IF;
SMS_HANDLER_3_L158:
 JMP  SMS_HANDLER_3_L93
SMS_HANDLER_3_L156:
 LD   19
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_3_L162
#srcline 638 ;        ggso_Ussd:
#srcline 639 ;          //TODO: *#06#
#srcline 640 ;          IF FIND(pBuferIN^, _GsmLib_AtReplyCUSD) > 0 THEN
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_AtReplyCUSD
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_3_L163
#srcline 641 ;            pos := FIND(pBuferIN^, _GsmLib_QuoteString);
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_QuoteString
 SFND 
 WRY  pos
#debug_left int pos
#srcline 642 ;            IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_3_L165
#srcline 643 ;              pstring := ADR(BuferIN) + INT_TO_UDINT(pos);
 LEAX BuferIN
#debug pointer BuferIN
 LDY  pos
#debug int pos
 EXTW 
 ADD
 LEAY pstring
 WRIL 
#debug_left pointer pstring
#srcline 644 ;              pos := FIND(pstring^, _GsmLib_QuoteString);
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 LEA  _GsmLib_QuoteString
 SFND 
 WRY  pos
#debug_left int pos
#srcline 645 ;              IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_3_L167
#srcline 646 ;                RecvMess  := LEFT(IN := pstring^, L := pos-1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   160
 DST    ; Level 1
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 LDY  pos
#debug int pos
 EXTW 
 LD   int 1
 SUB
 EXTW
 SLFT 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  RecvMess
 WRI  
 LDX  RecvMess
 LD   160
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string RecvMess
 PDST   ; Level 1
#srcline 647 ;                NewMess   := true;
 LD   bool -1       ; true
 WRX  NewMess
#debug_left bool NewMess
#srcline 648 ;                RecvTime := LREAL_TO_DATE_AND_TIME(0.0) ;
 LDQ  lreal 0.0
 WRX  RecvTime
#debug_left dt RecvTime
#srcline 649 ;                Sender   := l_USSD;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   20
 DST    ; Level 1
 LEAX l_USSD
#debug string l_USSD
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  Sender
 WRI  
 LDX  Sender
 LD   20
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string Sender
 PDST   ; Level 1
#srcline 650 ;                State    := ggso_SignalQ;
 LD   udint 20  ; TGSMGateStateOut#ggso_SignalQ
 WRX  State
#debug_left usint State
#srcline 651 ;                MessOut  := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 652 ;                UssdPending := false;
 LD   bool 0       ; false
 WRX  UssdPending
#debug_left bool UssdPending
#srcline 653 ;              END_IF;
SMS_HANDLER_3_L167:
#srcline 654 ;            END_IF;
SMS_HANDLER_3_L165:
#srcline 655 ;          ELSIF not ok THEN
 JMP  SMS_HANDLER_3_L164
SMS_HANDLER_3_L163:
 LDX  ok
#debug bool ok
 NEG
 JMC  SMS_HANDLER_3_L169
#srcline 656 ;            State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 657 ;            Error := gger_USSD_Not_Executed;
 LD   udint 19  ; TGSMGateError#gger_USSD_Not_Executed
 WRX  Error
#debug_left usint Error
#srcline 658 ;          END_IF;
 JMP  SMS_HANDLER_3_L164
SMS_HANDLER_3_L169:
SMS_HANDLER_3_L164:
 JMP  SMS_HANDLER_3_L93
SMS_HANDLER_3_L162:
 LD   15
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_3_L170
#srcline 659 ;        ggso_Read:
#srcline 660 ;          IF FIND(pBuferIN^, _GsmLib_AtReplyCMGR) > 0 THEN
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_AtReplyCMGR
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_3_L171
#srcline 661 ;            ReadErrs := 0;
 LD   usint 0
 WRX  ReadErrs
#debug_left usint ReadErrs
#srcline 662 ;            MaxReadErrs := 2;
 LD   usint 2
 WRX  MaxReadErrs
#debug_left usint MaxReadErrs
#srcline 663 ;            pos := FIND(pBuferIN^, _GsmLib_CommaString);
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_CommaString
 SFND 
 WRY  pos
#debug_left int pos
#srcline 664 ;            IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_3_L173
#srcline 665 ;              pstring := ADR(BuferIN) + INT_TO_UDINT(pos) + 1;
 LEAX BuferIN
#debug pointer BuferIN
 LDY  pos
#debug int pos
 EXTW 
 ADD
 LD   udint 1
 ADD
 LEAY pstring
 WRIL 
#debug_left pointer pstring
#srcline 666 ;              OctetCnt := STRING_TO_USINT(pstring^);
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 SCNV $3008;  IEC_STRING _TO_ IEC_USINT
 WRX  OctetCnt
#debug_left usint OctetCnt
#srcline 667 ;              IF OctetCnt > 0 THEN
 LDX  OctetCnt
#debug usint OctetCnt
 LD   usint 0
 GT
 JMC  SMS_HANDLER_3_L175
#srcline 668 ;                State := ggso_ReadOctets;
 LD   udint 25  ; TGSMGateStateOut#ggso_ReadOctets
 WRX  State
#debug_left usint State
#srcline 669 ;              ELSE
 JMP  SMS_HANDLER_3_L176
SMS_HANDLER_3_L175:
#srcline 670 ;                State := ggso_ReadOk;
 LD   udint 16  ; TGSMGateStateOut#ggso_ReadOk
 WRX  State
#debug_left usint State
#srcline 671 ;              END_IF;
SMS_HANDLER_3_L176:
#srcline 672 ;            END_IF;
SMS_HANDLER_3_L173:
#srcline 673 ;          ELSIF FIND(pBuferIN^, _GsmLib_AtReplyERROR) > 0 THEN
 JMP  SMS_HANDLER_3_L172
SMS_HANDLER_3_L171:
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_AtReplyERROR
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_3_L177
#srcline 674 ;            ReadErrs := ReadErrs + 1;
 LDX  ReadErrs
#debug usint ReadErrs
 LD   usint 1
 ADD
 AND  $FF
 WRX  ReadErrs
#debug_left usint ReadErrs
#srcline 675 ;            IF ReadErrs < MaxReadErrs THEN
 LDX  ReadErrs
#debug usint ReadErrs
 LDX  MaxReadErrs
#debug usint MaxReadErrs
 LT
 JMC  SMS_HANDLER_3_L178
#srcline 676 ;              State := ggso_SignalQ;
 LD   udint 20  ; TGSMGateStateOut#ggso_SignalQ
 WRX  State
#debug_left usint State
#srcline 677 ;              MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 678 ;            ELSE
 JMP  SMS_HANDLER_3_L179
SMS_HANDLER_3_L178:
#srcline 679 ;              State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 680 ;              Error := gger_Receiving_failed;
 LD   udint 10  ; TGSMGateError#gger_Receiving_failed
 WRX  Error
#debug_left usint Error
#srcline 681 ;            END_IF;
SMS_HANDLER_3_L179:
#srcline 682 ;          END_IF;
 JMP  SMS_HANDLER_3_L172
SMS_HANDLER_3_L177:
SMS_HANDLER_3_L172:
 JMP  SMS_HANDLER_3_L93
SMS_HANDLER_3_L170:
 LD   25
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_3_L180
#srcline 683 ;        ggso_ReadOctets:
#srcline 684 ;          pusint  := ADR(RecvMess);
 LDX  RecvMess
#debug pointer RecvMess
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 685 ;          pusint^  := 0;              //clear recvmess
 LD   usint 0
 LEAY pusint
 LDIL    ; dereference 
 WRI 
#debug_left usint pusint^
#srcline 686 ;          pusint  := ADR(BuferIN);
 LEAX BuferIN
#debug pointer BuferIN
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 687 ;          lenNum := BYTE_TO_USINT(_GsmLib_HEX_TO_BYTE(pusint));
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LEA  __Instance___GsmLib_HEX_TO_BYTE~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_HEX_TO_BYTE~HEX
 PRV
 LEA  __Instance___GsmLib_HEX_TO_BYTE
 CAL  _GsmLib_HEX_TO_BYTE_L0
 WRY  lenNum
#debug_left usint lenNum
#srcline 688 ;          IF lenNum > 0 THEN
 LDY  lenNum
#debug usint lenNum
 LD   usint 0
 GT
 JMC  SMS_HANDLER_3_L181
#srcline 689 ;            typNum := _GsmLib_HEX_TO_BYTE(pusint+2);
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LD   udint 2
 ADD
 LEA  __Instance___GsmLib_HEX_TO_BYTE~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_HEX_TO_BYTE~HEX
 PRV
 LEA  __Instance___GsmLib_HEX_TO_BYTE
 CAL  _GsmLib_HEX_TO_BYTE_L0
 WRY  typNum
#debug_left byte typNum
#srcline 690 ;            pusint  := pusint + 4 + USINT_TO_UDINT(_GsmLib_DecodeSemiOctetsNumber(pusint+4, (lenNum-1)*2, l_SMSCenter));
 LEAY pusint
 LDIL 
#debug pointer pusint
 LD   udint 4
 ADD
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LD   udint 4
 ADD
 LEA  __Instance___GsmLib_DecodeSemiOctetsNumber~IN
 WRIL 
#debug_left udint __Instance___GsmLib_DecodeSemiOctetsNumber~IN
 LDY  lenNum
#debug usint lenNum
 LD   usint 1
 SUB
 AND  $FF
 LD   usint 2
 MUL
 AND  $FF
 WR   __Instance___GsmLib_DecodeSemiOctetsNumber~LNG
#debug_left usint __Instance___GsmLib_DecodeSemiOctetsNumber~LNG
 LEAX l_SMSCenter
 WR   __Instance___GsmLib_DecodeSemiOctetsNumber~Num
#debug_left pointer __Instance___GsmLib_DecodeSemiOctetsNumber.Num
 PRV
 LEA  __Instance___GsmLib_DecodeSemiOctetsNumber
 CAL  _GsmLib_DecodeSemiOctetsNumber_L0
 ADD
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 691 ;            IF typNum.4 THEN
 LDY  typNum.4
#debug bool typNum.4
 JMC  SMS_HANDLER_3_L183
#srcline 692 ;              l_SMSCenter := _GsmLib_PlusString + l_SMSCenter;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   20
 DST    ; Level 1
 LEA  _GsmLib_PlusString
 SCON 
 LEAX l_SMSCenter
#debug string l_SMSCenter
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX l_SMSCenter
 WRI  
 LEAX l_SMSCenter
 LD   20
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string l_SMSCenter
 PDST   ; Level 1
#srcline 693 ;            END_IF;
SMS_HANDLER_3_L183:
#srcline 694 ;          ELSE
 JMP  SMS_HANDLER_3_L182
SMS_HANDLER_3_L181:
#srcline 695 ;            pusint  := pusint + 2;
 LEAY pusint
 LDIL 
#debug pointer pusint
 LD   udint 2
 ADD
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 696 ;          END_IF;
SMS_HANDLER_3_L182:
#srcline 697 ;          StatTime := LREAL_TO_DATE_AND_TIME(0.0);
 LDQ  lreal 0.0
 WRX  StatTime
#debug_left dt StatTime
#srcline 698 ;          RecvTime := LREAL_TO_DATE_AND_TIME(0.0);
 LDQ  lreal 0.0
 WRX  RecvTime
#debug_left dt RecvTime
#srcline 699 ;          firstOctet := _GsmLib_HEX_TO_BYTE(pusint);
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LEA  __Instance___GsmLib_HEX_TO_BYTE~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_HEX_TO_BYTE~HEX
 PRV
 LEA  __Instance___GsmLib_HEX_TO_BYTE
 CAL  _GsmLib_HEX_TO_BYTE_L0
 WRY  firstOctet
#debug_left byte firstOctet
#srcline 700 ;          IF firstOctet <> 16#FF THEN
 LDY  firstOctet
#debug byte firstOctet
 LD   byte $FF
 EQ
 NEG
 JMC  SMS_HANDLER_3_L185
#srcline 701 ;            MessStat := firstOctet.1;
 LDY  firstOctet.1
#debug bool firstOctet.1
 WRX  MessStat
#debug_left bool MessStat
#srcline 702 ;            IF firstOctet.0 OR firstOctet.1 THEN //firstOctet AND 3 > 0 THEN
 LDY  firstOctet.0
#debug bool firstOctet.0
 LDY  firstOctet.1
#debug bool firstOctet.1
 OR  
 JMC  SMS_HANDLER_3_L187
#srcline 703 ;              //SMS STATUS REPORT OR SMS SUBMIT
#srcline 704 ;              pusint   := pusint + 2;
 LEAY pusint
 LDIL 
#debug pointer pusint
 LD   udint 2
 ADD
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 705 ;              SmsRef   := BYTE_TO_USINT(_GsmLib_HEX_TO_BYTE(pusint));
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LEA  __Instance___GsmLib_HEX_TO_BYTE~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_HEX_TO_BYTE~HEX
 PRV
 LEA  __Instance___GsmLib_HEX_TO_BYTE
 CAL  _GsmLib_HEX_TO_BYTE_L0
 WRX  SmsRef
#debug_left usint SmsRef
#srcline 706 ;            ELSE
 JMP  SMS_HANDLER_3_L188
SMS_HANDLER_3_L187:
#srcline 707 ;              //SMS STATUS DELIVERY
#srcline 708 ;              SmsRef := 0;
 LD   usint 0
 WRX  SmsRef
#debug_left usint SmsRef
#srcline 709 ;            END_IF;
SMS_HANDLER_3_L188:
#srcline 710 ;            pusint := pusint + 2;
 LEAY pusint
 LDIL 
#debug pointer pusint
 LD   udint 2
 ADD
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 711 ;            lenNum := BYTE_TO_USINT(_GsmLib_HEX_TO_BYTE(pusint));
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LEA  __Instance___GsmLib_HEX_TO_BYTE~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_HEX_TO_BYTE~HEX
 PRV
 LEA  __Instance___GsmLib_HEX_TO_BYTE
 CAL  _GsmLib_HEX_TO_BYTE_L0
 WRY  lenNum
#debug_left usint lenNum
#srcline 712 ;            typNum := _GsmLib_HEX_TO_BYTE(pusint+2);
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LD   udint 2
 ADD
 LEA  __Instance___GsmLib_HEX_TO_BYTE~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_HEX_TO_BYTE~HEX
 PRV
 LEA  __Instance___GsmLib_HEX_TO_BYTE
 CAL  _GsmLib_HEX_TO_BYTE_L0
 WRY  typNum
#debug_left byte typNum
#srcline 713 ;            pusint := pusint + 4 + USINT_TO_UDINT(_GsmLib_DecodeSemiOctetsNumber(pusint+4, lenNum, Sender));
 LEAY pusint
 LDIL 
#debug pointer pusint
 LD   udint 4
 ADD
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LD   udint 4
 ADD
 LEA  __Instance___GsmLib_DecodeSemiOctetsNumber~IN
 WRIL 
#debug_left udint __Instance___GsmLib_DecodeSemiOctetsNumber~IN
 LDY  lenNum
#debug usint lenNum
 WR   __Instance___GsmLib_DecodeSemiOctetsNumber~LNG
#debug_left usint __Instance___GsmLib_DecodeSemiOctetsNumber~LNG
 LDX  Sender
 WR   __Instance___GsmLib_DecodeSemiOctetsNumber~Num
#debug_left pointer __Instance___GsmLib_DecodeSemiOctetsNumber.Num
 PRV
 LEA  __Instance___GsmLib_DecodeSemiOctetsNumber
 CAL  _GsmLib_DecodeSemiOctetsNumber_L0
 ADD
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 714 ;            IF typNum.4 THEN
 LDY  typNum.4
#debug bool typNum.4
 JMC  SMS_HANDLER_3_L189
#srcline 715 ;              Sender := _GsmLib_PlusString + Sender;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   20
 DST    ; Level 1
 LEA  _GsmLib_PlusString
 SCON 
 LDX  Sender
#debug string Sender
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  Sender
 WRI  
 LDX  Sender
 LD   20
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string Sender
 PDST   ; Level 1
#srcline 716 ;            END_IF;
SMS_HANDLER_3_L189:
#srcline 717 ;            IF NOT firstOctet.1 THEN
 LDY  firstOctet.1
#debug bool firstOctet.1
 NEG
 JMC  SMS_HANDLER_3_L191
#srcline 718 ;              //NOT SMS STATUS
#srcline 719 ;              protId   := _GsmLib_HEX_TO_BYTE(pusint);
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LEA  __Instance___GsmLib_HEX_TO_BYTE~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_HEX_TO_BYTE~HEX
 PRV
 LEA  __Instance___GsmLib_HEX_TO_BYTE
 CAL  _GsmLib_HEX_TO_BYTE_L0
 WRY  protId
#debug_left byte protId
#srcline 720 ;              dataCode := _GsmLib_HEX_TO_BYTE(pusint+2);
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LD   udint 2
 ADD
 LEA  __Instance___GsmLib_HEX_TO_BYTE~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_HEX_TO_BYTE~HEX
 PRV
 LEA  __Instance___GsmLib_HEX_TO_BYTE
 CAL  _GsmLib_HEX_TO_BYTE_L0
 WRY  dataCode
#debug_left byte dataCode
#srcline 721 ;              pusint   := pusint + 4;
 LEAY pusint
 LDIL 
#debug pointer pusint
 LD   udint 4
 ADD
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 722 ;            END_IF;
SMS_HANDLER_3_L191:
#srcline 723 ;            RecvTime := _GsmLib_GetGSMDateTime(pusint);
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LEA  __Instance___GsmLib_GetGSMDateTime~pGSMDT
 WRIL 
#debug_left udint __Instance___GsmLib_GetGSMDateTime~pGSMDT
 PRV
 LEA  __Instance___GsmLib_GetGSMDateTime
 CAL  _GsmLib_GetGSMDateTime_L0
 WRX  RecvTime
#debug_left dt RecvTime
#srcline 724 ;            IF DT_TO_LREAL(RecvTime) = 0.0 THEN
 LDX  RecvTime
#debug dt RecvTime
 LDQ  lreal 0.0
 EQDF
 JMC  SMS_HANDLER_3_L193
#srcline 725 ;              pusint := pusint + 2;
 LEAY pusint
 LDIL 
#debug pointer pusint
 LD   udint 2
 ADD
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 726 ;            ELSE
 JMP  SMS_HANDLER_3_L194
SMS_HANDLER_3_L193:
#srcline 727 ;              pusint := pusint + 14;
 LEAY pusint
 LDIL 
#debug pointer pusint
 LD   udint 14
 ADD
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 728 ;            END_IF;
SMS_HANDLER_3_L194:
#srcline 729 ;            IF firstOctet.1 THEN
 LDY  firstOctet.1
#debug bool firstOctet.1
 JMC  SMS_HANDLER_3_L195
#srcline 730 ;              //SMS STATUS
#srcline 731 ;              StatTime := _GsmLib_GetGSMDateTime(pusint);
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LEA  __Instance___GsmLib_GetGSMDateTime~pGSMDT
 WRIL 
#debug_left udint __Instance___GsmLib_GetGSMDateTime~pGSMDT
 PRV
 LEA  __Instance___GsmLib_GetGSMDateTime
 CAL  _GsmLib_GetGSMDateTime_L0
 WRX  StatTime
#debug_left dt StatTime
#srcline 732 ;              IF DT_TO_LREAL(StatTime) = 0.0 THEN
 LDX  StatTime
#debug dt StatTime
 LDQ  lreal 0.0
 EQDF
 JMC  SMS_HANDLER_3_L197
#srcline 733 ;                pusint := pusint + 2;
 LEAY pusint
 LDIL 
#debug pointer pusint
 LD   udint 2
 ADD
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 734 ;              ELSE
 JMP  SMS_HANDLER_3_L198
SMS_HANDLER_3_L197:
#srcline 735 ;                pusint := pusint + 14;
 LEAY pusint
 LDIL 
#debug pointer pusint
 LD   udint 14
 ADD
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 736 ;              END_IF;
SMS_HANDLER_3_L198:
#srcline 737 ;              MessStatCode := BYTE_TO_USINT(_GsmLib_HEX_TO_BYTE(pusint));
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LEA  __Instance___GsmLib_HEX_TO_BYTE~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_HEX_TO_BYTE~HEX
 PRV
 LEA  __Instance___GsmLib_HEX_TO_BYTE
 CAL  _GsmLib_HEX_TO_BYTE_L0
 WRX  MessStatCode
#debug_left usint MessStatCode
#srcline 738 ;            ELSE
 JMP  SMS_HANDLER_3_L196
SMS_HANDLER_3_L195:
#srcline 739 ;              StatTime  := REAL_TO_DT(0.0);
 LD   real 0.0
 FDF
 WRX  StatTime
#debug_left dt StatTime
#srcline 740 ;              tusint    := BYTE_TO_USINT(_GsmLib_HEX_TO_BYTE(pusint));
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LEA  __Instance___GsmLib_HEX_TO_BYTE~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_HEX_TO_BYTE~HEX
 PRV
 LEA  __Instance___GsmLib_HEX_TO_BYTE
 CAL  _GsmLib_HEX_TO_BYTE_L0
 WRY  tusint
#debug_left usint tusint
#srcline 741 ;              pusint    := pusint + 2;
 LEAY pusint
 LDIL 
#debug pointer pusint
 LD   udint 2
 ADD
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 742 ;              IF firstOctet.6 THEN
 LDY  firstOctet.6
#debug bool firstOctet.6
 JMC  SMS_HANDLER_3_L199
#srcline 743 ;                lenUserHead := 1 + BYTE_TO_USINT(_GsmLib_HEX_TO_BYTE(pusint));
 LD   usint 1
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LEA  __Instance___GsmLib_HEX_TO_BYTE~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_HEX_TO_BYTE~HEX
 PRV
 LEA  __Instance___GsmLib_HEX_TO_BYTE
 CAL  _GsmLib_HEX_TO_BYTE_L0
 ADD
 AND  $FF
 WRY  lenUserHead
#debug_left usint lenUserHead
#srcline 744 ;              ELSE
 JMP  SMS_HANDLER_3_L200
SMS_HANDLER_3_L199:
#srcline 745 ;                lenUserHead := 0;
 LD   usint 0
 WRY  lenUserHead
#debug_left usint lenUserHead
#srcline 746 ;              END_IF;
SMS_HANDLER_3_L200:
#srcline 747 ;              IF dataCode.3 THEN
 LDY  dataCode.3
#debug bool dataCode.3
 JMC  SMS_HANDLER_3_L201
#srcline 748 ;                tusint := _GsmLib_Decode16bitHEX(HEX := pusint, N := tusint, U := lenuserhead, Text := RecvMess);
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LEA  __Instance___GsmLib_Decode16bitHEX~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_Decode16bitHEX~HEX
 LDY  tusint
#debug usint tusint
 WR   __Instance___GsmLib_Decode16bitHEX~N
#debug_left usint __Instance___GsmLib_Decode16bitHEX~N
 LDY  lenuserhead
#debug usint lenuserhead
 WR   __Instance___GsmLib_Decode16bitHEX~U
#debug_left usint __Instance___GsmLib_Decode16bitHEX~U
 LDX  RecvMess
 WR   __Instance___GsmLib_Decode16bitHEX~Text
#debug_left pointer __Instance___GsmLib_Decode16bitHEX.Text
 PRV
 LEA  __Instance___GsmLib_Decode16bitHEX
 CAL  _GsmLib_Decode16bitHEX_L0
 WRY  tusint
#debug_left usint tusint
#srcline 749 ;              ELSIF dataCode.2 THEN
 JMP  SMS_HANDLER_3_L202
SMS_HANDLER_3_L201:
 LDY  dataCode.2
#debug bool dataCode.2
 JMC  SMS_HANDLER_3_L203
#srcline 750 ;                tusint := _GsmLib_Decode8bitHEX(HEX := pusint, N := tusint, U := lenuserhead, Text := RecvMess);
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LEA  __Instance___GsmLib_Decode8bitHEX~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_Decode8bitHEX~HEX
 LDY  tusint
#debug usint tusint
 WR   __Instance___GsmLib_Decode8bitHEX~N
#debug_left usint __Instance___GsmLib_Decode8bitHEX~N
 LDY  lenuserhead
#debug usint lenuserhead
 WR   __Instance___GsmLib_Decode8bitHEX~U
#debug_left usint __Instance___GsmLib_Decode8bitHEX~U
 LDX  RecvMess
 WR   __Instance___GsmLib_Decode8bitHEX~Text
#debug_left pointer __Instance___GsmLib_Decode8bitHEX.Text
 PRV
 LEA  __Instance___GsmLib_Decode8bitHEX
 CAL  _GsmLib_Decode8bitHEX_L0
 WRY  tusint
#debug_left usint tusint
#srcline 751 ;              ELSE
 JMP  SMS_HANDLER_3_L202
SMS_HANDLER_3_L203:
#srcline 752 ;                tusint := _GsmLib_Decode7bitHEX(HEX := pusint, N := tusint, U := lenuserhead, Text := RecvMess);
 NXT
 LEAY pusint
 LDIL 
#debug pointer pusint
 LEA  __Instance___GsmLib_Decode7bitHEX~HEX
 WRIL 
#debug_left udint __Instance___GsmLib_Decode7bitHEX~HEX
 LDY  tusint
#debug usint tusint
 WR   __Instance___GsmLib_Decode7bitHEX~N
#debug_left usint __Instance___GsmLib_Decode7bitHEX~N
 LDY  lenuserhead
#debug usint lenuserhead
 WR   __Instance___GsmLib_Decode7bitHEX~U
#debug_left usint __Instance___GsmLib_Decode7bitHEX~U
 LDX  RecvMess
 WR   __Instance___GsmLib_Decode7bitHEX~Text
#debug_left pointer __Instance___GsmLib_Decode7bitHEX.Text
 PRV
 LEA  __Instance___GsmLib_Decode7bitHEX
 CAL  _GsmLib_Decode7bitHEX_L0
 WRY  tusint
#debug_left usint tusint
#srcline 753 ;              END_IF;
SMS_HANDLER_3_L202:
#srcline 754 ;            END_IF;
SMS_HANDLER_3_L196:
#srcline 755 ;          END_IF;
SMS_HANDLER_3_L185:
#srcline 756 ;          State := ggso_ReadOk;
 LD   udint 16  ; TGSMGateStateOut#ggso_ReadOk
 WRX  State
#debug_left usint State
 JMP  SMS_HANDLER_3_L93
SMS_HANDLER_3_L180:
 LD   16
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_3_L204
#srcline 757 ;        ggso_ReadOk:
#srcline 758 ;          IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_3_L205
#srcline 759 ;            InitDone := true;
 LD   bool -1       ; true
 WRX  InitDone
#debug_left bool InitDone
#srcline 760 ;            IF OctetCnt > 0 THEN
 LDX  OctetCnt
#debug usint OctetCnt
 LD   usint 0
 GT
 JMC  SMS_HANDLER_3_L207
#srcline 761 ;              NewMess := NOT MessStat;
 LDX  MessStat
#debug bool MessStat
 NEG
 WRX  NewMess
#debug_left bool NewMess
#srcline 762 ;              NewStat := MessStat;
 LDX  MessStat
#debug bool MessStat
 WRX  NewStat
#debug_left bool NewStat
#srcline 763 ;              IF NewStat THEN
 LDX  NewStat
#debug bool NewStat
 JMC  SMS_HANDLER_3_L209
#srcline 764 ;                pusint := ADR(StatCode);
 LEAX StatCode
#debug pointer StatCode
 LEAY pusint
 WRIL 
#debug_left pointer pusint
#srcline 765 ;                CASE MessStatCode OF
 LDX  MessStatCode
#debug usint MessStatCode
 WRY  P4__st__
 LDY  P4__st__
 LD   $02
 GT  
 JMD SMS_HANDLER_3_L212
 LDY  P4__st__
 LD   $00
 LT  
 JMD SMS_HANDLER_3_L212
#srcline 766 ;                  16#00..16#02 :
#srcline 767 ;                    pusint^ := MessStatCode + 1;
 LDX  MessStatCode
#debug usint MessStatCode
 LD   usint 1
 ADD
 AND  $FF
 LEAY pusint
 LDIL    ; dereference 
 WRI 
#debug_left usint pusint^
 JMP  SMS_HANDLER_3_L211
SMS_HANDLER_3_L212:
 LDY  P4__st__
 LD   $25
 GT  
 JMD SMS_HANDLER_3_L213
 LDY  P4__st__
 LD   $20
 LT  
 JMD SMS_HANDLER_3_L213
#srcline 768 ;                  16#20..16#25 :
#srcline 769 ;                    pusint^ := MessStatCode - 16#1D; // + 4 - 16#20
 LDX  MessStatCode
#debug usint MessStatCode
 LD   usint $1D
 SUB
 AND  $FF
 LEAY pusint
 LDIL    ; dereference 
 WRI 
#debug_left usint pusint^
 JMP  SMS_HANDLER_3_L211
SMS_HANDLER_3_L213:
 LDY  P4__st__
 LD   $49
 GT  
 JMD SMS_HANDLER_3_L214
 LDY  P4__st__
 LD   $40
 LT  
 JMD SMS_HANDLER_3_L214
#srcline 770 ;                  16#40..16#49 :
#srcline 771 ;                    pusint^ := MessStatCode - 16#36; // + 10 - 16#40
 LDX  MessStatCode
#debug usint MessStatCode
 LD   usint $36
 SUB
 AND  $FF
 LEAY pusint
 LDIL    ; dereference 
 WRI 
#debug_left usint pusint^
 JMP  SMS_HANDLER_3_L211
SMS_HANDLER_3_L214:
#srcline 772 ;                ELSE
#srcline 773 ;                  StatCode     := ggss_Unknown;
 LD   udint 0  ; TGSMGateSmsStatus#ggss_Unknown
 WRX  StatCode
#debug_left usint StatCode
#srcline 774 ;                END_CASE;
SMS_HANDLER_3_L211:
#srcline 775 ;              ELSE
 JMP  SMS_HANDLER_3_L210
SMS_HANDLER_3_L209:
#srcline 776 ;                StatCode     := ggss_Unknown;
 LD   udint 0  ; TGSMGateSmsStatus#ggss_Unknown
 WRX  StatCode
#debug_left usint StatCode
#srcline 777 ;              END_IF;
SMS_HANDLER_3_L210:
#srcline 778 ;              State := ggso_EraseOne;
 LD   udint 13  ; TGSMGateStateOut#ggso_EraseOne
 WRX  State
#debug_left usint State
#srcline 779 ;              MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 780 ;            ELSIF SendPending THEN
 JMP  SMS_HANDLER_3_L208
SMS_HANDLER_3_L207:
 LDX  SendPending
#debug bool SendPending
 JMC  SMS_HANDLER_3_L215
#srcline 781 ;              State := ggso_Send;
 LD   udint 18  ; TGSMGateStateOut#ggso_Send
 WRX  State
#debug_left usint State
#srcline 782 ;            ELSIF UssdPending THEN
 JMP  SMS_HANDLER_3_L208
SMS_HANDLER_3_L215:
 LDX  UssdPending
#debug bool UssdPending
 JMC  SMS_HANDLER_3_L216
#srcline 783 ;              State := ggso_Ussd;
 LD   udint 19  ; TGSMGateStateOut#ggso_Ussd
 WRX  State
#debug_left usint State
#srcline 784 ;            ELSIF DialPending THEN
 JMP  SMS_HANDLER_3_L208
SMS_HANDLER_3_L216:
 LDX  DialPending
#debug bool DialPending
 JMC  SMS_HANDLER_3_L217
#srcline 785 ;              State := ggso_Ringing;
 LD   udint 22  ; TGSMGateStateOut#ggso_Ringing
 WRX  State
#debug_left usint State
#srcline 786 ;              TimeOut.PT := DialTime;
 LDX  DialTime
#debug time DialTime
 WRX  TimeOut~PT
#debug_left time TimeOut.PT
#srcline 787 ;            ELSE
 JMP  SMS_HANDLER_3_L208
SMS_HANDLER_3_L217:
#srcline 788 ;              IF Counter < MessagesCnt THEN
 LDX  Counter
#debug usint Counter
 LDX  MessagesCnt
#debug usint MessagesCnt
 LT
 JMC  SMS_HANDLER_3_L218
#srcline 789 ;                State   := ggso_Read;
 LD   udint 15  ; TGSMGateStateOut#ggso_Read
 WRX  State
#debug_left usint State
#srcline 790 ;                Counter := Counter + 1;
 LDX  Counter
#debug usint Counter
 LD   usint 1
 ADD
 AND  $FF
 WRX  Counter
#debug_left usint Counter
#srcline 791 ;              ELSE //all memory slots read
 JMP  SMS_HANDLER_3_L219
SMS_HANDLER_3_L218:
#srcline 792 ;                State := ggso_SignalQ;
 LD   udint 20  ; TGSMGateStateOut#ggso_SignalQ
 WRX  State
#debug_left usint State
#srcline 793 ;              END_IF;
SMS_HANDLER_3_L219:
#srcline 794 ;            END_IF;
SMS_HANDLER_3_L208:
#srcline 795 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 796 ;          ELSE
 JMP  SMS_HANDLER_3_L206
SMS_HANDLER_3_L205:
#srcline 797 ;            State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 798 ;            Error := gger_Receiving_failed;
 LD   udint 10  ; TGSMGateError#gger_Receiving_failed
 WRX  Error
#debug_left usint Error
#srcline 799 ;          END_IF;
SMS_HANDLER_3_L206:
 JMP  SMS_HANDLER_3_L93
SMS_HANDLER_3_L204:
 LD   20
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_3_L220
#srcline 800 ;        ggso_SignalQ:
#srcline 801 ;          IF FIND(pBuferIN^, _GsmLib_AtReplyCSQ) > 0 THEN
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_AtReplyCSQ
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_3_L221
#srcline 802 ;            pstring := ADR(BuferIN[6]);
 LEAX BuferIN
 ADD  6  ; + offset 
#debug pointer BuferIN[6]
 LEAY pstring
 WRIL 
#debug_left pointer pstring
#srcline 803 ;            tusint := STRING_TO_USINT(pstring^);
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 SCNV $3008;  IEC_STRING _TO_ IEC_USINT
 WRY  tusint
#debug_left usint tusint
#srcline 804 ;            IF tusint = 99 THEN
 LDY  tusint
#debug usint tusint
 LD   usint 99
 EQ
 JMC  SMS_HANDLER_3_L223
#srcline 805 ;              Signal := -1;
 LD   sint -1
 WRX  Signal
#debug_left sint Signal
#srcline 806 ;            ELSE
 JMP  SMS_HANDLER_3_L224
SMS_HANDLER_3_L223:
#srcline 807 ;              Signal := UDINT_TO_SINT((USINT_TO_UDINT(tusint)*100)/31);
 LDY  tusint
#debug usint tusint
 LD   udint 100
 MUL
 LD   udint 31
 DIVL
 EXTB
 WRX  Signal
#debug_left sint Signal
#srcline 808 ;            END_IF;
SMS_HANDLER_3_L224:
#srcline 809 ;          END_IF;
SMS_HANDLER_3_L221:
#srcline 810 ;          State := ggso_ReadQuery; //and again
 LD   udint 14  ; TGSMGateStateOut#ggso_ReadQuery
 WRX  State
#debug_left usint State
 JMP  SMS_HANDLER_3_L93
SMS_HANDLER_3_L220:
 LD   21
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_3_L225
#srcline 811 ;        ggso_RingNumber:
#srcline 812 ;          Ring := true;
 LD   bool -1       ; true
 WRX  Ring
#debug_left bool Ring
#srcline 813 ;          RingCount := 1;
 LD   usint 1
 WRX  RingCount
#debug_left usint RingCount
#srcline 814 ;          IF FIND(pBuferIN^, _GsmLib_AtReplyCLCC) > 0 THEN
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_AtReplyCLCC
 SFND 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_3_L226
#srcline 815 ;            pos := FIND(pBuferIN^, _GsmLib_QuoteString);
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_QuoteString
 SFND 
 WRY  pos
#debug_left int pos
#srcline 816 ;            IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_3_L228
#srcline 817 ;              pstring := ADR(BuferIN) + INT_TO_UDINT(pos);
 LEAX BuferIN
#debug pointer BuferIN
 LDY  pos
#debug int pos
 EXTW 
 ADD
 LEAY pstring
 WRIL 
#debug_left pointer pstring
#srcline 818 ;              pos := FIND(pstring^, _GsmLib_QuoteString);
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 LEA  _GsmLib_QuoteString
 SFND 
 WRY  pos
#debug_left int pos
#srcline 819 ;              IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_3_L230
#srcline 820 ;                Caller := LEFT(pstring^, Pos-1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   20
 DST    ; Level 1
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 LDY  Pos
#debug int Pos
 EXTW 
 LD   int 1
 SUB
 EXTW
 SLFT 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  Caller
 WRI  
 LDX  Caller
 LD   20
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string Caller
 PDST   ; Level 1
#srcline 821 ;              END_IF;
SMS_HANDLER_3_L230:
#srcline 822 ;            END_IF;
SMS_HANDLER_3_L228:
#srcline 823 ;          END_IF;
SMS_HANDLER_3_L226:
#srcline 824 ;          WaitTime.PT := T#5.5s;    //timeout to cancel call
 LD   time 5500
 WRX  WaitTime~PT
#debug_left time WaitTime.PT
#srcline 825 ;          IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_3_L232
#srcline 826 ;            State := ggso_CancelCall; //cancel call
 LD   udint 23  ; TGSMGateStateOut#ggso_CancelCall
 WRX  State
#debug_left usint State
#srcline 827 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 828 ;          END_IF;
SMS_HANDLER_3_L232:
 JMP  SMS_HANDLER_3_L93
SMS_HANDLER_3_L225:
 LD   22
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_3_L234
#srcline 829 ;        ggso_Ringing:
#srcline 830 ;          IF FIND(pBuferIN^, _GsmLib_AtReplyNOCARRIER) > 0 OR FIND(pBuferIN^, _GsmLib_AtReplyERROR) > 0 THEN
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_AtReplyNOCARRIER
 SFND 
 LD   int 0
 GTS
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_AtReplyERROR
 SFND 
 LD   int 0
 GTS
 OR  
 JMC  SMS_HANDLER_3_L235
#srcline 831 ;            State := ggso_Error;
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 WRX  State
#debug_left usint State
#srcline 832 ;            Error := gger_Dialing_Failed;
 LD   udint 18  ; TGSMGateError#gger_Dialing_Failed
 WRX  Error
#debug_left usint Error
#srcline 833 ;          END_IF;
SMS_HANDLER_3_L235:
#srcline 834 ;          IF ok THEN
 LDX  ok
#debug bool ok
 JMC  SMS_HANDLER_3_L237
#srcline 835 ;            State := ggso_CancelCall;
 LD   udint 23  ; TGSMGateStateOut#ggso_CancelCall
 WRX  State
#debug_left usint State
#srcline 836 ;            MessOut := true;
 LD   bool -1       ; true
 WRX  MessOut
#debug_left bool MessOut
#srcline 837 ;          END_IF;
SMS_HANDLER_3_L237:
 JMP  SMS_HANDLER_3_L93
SMS_HANDLER_3_L234:
 LD   23
 LDY  P3__st__
 EQ  
 JMC  SMS_HANDLER_3_L239
#srcline 838 ;        ggso_CancelCall:
#srcline 839 ;          State := ggso_ReadQuery; //and again
 LD   udint 14  ; TGSMGateStateOut#ggso_ReadQuery
 WRX  State
#debug_left usint State
#srcline 840 ;          DialPending := false;
 LD   bool 0       ; false
 WRX  DialPending
#debug_left bool DialPending
 JMP  SMS_HANDLER_3_L93
SMS_HANDLER_3_L239:
SMS_HANDLER_3_L93:
#srcline 842 ;    END_IF;
SMS_HANDLER_3_L92:
#srcline 843 ;  END_IF;
SMS_HANDLER_3_L81:
#srcline 845 ;  IF State = ggso_Error THEN
 LDX  State
#debug usint State
 LD   udint 24  ; TGSMGateStateOut#ggso_Error
 EQ
 JMC  SMS_HANDLER_3_L240
#srcline 846 ;    pos := FIND(pBuferIN^, _GsmLib_AtReplyERROR);
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_AtReplyERROR
 SFND 
 WRY  pos
#debug_left int pos
#srcline 847 ;    IF pos  > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  SMS_HANDLER_3_L242
#srcline 848 ;      datalen := RecvFrom.lenMess - 2;
 LDX  RecvFrom~lenMess
#debug uint RecvFrom.lenMess
 LD   uint 2
 SUB
 AND  $FFFF
 WRY  datalen
#debug_left uint datalen
#srcline 849 ;      pUsint  := ADR(BuferIN) + UINT_TO_UDINT(datalen);
 LEAX BuferIN
#debug pointer BuferIN
 LDY  datalen
#debug uint datalen
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 850 ;      pusint^ := 0;
 LD   usint 0
 LEAY pusint
 LDIL    ; dereference 
 WRI 
#debug_left usint pusint^
#srcline 851 ;      pstring := ADR(BuferIN) + INT_TO_UDINT(pos) - 1;
 LEAX BuferIN
#debug pointer BuferIN
 LDY  pos
#debug int pos
 EXTW 
 ADD
 LD   udint 1
 SUB
 LEAY pstring
 WRIL 
#debug_left pointer pstring
#srcline 852 ;      RecvMess := pstring^;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   160
 DST    ; Level 1
 LEAY pstring
 LDIL    ; dereference 
#debug string pstring^
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  RecvMess
 WRI  
 LDX  RecvMess
 LD   160
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string RecvMess
 PDST   ; Level 1
#srcline 853 ;      pusint^ := 13;
 LD   usint 13
 LEAY pusint
 LDIL    ; dereference 
 WRI 
#debug_left usint pusint^
#srcline 854 ;    END_IF;
SMS_HANDLER_3_L242:
#srcline 855 ;  END_IF;
SMS_HANDLER_3_L240:
#srcline 857 ;  //debug
#srcline 858 ;  //Stop := true;
#srcline 859 ;  (**)
#srcline 860 ;END_FUNCTION_BLOCK
SMS_HANDLER_3_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
SMS_HANDLER_3__InstanceInit__:
 LINK 0
 LD   time 20000
 WRX  DialTime
 LD   sint -1
 WRX  Signal
 LD   bool -1   ; true
 WRX  MessOut
 LD   bool -1   ; true
 WRX  ColdRestart
 LEAX RecvFrom
 CAL  fbRecvToCrLf__InstanceInit__
 LEAX SendTo
 CAL  fbSendTo__InstanceInit__
 LD   udint $FFFFFFFF    ; nil
 WRX  pusintdbg
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'D:\TECOLIB\GSM_LIBRARYX2\GSMLIBCONTROL\FBSENDSMSTCP_ER75I.ST'
#pou fbSendSmsTcp_ER75i
#srcline 12 ;FUNCTION_BLOCK fbSendSmsTcp_ER75i

#struct fbSendSmsTcp_ER75i__temp__
  pointer pBuferIN,
  usint P0__st__,
  string[257] PS0__st__
#data byte _str_fbSendSmsTcp_ER75i_0 = 
  'A','T','+','C','M','G','F','=','1',$0D,$0A,0
#data byte _str_fbSendSmsTcp_ER75i_1 = 
  'A','T','+','C','M','G','S','=','"',0
#data byte _str_fbSendSmsTcp_ER75i_2 = 
  'A','T',$0D,$0A,0
#data byte _str_fbSendSmsTcp_ER75i_3 = 
  $1A,0
P     61
fbSendSmsTcp_ER75i_L0:
 LINK __SizeOf(fbSendSmsTcp_ER75i__temp__)
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  pBuferIN
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  Send
 LETX __EDGE_R__Send
 WRX  Send
#srcline 60 ;  IF Send THEN
 LDX  Send
#debug bool Send
 JMC  fbSendSmsTcp_ER75i_L1
#srcline 61 ;    SendPending := true;
 LD   bool -1       ; true
 WRX  SendPending
#debug_left bool SendPending
#srcline 62 ;    l_Recipient  := Recipient;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   20
 DST    ; Level 1
 LDX  Recipient
#debug string Recipient
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX l_Recipient
 WRI  
 LEAX l_Recipient
 LD   20
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string l_Recipient
 PDST   ; Level 1
#srcline 63 ;    l_MessToSend := MessToSend;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   160
 DST    ; Level 1
 LDX  MessToSend
#debug string MessToSend
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX l_MessToSend
 WRI  
 LEAX l_MessToSend
 LD   160
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string l_MessToSend
 PDST   ; Level 1
#srcline 64 ;  END_IF;
fbSendSmsTcp_ER75i_L1:
#srcline 65 ;  
#srcline 66 ;{$IFDEF STOPING}
#srcline 67 ;  IF Stop THEN
#srcline 68 ;    RETURN;
#srcline 69 ;  END_IF;
#srcline 70 ;{$END_IF}
#srcline 71 ;  RecvFrom(getMess := 1, lenBuf := 512, chanCode := ChanCode, buffer := BuferIN[0]);
 LD   1
 WRX  RecvFrom~getMess
#debug_left bool RecvFrom~getMess
 LD   uint 512
 WRX  RecvFrom~lenBuf
#debug_left uint RecvFrom~lenBuf
 LDX  ChanCode
#debug uint ChanCode
 WRX  RecvFrom~chanCode
#debug_left uint RecvFrom~chanCode
 LEAX BuferIN
 WRX  RecvFrom~buffer
#debug_left pointer RecvFrom.buffer
 LEAX RecvFrom
 CAL  fbRecvToCrLf_L0
#srcline 72 ;  RecvFrom.reset := false;
 LD   bool 0       ; false
 WRX  RecvFrom~reset
#debug_left bool RecvFrom.reset
#srcline 73 ;  pBuferIN := ADR(BuferIN);
 LEAX BuferIN
#debug pointer BuferIN
 LEAY pBuferIN
 WRIL 
#debug_left pointer pBuferIN
#srcline 74 ;  NewMess  := RecvFrom.lenMess > 2;
 LDX  RecvFrom~lenMess
#debug uint RecvFrom.lenMess
 LD   uint 2
 GT
 WRX  NewMess
#debug_left bool NewMess
#srcline 76 ;  Sent := false;
 LD   bool 0       ; false
 WRX  Sent
#debug_left bool Sent
#srcline 77 ;  Busy := State <> ssts_Ready;
 LDX  State
#debug usint State
 LD   udint 4  ; SendSmsTcp_ER75i_State#ssts_Ready
 EQ
 NEG
 WRX  Busy
#debug_left bool Busy
#srcline 79 ;  (*
#srcline 80 ;  IF RecvFrom.lenMess = 0 THEN
#srcline 81 ;    DebugText := '';
#srcline 82 ;  ELSE
#srcline 83 ;    DebugText := UINT_TO_STRING(RecvFrom.lenMess) + '-' +  pBuferIN^;
#srcline 84 ;  END_IF;
#srcline 85 ;  *)
#srcline 86 ;  
#srcline 87 ;  IF NewMess THEN
 LDX  NewMess
#debug bool NewMess
 JMC  fbSendSmsTcp_ER75i_L3
#srcline 88 ;    Ok := FIND(pBuferIN^,_GsmLib_OkString) > 0;
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_OkString
 SFND 
 LD   int 0
 GTS
 WRX  Ok
#debug_left bool Ok
#srcline 89 ;  END_IF;
fbSendSmsTcp_ER75i_L3:
#srcline 91 ;  Connected := IsEstabTCPconnection(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 WRX  Connected
#debug_left bool Connected
#srcline 93 ;  timer(IN := NOT NewMess AND OldState = State AND State <> ssts_Idle, PT := timeout);
 LDX  NewMess
#debug bool NewMess
 NEG
 LDX  OldState
#debug usint OldState
 LDX  State
#debug usint State
 EQ
 AND
 LDX  State
#debug usint State
 LD   udint 0  ; SendSmsTcp_ER75i_State#ssts_Idle
 EQ
 NEG
 AND
 WRX  timer~IN
#debug_left bool timer~IN
 LDX  timeout
#debug time timeout
 WRX  timer~PT
#debug_left time timer~PT
 LEAX timer
 CAL  TON_L0
#srcline 94 ;  OldState := State;
 LDX  State
#debug usint State
 WRX  OldState
#debug_left usint OldState
#srcline 95 ;  
#srcline 97 ;  GetRemoteIPaddress(chanCode := ChanCode, ethAdr := ethAdr);
 NXT
 LDX  ChanCode
#debug uint ChanCode
 WR   __Instance__GetRemoteIPaddress~chanCode
#debug_left uint __Instance__GetRemoteIPaddress~chanCode
 LEAX ethAdr
 WR   __Instance__GetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__GetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__GetRemoteIPaddress
 CAL  GetRemoteIPaddress_L0
#srcline 98 ;  IF State = ssts_Ready AND (NOT Connected OR ethAdr.remoteIP <> IPadr OR ethAdr.remotePort <> Port) THEN
 LDX  State
#debug usint State
 LD   udint 4  ; SendSmsTcp_ER75i_State#ssts_Ready
 EQ
 LDX  Connected
#debug bool Connected
 NEG
 LEAX ethAdr~remoteIP
 LEAX IPadr
 LD   4   ; SizeOf()
 BCMP 
 EQ   0
 NEG
 OR  
 LDX  ethAdr~remotePort
#debug uint ethAdr.remotePort
 LDX  Port
#debug uint Port
 EQ
 NEG
 OR  
 AND
 JMC  fbSendSmsTcp_ER75i_L5
#srcline 99 ;    State := ssts_Err;
 LD   udint 9  ; SendSmsTcp_ER75i_State#ssts_Err
 WRX  State
#debug_left usint State
#srcline 100 ;  END_IF;
fbSendSmsTcp_ER75i_L5:
#srcline 101 ;  
#srcline 102 ;  CASE State OF
 LDX  State
#debug usint State
 WRY  P0__st__
 LD   0
 LDY  P0__st__
 EQ  
 JMC  fbSendSmsTcp_ER75i_L8
#srcline 103 ;    ssts_Idle :
#srcline 104 ;      RecvFrom.reset := true;
 LD   bool -1       ; true
 WRX  RecvFrom~reset
#debug_left bool RecvFrom.reset
#srcline 105 ;      CloseTCPconnection(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 106 ;      IF Conn AND NOT Connected THEN //pøipojit TCP
 LDX  Conn
#debug bool Conn
 LDX  Connected
#debug bool Connected
 NEG
 AND
 JMC  fbSendSmsTcp_ER75i_L9
#srcline 107 ;        State := ssts_Init;
 LD   udint 1  ; SendSmsTcp_ER75i_State#ssts_Init
 WRX  State
#debug_left usint State
#srcline 108 ;      END_IF;
fbSendSmsTcp_ER75i_L9:
 JMP  fbSendSmsTcp_ER75i_L7
fbSendSmsTcp_ER75i_L8:
 LD   1
 LDY  P0__st__
 EQ  
 JMC  fbSendSmsTcp_ER75i_L11
#srcline 109 ;    ssts_Init :  //nastavit adresu
#srcline 110 ;      ethAdr.remoteIP := IPadr;
 LEAX IPadr
#debug pointer IPadr
 SRC  %IB0
 LEAX ethAdr~remoteIP
#debug_left pointer ethAdr.remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 111 ;      ethAdr.remotePort := port;
 LDX  port
#debug uint port
 WRX  ethAdr~remotePort
#debug_left uint ethAdr.remotePort
#srcline 112 ;      ethAdr.localPort := 0;
 LD   uint 0
 WRX  ethAdr~localPort
#debug_left uint ethAdr.localPort
#srcline 113 ;      
#srcline 114 ;      IF SetRemoteIPaddress(rq := 1, chanCode := chanCode, ethAdr := ethAdr) THEN
 NXT
 LD   1
 WR   __Instance__SetRemoteIPaddress~rq
#debug_left bool __Instance__SetRemoteIPaddress~rq
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__SetRemoteIPaddress~chanCode
#debug_left uint __Instance__SetRemoteIPaddress~chanCode
 LEAX ethAdr
 WR   __Instance__SetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__SetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__SetRemoteIPaddress
 CAL  SetRemoteIPaddress_L0
 JMC  fbSendSmsTcp_ER75i_L12
#srcline 115 ;        State := ssts_Conn;
 LD   udint 2  ; SendSmsTcp_ER75i_State#ssts_Conn
 WRX  State
#debug_left usint State
#srcline 116 ;        EstabTCPconnection(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__EstabTCPconnection~chanCode
#debug_left uint __Instance__EstabTCPconnection~chanCode
 PRV
 LEA  __Instance__EstabTCPconnection
 CAL  EstabTCPconnection_L0
#srcline 117 ;      END_IF;
fbSendSmsTcp_ER75i_L12:
 JMP  fbSendSmsTcp_ER75i_L7
fbSendSmsTcp_ER75i_L11:
 LD   2
 LDY  P0__st__
 EQ  
 JMC  fbSendSmsTcp_ER75i_L14
#srcline 118 ;    ssts_Conn : //poèkat na spojení
#srcline 119 ;      IF Connected THEN
 LDX  Connected
#debug bool Connected
 JMC  fbSendSmsTcp_ER75i_L15
#srcline 120 ;        SendTo.rq := true;
 LD   bool -1       ; true
 WRX  SendTo~rq
#debug_left bool SendTo.rq
#srcline 121 ;        DataOut := 'AT+CMGF=1$r$n';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbSendSmsTcp_ER75i_0
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX DataOut
 WRI  
 LEAX DataOut
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string DataOut
 PDST   ; Level 1
#srcline 122 ;        State := ssts_TextMode;
 LD   udint 3  ; SendSmsTcp_ER75i_State#ssts_TextMode
 WRX  State
#debug_left usint State
#srcline 123 ;      END_IF;
fbSendSmsTcp_ER75i_L15:
 JMP  fbSendSmsTcp_ER75i_L7
fbSendSmsTcp_ER75i_L14:
 LD   3
 LDY  P0__st__
 EQ  
 JMC  fbSendSmsTcp_ER75i_L17
#srcline 124 ;    ssts_TextMode : //pockat na potvrzeni textoveho rezimu
#srcline 125 ;      IF Ok THEN
 LDX  Ok
#debug bool Ok
 JMC  fbSendSmsTcp_ER75i_L18
#srcline 126 ;        State := ssts_Ready;
 LD   udint 4  ; SendSmsTcp_ER75i_State#ssts_Ready
 WRX  State
#debug_left usint State
#srcline 127 ;      END_IF;
fbSendSmsTcp_ER75i_L18:
 JMP  fbSendSmsTcp_ER75i_L7
fbSendSmsTcp_ER75i_L17:
 LD   4
 LDY  P0__st__
 EQ  
 JMC  fbSendSmsTcp_ER75i_L20
#srcline 128 ;    ssts_Ready : //èekat na send
#srcline 129 ;      IF NOT Conn THEN //odpojit TCP
 LDX  Conn
#debug bool Conn
 NEG
 JMC  fbSendSmsTcp_ER75i_L21
#srcline 130 ;        State := ssts_Idle;
 LD   udint 0  ; SendSmsTcp_ER75i_State#ssts_Idle
 WRX  State
#debug_left usint State
#srcline 131 ;      END_IF;
fbSendSmsTcp_ER75i_L21:
#srcline 132 ;      IF SendPending THEN
 LDX  SendPending
#debug bool SendPending
 JMC  fbSendSmsTcp_ER75i_L23
#srcline 133 ;        State := ssts_SendingText;
 LD   udint 6  ; SendSmsTcp_ER75i_State#ssts_SendingText
 WRX  State
#debug_left usint State
#srcline 134 ;        SendTo.rq := true;
 LD   bool -1       ; true
 WRX  SendTo~rq
#debug_left bool SendTo.rq
#srcline 135 ;        DataOut := 'AT+CMGS="'+l_Recipient+_GsmLib_QuoteCrLfString;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbSendSmsTcp_ER75i_1
 SCON 
 LEAX l_Recipient
#debug string l_Recipient
 SCON 
 LEA  _GsmLib_QuoteCrLfString
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX DataOut
 WRI  
 LEAX DataOut
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string DataOut
 PDST   ; Level 1
#srcline 136 ;      END_IF;
fbSendSmsTcp_ER75i_L23:
#srcline 137 ;      IF timer.Q THEN
 LDX  timer~Q
#debug bool timer.Q
 JMC  fbSendSmsTcp_ER75i_L25
#srcline 138 ;        SendTo.rq := true;
 LD   bool -1       ; true
 WRX  SendTo~rq
#debug_left bool SendTo.rq
#srcline 139 ;        DataOut := 'AT$r$n';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbSendSmsTcp_ER75i_2
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX DataOut
 WRI  
 LEAX DataOut
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string DataOut
 PDST   ; Level 1
#srcline 140 ;        State := ssts_KeepAlive;
 LD   udint 5  ; SendSmsTcp_ER75i_State#ssts_KeepAlive
 WRX  State
#debug_left usint State
#srcline 141 ;        timer.Q := false;
 LD   bool 0       ; false
 WRX  timer~Q
#debug_left bool timer.Q
#srcline 142 ;      END_IF;
fbSendSmsTcp_ER75i_L25:
 JMP  fbSendSmsTcp_ER75i_L7
fbSendSmsTcp_ER75i_L20:
 LD   5
 LDY  P0__st__
 EQ  
 JMC  fbSendSmsTcp_ER75i_L27
#srcline 143 ;    ssts_KeepAlive : //udrzet spojeni
#srcline 144 ;      IF Ok THEN
 LDX  Ok
#debug bool Ok
 JMC  fbSendSmsTcp_ER75i_L28
#srcline 145 ;        State := ssts_Ready;
 LD   udint 4  ; SendSmsTcp_ER75i_State#ssts_Ready
 WRX  State
#debug_left usint State
#srcline 146 ;      END_IF;
fbSendSmsTcp_ER75i_L28:
 JMP  fbSendSmsTcp_ER75i_L7
fbSendSmsTcp_ER75i_L27:
 LD   6
 LDY  P0__st__
 EQ  
 JMC  fbSendSmsTcp_ER75i_L30
#srcline 147 ;    ssts_SendingText : //poslat text
#srcline 148 ;      IF RecvFrom.lenMess > 0 THEN
 LDX  RecvFrom~lenMess
#debug uint RecvFrom.lenMess
 LD   uint 0
 GT
 JMC  fbSendSmsTcp_ER75i_L31
#srcline 149 ;        SendTo.rq := true;
 LD   bool -1       ; true
 WRX  SendTo~rq
#debug_left bool SendTo.rq
#srcline 150 ;        DataOut := l_MessToSend + '$1A';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX l_MessToSend
#debug string l_MessToSend
 SCON 
 LEA  _str_fbSendSmsTcp_ER75i_3
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX DataOut
 WRI  
 LEAX DataOut
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string DataOut
 PDST   ; Level 1
#srcline 151 ;        State := ssts_WaitingSendAck;
 LD   udint 7  ; SendSmsTcp_ER75i_State#ssts_WaitingSendAck
 WRX  State
#debug_left usint State
#srcline 152 ;      END_IF;
fbSendSmsTcp_ER75i_L31:
 JMP  fbSendSmsTcp_ER75i_L7
fbSendSmsTcp_ER75i_L30:
 LD   7
 LDY  P0__st__
 EQ  
 JMC  fbSendSmsTcp_ER75i_L33
#srcline 153 ;    ssts_WaitingSendAck :
#srcline 154 ;      IF NewMess THEN
 LDX  NewMess
#debug bool NewMess
 JMC  fbSendSmsTcp_ER75i_L34
#srcline 155 ;        IF FIND(pBuferIN^,_GsmLib_AtReplyCMGS) > 0 THEN
 LEAY pBuferIN
 LDIL    ; dereference 
#debug string pBuferIN^
 LEA  _GsmLib_AtReplyCMGS
 SFND 
 LD   int 0
 GTS
 JMC  fbSendSmsTcp_ER75i_L36
#srcline 156 ;          State := ssts_WaitingAck;
 LD   udint 8  ; SendSmsTcp_ER75i_State#ssts_WaitingAck
 WRX  State
#debug_left usint State
#srcline 157 ;        END_IF;
fbSendSmsTcp_ER75i_L36:
#srcline 158 ;      END_IF;
fbSendSmsTcp_ER75i_L34:
 JMP  fbSendSmsTcp_ER75i_L7
fbSendSmsTcp_ER75i_L33:
 LD   8
 LDY  P0__st__
 EQ  
 JMC  fbSendSmsTcp_ER75i_L38
#srcline 159 ;    ssts_WaitingAck : //èekat na potvrzení
#srcline 160 ;      IF NewMess THEN
 LDX  NewMess
#debug bool NewMess
 JMC  fbSendSmsTcp_ER75i_L39
#srcline 161 ;        IF Ok THEN
 LDX  Ok
#debug bool Ok
 JMC  fbSendSmsTcp_ER75i_L41
#srcline 162 ;          Sent := true;
 LD   bool -1       ; true
 WRX  Sent
#debug_left bool Sent
#srcline 163 ;          SendPending := false;
 LD   bool 0       ; false
 WRX  SendPending
#debug_left bool SendPending
#srcline 164 ;          State := ssts_Ready;
 LD   udint 4  ; SendSmsTcp_ER75i_State#ssts_Ready
 WRX  State
#debug_left usint State
#srcline 165 ;        ELSE
 JMP  fbSendSmsTcp_ER75i_L42
fbSendSmsTcp_ER75i_L41:
#srcline 166 ;          State := ssts_Err;
 LD   udint 9  ; SendSmsTcp_ER75i_State#ssts_Err
 WRX  State
#debug_left usint State
#srcline 167 ;        END_IF;
fbSendSmsTcp_ER75i_L42:
#srcline 168 ;      END_IF;
fbSendSmsTcp_ER75i_L39:
 JMP  fbSendSmsTcp_ER75i_L7
fbSendSmsTcp_ER75i_L38:
 LD   9
 LDY  P0__st__
 EQ  
 JMC  fbSendSmsTcp_ER75i_L43
#srcline 169 ;    ssts_Err  :
#srcline 170 ;      CloseTCPconnection(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 171 ;      IF timer.Q THEN
 LDX  timer~Q
#debug bool timer.Q
 JMC  fbSendSmsTcp_ER75i_L44
#srcline 172 ;        State := ssts_Idle;
 LD   udint 0  ; SendSmsTcp_ER75i_State#ssts_Idle
 WRX  State
#debug_left usint State
#srcline 173 ;        SendPending := false;
 LD   bool 0       ; false
 WRX  SendPending
#debug_left bool SendPending
#srcline 174 ;        timer.Q := false;
 LD   bool 0       ; false
 WRX  timer~Q
#debug_left bool timer.Q
#srcline 175 ;      END_IF;
fbSendSmsTcp_ER75i_L44:
 JMP  fbSendSmsTcp_ER75i_L7
fbSendSmsTcp_ER75i_L43:
fbSendSmsTcp_ER75i_L7:
#srcline 177 ;  
#srcline 178 ;  
#srcline 179 ;  SendTo(chanCode := chanCode, lenTx := LEN(DataOUT), data := void(DataOUT));
 LDX  chanCode
#debug uint chanCode
 WRX  SendTo~chanCode
#debug_left uint SendTo~chanCode
 LEAX DataOUT
#debug string DataOUT
 SLEN 
 WRX  SendTo~lenTx
#debug_left uint SendTo~lenTx
 LEAX DataOUT
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 180 ;  SendTo.rq := false;
 LD   bool 0       ; false
 WRX  SendTo~rq
#debug_left bool SendTo.rq
#srcline 181 ;  Ok := false;
 LD   bool 0       ; false
 WRX  Ok
#debug_left bool Ok
#srcline 182 ;  IF timer.Q THEN
 LDX  timer~Q
#debug bool timer.Q
 JMC  fbSendSmsTcp_ER75i_L46
#srcline 183 ;    State := ssts_Err;
 LD   udint 9  ; SendSmsTcp_ER75i_State#ssts_Err
 WRX  State
#debug_left usint State
#srcline 184 ;  END_IF;
fbSendSmsTcp_ER75i_L46:
#srcline 186 ;{$IFDEF STOPING}
#srcline 187 ;  Stop := 1;
#srcline 188 ;{$END_IF}
#srcline 190 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61

; Initialize - variables
P     61
fbSendSmsTcp_ER75i__InstanceInit__:
 LINK 0
 LD   bool -1   ; true
 WRX  Conn
 LD   uint 50000
 WRX  Port
 LEAX RecvFrom
 CAL  fbRecvToCrLf__InstanceInit__
 LEAX SendTo
 CAL  fbSendTo__InstanceInit__
 LD   time 15000
 WRX  timeout
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
¦¾  š  ›